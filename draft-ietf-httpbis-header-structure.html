<!DOCTYPE html>
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Structured Field Values for HTTP</title><script>
function anchorRewrite() {
  map = { };
  if (window.location.hash.length >= 1) {
    var fragid = window.location.hash.substr(1);
    if (fragid) {
      if (! document.getElementById(fragid)) {
        var prefix = "rfc.";
        var mapped = map[fragid];
        if (mapped) {
          window.location.hash = mapped;
        } else if (fragid.indexOf("section-") == 0) {
          window.location.hash = prefix + "section." + fragid.substring(8);
        } else if (fragid.indexOf("appendix-") == 0) {
          window.location.hash = prefix + "section." + fragid.substring(9);
        } else if (fragid.indexOf("s-") == 0) {
          var postfix = fragid.substring(2);
          if (postfix.startsWith("abstract")) {
            window.location.hash = prefix + postfix;
          } else if (postfix.startsWith("note-")) {
            window.location.hash = prefix + "note." + postfix.substring(5);
          } else {
            window.location.hash = prefix + "section." + postfix;
          }
        } else if (fragid.indexOf("p-") == 0) {
          var r = fragid.substring(2);
          var p = r.indexOf("-");
          if (p >= 0) {
            window.location.hash = prefix + "section." + r.substring(0, p) + ".p." + r.substring(p + 1);
          }
        }
      }
    }  
  }
}
window.addEventListener('hashchange', anchorRewrite);
window.addEventListener('DOMContentLoaded', anchorRewrite);
</script><!--Specified as xml2rfc-ext-css-contents--><style>
body {
  font: 16px "Helvetica Neue","Open Sans",Helvetica,Calibri,sans-serif;
  color: #333;
  font-size-adjust: 0.5;
  line-height: 24px;
  margin: 75px auto;
  max-width: 624px;
  padding: 0 5px;
}

.title, .filename, h1, h2, h3, h4, h5 {
  font: 16px "Roboto Condensed","Helvetica Neue","Open Sans",Helvetica,Calibri,sans-serif;
  font-size-adjust: 0.5;
  font-weight: bold;
  color: #333;
  line-height: 100%;
  margin: 1.2em 0 0.3em;
}
.title, #rfc\.title h1 { font-size: 32px; }
h1, section h1, h2, section h2, section h3, nav h2 { font-size: 20px; }
h3, section h4, h4, section h5 { font-size: 16px; }
h1 a[href], h2 a[href], h3 a[href], h4 a[href] {
  color: #333;
}

table {
  margin-left: 0em;
  border-collapse: collapse;
}
th {
  text-align: left;
  border-bottom: 2px solid #ddd;
}
td {
  border-top: 1px solid #ddd;
  vertical-align: top;
}
tr:nth-child(2n+1) > td,
tr:nth-child(2n+1) > th {
  background-color: #f9f9f9;
}
td.reference {
  max-width: 200px;
  border-top: none;
  padding-right: 1em;
}
.right {
  text-align: right;
}


table.header, table#rfc\.headerblock {
  width: 100%;
}
table.header td, table#rfc\.headerblock td {
  border: none;
  background-color: transparent;
  color: black;
  padding: 0;
}
.filename {
  display: block;
  color: rgb(119, 119, 119);
  font-size: 20px;
  font-weight: normal;
  line-height: 100%;
  margin: 10px 0 32px;
}
#rfc\.abstract+p, #rfc\.abstract+p code, #rfc\.abstract+p samp, #rfc\.abstract+p tt {
  font-size: 20px;
  line-height: 28px;
}

samp, tt, code, pre, span.tt {
  font-size: 13.5px;
  font-family: Consolas, monospace;
  font-size-adjust: none;
}
pre {
  background-color: #eee;
  border: 1px solid #ddd;
  overflow-x: auto;
  padding: 5px;
  margin: 5px;
}
.figure, caption {
  font-style: italic;
  margin: 0 1.5em;
  text-align: left;
}

address {
  margin: 16px 2px;
  line-height: 20px;
}
.vcard {
  font-style: normal;
}
.vcardline {
  display: block;
}
.vcardline .fn, address b {
  font-weight: normal;
}
.vcardline .hidden {
  display: none;
}

dl {
  margin-left: 1em;
}
dl.dl-horizontal: {
  margin-left: 0;
}
dl > dt {
  float: left;
  margin-right: 1em;
}
dl.nohang > dt {
  float: none;
}
dl > dd {
  margin-bottom: .5em;
}
dl.compact > dd {
  margin-bottom: 0em;
}
dl > dd > dl {
  margin-top: 0.5em;
  margin-bottom: 0em;
}
ul.empty {
  list-style-type: none;
}
ul.empty li {
  margin-top: .5em;
}

hr {
  border: 0;
  border-top: 1px solid #eee;
}
hr.noprint {
  display: none;
}

a {
  text-decoration: none;
}
a[href] {
  color: #2a6496;
}
a[href]:hover {
  background-color: #eee;
}

p, ol, ul, li {
  padding: 0;
}
p {
  margin: 0.5em 0;
}
ol, ul {
  margin: 0.2em 0 0.2em 2em;
}
li {
  margin: 0.2em 0;
}
address {
  font-style: normal;
}

ul.toc ul {
  margin: 0 0 0 2em;
}
ul.toc li {
  list-style: none;
  margin: 0;
}

@media screen and (min-width: 924px) {
  body {
    padding-right: 350px;
  }
  body>ul.toc, body>#rfc\.toc {
    position: fixed;
    bottom: 0;
    right: 0;
    right: calc(50vw - 500px);
    width: 300px;
    z-index: 1;
    overflow: auto;
    overscroll-behavior: contain;
  }
  body>#rfc\.toc {
    top: 55px;
  }
  body>ul.toc {
    top: 100px;
  }

  ul.toc {
    margin: 0 0 0 4px;
    font-size: 12px;
    line-height: 20px;
  }
  ul.toc ul {
    margin-left: 1.2em;
  }
}</style><link rel="Contents" href="#rfc.toc"><link rel="Author" href="#rfc.authors"><link rel="License" href="#rfc.copyrightnotice"><link rel="Chapter" title="1 Introduction" href="#rfc.section.1"><link rel="Chapter" title="2 Defining New Structured Fields" href="#rfc.section.2"><link rel="Chapter" title="3 Structured Data Types" href="#rfc.section.3"><link rel="Chapter" title="4 Working With Structured Fields in HTTP" href="#rfc.section.4"><link rel="Chapter" title="5 IANA Considerations" href="#rfc.section.5"><link rel="Chapter" title="6 Security Considerations" href="#rfc.section.6"><link rel="Chapter" title="7 References" href="#rfc.section.7"><link rel="Appendix" title="A Frequently Asked Questions" href="#rfc.section.A"><link rel="Appendix" title="B Implementation Notes" href="#rfc.section.B"><link rel="Appendix" title="C Changes" href="#rfc.section.C"><link rel="Appendix" title="Acknowledgements" href="#rfc.section.unnumbered-1"><meta name="viewport" content="initial-scale=1"><meta name="generator" content="http://greenbytes.de/tech/webdav/rfc2629.xslt, Revision 1.1327, 2020/09/24 11:13:36, XSLT vendor: libxslt http://xmlsoft.org/XSLT/, via: https://github.com/cabo/kramdown-rfc2629 version 1.3.10"><meta name="keywords" content="Internet-Draft"><link rel="schema.dcterms" href="http://purl.org/dc/terms/"><meta name="dcterms.creator" content="Nottingham, M."><meta name="dcterms.creator" content="Kamp, P-H."><meta name="dcterms.issued" content="2020-10-05"><meta name="dcterms.abstract" content="This document describes a set of data types and associated algorithms that are intended to make it easier and safer to define and handle HTTP header and trailer fields, known as “Structured Fields”, “Structured Headers”, or “Structured Trailers”. It is intended for use by specifications of new HTTP fields that wish to use a common syntax that is more restrictive than traditional HTTP field values."><meta name="description" content="This document describes a set of data types and associated algorithms that are intended to make it easier and safer to define and handle HTTP header and trailer fields, known as “Structured Fields”, “Structured Headers”, or “Structured Trailers”. It is intended for use by specifications of new HTTP fields that wish to use a common syntax that is more restrictive than traditional HTTP field values."></head><body><header><table class="header" id="rfc.headerblock"><tbody><tr><td class="left">HTTP Working Group</td><td class="right">M. Nottingham</td></tr><tr><td class="left">Internet-Draft</td><td class="right">Fastly</td></tr><tr><td class="left">Intended status: Standards Track</td><td class="right">P-H. Kamp</td></tr><tr><td class="left">Expires: April 8, 2021</td><td class="right">The Varnish Cache Project</td></tr><tr><td class="left"></td><td class="right">October 5, 2020</td></tr></tbody></table><div id="rfc.title"><h1>Structured Field Values for HTTP</h1><div class="filename"><a href="https://datatracker.ietf.org/doc/draft-ietf-httpbis-header-structure" class="smpl">draft-ietf-httpbis-header-structure-latest</a></div></div></header><section><h2 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h2><div id="rfc.abstract.p.1"><p>This document describes a set of data types and associated algorithms that are intended to make it easier and safer to define and handle HTTP header and trailer fields, known as “Structured Fields”, “Structured Headers”, or “Structured Trailers”. It is intended for use by specifications of new HTTP fields that wish to use a common syntax that is more restrictive than traditional HTTP field values.</p></div></section><section class="note"><h2 id="rfc.note.1"><a href="#rfc.note.1">Note to Readers</a></h2><div id="rfc.note.1.p.1"><p><em>RFC EDITOR: please remove this section before publication</em></p></div><div id="rfc.note.1.p.2"><p>Discussion of this draft takes place on the HTTP working group mailing list (ietf-http-wg@w3.org), which is archived at <a href="https://lists.w3.org/Archives/Public/ietf-http-wg/">https://lists.w3.org/Archives/Public/ietf-http-wg/</a>.</p></div><div id="rfc.note.1.p.3"><p>Working Group information can be found at <a href="https://httpwg.github.io/">https://httpwg.github.io/</a>; source code and issues list for this draft can be found at <a href="https://github.com/httpwg/http-extensions/labels/header-structure">https://github.com/httpwg/http-extensions/labels/header-structure</a>.</p></div><div id="rfc.note.1.p.4"><p>Tests for implementations are collected at <a href="https://github.com/httpwg/structured-field-tests">https://github.com/httpwg/structured-field-tests</a>.</p></div><div id="rfc.note.1.p.5"><p>Implementations are tracked at <a href="https://github.com/httpwg/wiki/wiki/Structured-Headers">https://github.com/httpwg/wiki/wiki/Structured-Headers</a>.</p></div></section><section id="rfc.status"><h2><a href="#rfc.status">Status of this Memo</a></h2><div id="rfc.boilerplate.1.p.1"><p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p></div><div id="rfc.boilerplate.1.p.2"><p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF). Note that other groups may also distribute working documents as Internet-Drafts. The list of current Internet-Drafts is at <a href="https://datatracker.ietf.org/drafts/current/">https://datatracker.ietf.org/drafts/current/</a>.</p></div><div id="rfc.boilerplate.1.p.3"><p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time. It is inappropriate to use Internet-Drafts as reference material or to cite them other than as “work in progress”.</p></div><div id="rfc.boilerplate.1.p.4"><p>This Internet-Draft will expire on April 8, 2021.</p></div></section><section id="rfc.copyrightnotice"><h2><a href="#rfc.copyrightnotice">Copyright Notice</a></h2><div id="rfc.boilerplate.2.p.1"><p>Copyright (c) 2020 IETF Trust and the persons identified as the document authors. All rights reserved.</p></div><div id="rfc.boilerplate.2.p.2"><p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (<a href="https://trustee.ietf.org/license-info">https://trustee.ietf.org/license-info</a>) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p></div></section><hr class="noprint"><nav id="rfc.toc"><h2 class="np"><a href="#rfc.toc">Table of Contents</a></h2><ul class="toc"><li><a href="#rfc.section.1">1.</a>   <a href="#introduction">Introduction</a><ul><li><a href="#rfc.section.1.1">1.1.</a>   <a href="#strict">Intentionally Strict Processing</a></li><li><a href="#rfc.section.1.2">1.2.</a>   <a href="#notational-conventions">Notational Conventions</a></li></ul></li><li><a href="#rfc.section.2">2.</a>   <a href="#specify">Defining New Structured Fields</a></li><li><a href="#rfc.section.3">3.</a>   <a href="#types">Structured Data Types</a><ul><li><a href="#rfc.section.3.1">3.1.</a>   <a href="#list">Lists</a><ul><li><a href="#rfc.section.3.1.1">3.1.1.</a>   <a href="#inner-list">Inner Lists</a></li><li><a href="#rfc.section.3.1.2">3.1.2.</a>   <a href="#param">Parameters</a></li></ul></li><li><a href="#rfc.section.3.2">3.2.</a>   <a href="#dictionary">Dictionaries</a></li><li><a href="#rfc.section.3.3">3.3.</a>   <a href="#item">Items</a><ul><li><a href="#rfc.section.3.3.1">3.3.1.</a>   <a href="#integer">Integers</a></li><li><a href="#rfc.section.3.3.2">3.3.2.</a>   <a href="#decimal">Decimals</a></li><li><a href="#rfc.section.3.3.3">3.3.3.</a>   <a href="#string">Strings</a></li><li><a href="#rfc.section.3.3.4">3.3.4.</a>   <a href="#token">Tokens</a></li><li><a href="#rfc.section.3.3.5">3.3.5.</a>   <a href="#binary">Byte Sequences</a></li><li><a href="#rfc.section.3.3.6">3.3.6.</a>   <a href="#boolean">Booleans</a></li></ul></li></ul></li><li><a href="#rfc.section.4">4.</a>   <a href="#text">Working With Structured Fields in HTTP</a><ul><li><a href="#rfc.section.4.1">4.1.</a>   <a href="#text-serialize">Serializing Structured Fields</a><ul><li><a href="#rfc.section.4.1.1">4.1.1.</a>   <a href="#ser-list">Serializing a List</a></li><li><a href="#rfc.section.4.1.2">4.1.2.</a>   <a href="#ser-dictionary">Serializing a Dictionary</a></li><li><a href="#rfc.section.4.1.3">4.1.3.</a>   <a href="#ser-item">Serializing an Item</a></li><li><a href="#rfc.section.4.1.4">4.1.4.</a>   <a href="#ser-integer">Serializing an Integer</a></li><li><a href="#rfc.section.4.1.5">4.1.5.</a>   <a href="#ser-decimal">Serializing a Decimal</a></li><li><a href="#rfc.section.4.1.6">4.1.6.</a>   <a href="#ser-string">Serializing a String</a></li><li><a href="#rfc.section.4.1.7">4.1.7.</a>   <a href="#ser-token">Serializing a Token</a></li><li><a href="#rfc.section.4.1.8">4.1.8.</a>   <a href="#ser-binary">Serializing a Byte Sequence</a></li><li><a href="#rfc.section.4.1.9">4.1.9.</a>   <a href="#ser-boolean">Serializing a Boolean</a></li></ul></li><li><a href="#rfc.section.4.2">4.2.</a>   <a href="#text-parse">Parsing Structured Fields</a><ul><li><a href="#rfc.section.4.2.1">4.2.1.</a>   <a href="#parse-list">Parsing a List</a></li><li><a href="#rfc.section.4.2.2">4.2.2.</a>   <a href="#parse-dictionary">Parsing a Dictionary</a></li><li><a href="#rfc.section.4.2.3">4.2.3.</a>   <a href="#parse-item">Parsing an Item</a></li><li><a href="#rfc.section.4.2.4">4.2.4.</a>   <a href="#parse-number">Parsing an Integer or Decimal</a></li><li><a href="#rfc.section.4.2.5">4.2.5.</a>   <a href="#parse-string">Parsing a String</a></li><li><a href="#rfc.section.4.2.6">4.2.6.</a>   <a href="#parse-token">Parsing a Token</a></li><li><a href="#rfc.section.4.2.7">4.2.7.</a>   <a href="#parse-binary">Parsing a Byte Sequence</a></li><li><a href="#rfc.section.4.2.8">4.2.8.</a>   <a href="#parse-boolean">Parsing a Boolean</a></li></ul></li></ul></li><li><a href="#rfc.section.5">5.</a>   <a href="#iana-considerations">IANA Considerations</a></li><li><a href="#rfc.section.6">6.</a>   <a href="#security-considerations">Security Considerations</a></li><li><a href="#rfc.section.7">7.</a>   <a href="#rfc.references">References</a><ul><li><a href="#rfc.section.7.1">7.1.</a>   <a href="#rfc.references.1">Normative References</a></li><li><a href="#rfc.section.7.2">7.2.</a>   <a href="#rfc.references.2">Informative References</a></li></ul></li><li><a href="#rfc.section.A">Appendix A.</a>   <a href="#faq">Frequently Asked Questions</a><ul><li><a href="#rfc.section.A.1">A.1.</a>   <a href="#why-not-json">Why not JSON?</a></li></ul></li><li><a href="#rfc.section.B">Appendix B.</a>   <a href="#implementation-notes">Implementation Notes</a></li><li><a href="#rfc.section.C">Appendix C.</a>   <a href="#changes">Changes</a><ul><li><a href="#rfc.section.C.1">C.1.</a>   <a href="#since-draft-ietf-httpbis-header-structure-18">Since draft-ietf-httpbis-header-structure-18</a></li><li><a href="#rfc.section.C.2">C.2.</a>   <a href="#since-draft-ietf-httpbis-header-structure-17">Since draft-ietf-httpbis-header-structure-17</a></li><li><a href="#rfc.section.C.3">C.3.</a>   <a href="#since-draft-ietf-httpbis-header-structure-16">Since draft-ietf-httpbis-header-structure-16</a></li><li><a href="#rfc.section.C.4">C.4.</a>   <a href="#since-draft-ietf-httpbis-header-structure-15">Since draft-ietf-httpbis-header-structure-15</a></li><li><a href="#rfc.section.C.5">C.5.</a>   <a href="#since-draft-ietf-httpbis-header-structure-14">Since draft-ietf-httpbis-header-structure-14</a></li><li><a href="#rfc.section.C.6">C.6.</a>   <a href="#since-draft-ietf-httpbis-header-structure-13">Since draft-ietf-httpbis-header-structure-13</a></li><li><a href="#rfc.section.C.7">C.7.</a>   <a href="#since-draft-ietf-httpbis-header-structure-12">Since draft-ietf-httpbis-header-structure-12</a></li><li><a href="#rfc.section.C.8">C.8.</a>   <a href="#since-draft-ietf-httpbis-header-structure-11">Since draft-ietf-httpbis-header-structure-11</a></li><li><a href="#rfc.section.C.9">C.9.</a>   <a href="#since-draft-ietf-httpbis-header-structure-10">Since draft-ietf-httpbis-header-structure-10</a></li><li><a href="#rfc.section.C.10">C.10.</a>   <a href="#since-draft-ietf-httpbis-header-structure-09">Since draft-ietf-httpbis-header-structure-09</a></li><li><a href="#rfc.section.C.11">C.11.</a>   <a href="#since-draft-ietf-httpbis-header-structure-08">Since draft-ietf-httpbis-header-structure-08</a></li><li><a href="#rfc.section.C.12">C.12.</a>   <a href="#since-draft-ietf-httpbis-header-structure-07">Since draft-ietf-httpbis-header-structure-07</a></li><li><a href="#rfc.section.C.13">C.13.</a>   <a href="#since-draft-ietf-httpbis-header-structure-06">Since draft-ietf-httpbis-header-structure-06</a></li><li><a href="#rfc.section.C.14">C.14.</a>   <a href="#since-draft-ietf-httpbis-header-structure-05">Since draft-ietf-httpbis-header-structure-05</a></li><li><a href="#rfc.section.C.15">C.15.</a>   <a href="#since-draft-ietf-httpbis-header-structure-04">Since draft-ietf-httpbis-header-structure-04</a></li><li><a href="#rfc.section.C.16">C.16.</a>   <a href="#since-draft-ietf-httpbis-header-structure-03">Since draft-ietf-httpbis-header-structure-03</a></li><li><a href="#rfc.section.C.17">C.17.</a>   <a href="#since-draft-ietf-httpbis-header-structure-02">Since draft-ietf-httpbis-header-structure-02</a></li><li><a href="#rfc.section.C.18">C.18.</a>   <a href="#since-draft-ietf-httpbis-header-structure-01">Since draft-ietf-httpbis-header-structure-01</a></li><li><a href="#rfc.section.C.19">C.19.</a>   <a href="#since-draft-ietf-httpbis-header-structure-00">Since draft-ietf-httpbis-header-structure-00</a></li></ul></li><li><a href="#acknowledgements">Acknowledgements</a></li><li><a href="#rfc.authors">Authors' Addresses</a></li></ul></nav><section id="introduction"><h2 id="rfc.section.1" class="np"><a href="#rfc.section.1">1.</a> <a href="#introduction">Introduction</a></h2><div id="rfc.section.1.p.1"><p>Specifying the syntax of new HTTP header (and trailer) fields is an onerous task; even with the guidance in Section 8.3.1 of <a href="#RFC7231"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content">[RFC7231]</cite></a>, there are many decisions – and pitfalls – for a prospective HTTP field author.</p></div><div id="rfc.section.1.p.2"><p>Once a field is defined, bespoke parsers and serializers often need to be written, because each field value has slightly different handling of what looks like common syntax.</p></div><div id="rfc.section.1.p.3"><p>This document introduces a set of common data structures for use in definitions of new HTTP field values to address these problems. In particular, it defines a generic, abstract model for them, along with a concrete serialization for expressing that model in HTTP <a href="#RFC7230"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing">[RFC7230]</cite></a> header and trailer fields.</p></div><div id="rfc.section.1.p.4"><p>A HTTP field that is defined as a “Structured Header” or “Structured Trailer” (if the field can be either, it is a “Structured Field”) uses the types defined in this specification to define its syntax and basic handling rules, thereby simplifying both its definition by specification writers and handling by implementations.</p></div><div id="rfc.section.1.p.5"><p>Additionally, future versions of HTTP can define alternative serializations of the abstract model of these structures, allowing fields that use that model to be transmitted more efficiently without being redefined.</p></div><div id="rfc.section.1.p.6"><p>Note that it is not a goal of this document to redefine the syntax of existing HTTP fields; the mechanisms described herein are only intended to be used with fields that explicitly opt into them.</p></div><div id="rfc.section.1.p.7"><p><a href="#specify" title="Defining New Structured Fields">Section 2</a> describes how to specify a Structured Field.</p></div><div id="rfc.section.1.p.8"><p><a href="#types" title="Structured Data Types">Section 3</a> defines a number of abstract data types that can be used in Structured Fields.</p></div><div id="rfc.section.1.p.9"><p>Those abstract types can be serialized into and parsed from HTTP field values using the algorithms described in <a href="#text" title="Working With Structured Fields in HTTP">Section 4</a>.</p></div><section id="strict"><h3 id="rfc.section.1.1"><a href="#rfc.section.1.1">1.1.</a> <a href="#strict">Intentionally Strict Processing</a></h3><div id="rfc.section.1.1.p.1"><p>This specification intentionally defines strict parsing and serialization behaviors using step-by-step algorithms; the only error handling defined is to fail the operation altogether.</p></div><div id="rfc.section.1.1.p.2"><p>It is designed to encourage faithful implementation and therefore good interoperability. Therefore, an implementation that tried to be helpful by being more tolerant of input would make interoperability worse, since that would create pressure on other implementations to implement similar (but likely subtly different) workarounds.</p></div><div id="rfc.section.1.1.p.3"><p>In other words, strict processing is an intentional feature of this specification; it allows non-conformant input to be discovered and corrected by the producer early, and avoids both interoperability and security issues that might otherwise result.</p></div><div id="rfc.section.1.1.p.4"><p>Note that as a result of this strictness, if a field is appended to by multiple parties (e.g., intermediaries, or different components in the sender), an error in one party’s value is likely to cause the entire field value to fail parsing.</p></div></section><section id="notational-conventions"><h3 id="rfc.section.1.2"><a href="#rfc.section.1.2">1.2.</a> <a href="#notational-conventions">Notational Conventions</a></h3><div id="rfc.section.1.2.p.1"><p>The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “NOT RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in BCP 14 <a href="#RFC2119"><cite title="Key words for use in RFCs to Indicate Requirement Levels">[RFC2119]</cite></a> <a href="#RFC8174"><cite title="Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words">[RFC8174]</cite></a> when, and only when, they appear in all capitals, as shown here.</p></div><div id="rfc.section.1.2.p.2"><p>This document uses algorithms to specify parsing and serialization behaviors, and the Augmented Backus-Naur Form (ABNF) notation of <a href="#RFC5234"><cite title="Augmented BNF for Syntax Specifications: ABNF">[RFC5234]</cite></a> to illustrate expected syntax in HTTP header fields. In doing so, it uses the VCHAR, SP, DIGIT, ALPHA and DQUOTE rules from <a href="#RFC5234"><cite title="Augmented BNF for Syntax Specifications: ABNF">[RFC5234]</cite></a>. It also includes the tchar and OWS rules from <a href="#RFC7230"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing">[RFC7230]</cite></a>.</p></div><div id="rfc.section.1.2.p.3"><p>When parsing from HTTP fields, implementations MUST have behavior that is indistinguishable from following the algorithms. If there is disagreement between the parsing algorithms and ABNF, the specified algorithms take precedence.</p></div><div id="rfc.section.1.2.p.4"><p>For serialization to HTTP fields, the ABNF illustrates their expected wire representations, and the algorithms define the recommended way to produce them. Implementations MAY vary from the specified behavior so long as the output is still correctly handled by the parsing algorithm.</p></div></section></section><section id="specify"><h2 id="rfc.section.2"><a href="#rfc.section.2">2.</a> <a href="#specify">Defining New Structured Fields</a></h2><div id="rfc.section.2.p.1" class="avoidbreakafter"><p>To specify a HTTP field as a Structured Field, its authors needs to:</p></div><div id="rfc.section.2.p.2"><ul><li>Normatively reference this specification. Recipients and generators of the field need to know that the requirements of this document are in effect.</li><li>Identify whether the field is a Structured Header (i.e., it can only be used in the header section - the common case), a Structured Trailer (only in the trailer section), or a Structured Field (both).</li><li>Specify the type of the field value; either List (<a href="#list" title="Lists">Section 3.1</a>), Dictionary (<a href="#dictionary" title="Dictionaries">Section 3.2</a>), or Item (<a href="#item" title="Items">Section 3.3</a>).</li><li>Define the semantics of the field value.</li><li>Specify any additional constraints upon the field value, as well as the consequences when those constraints are violated.</li></ul></div><div id="rfc.section.2.p.3"><p>Typically, this means that a field definition will specify the top-level type – List, Dictionary or Item – and then define its allowable types, and constraints upon them. For example, a header defined as a List might have all Integer members, or a mix of types; a header defined as an Item might allow only Strings, and additionally only strings beginning with the letter “Q”, or strings in lowercase. Likewise, Inner Lists (<a href="#inner-list" title="Inner Lists">Section 3.1.1</a>) are only valid when a field definition explicitly allows them.</p></div><div id="rfc.section.2.p.4"><p>When parsing fails, the entire field is ignored (see <a href="#text-parse" title="Parsing Structured Fields">Section 4.2</a>); in most situations, violating field-specific constraints should have the same effect. Thus, if a header is defined as an Item and required to be an Integer, but a String is received, the field will by default be ignored. If the field requires different error handling, this should be explicitly specified.</p></div><div id="rfc.section.2.p.5"><p>Both Items and Inner Lists allow parameters as an extensibility mechanism; this means that values can later be extended to accommodate more information, if need be. To preserve forward compatibility, field specifications are discouraged from defining the presence of an unrecognized Parameter as an error condition.</p></div><div id="rfc.section.2.p.6"><p>To further assure that this extensibility is available in the future, and to encourage consumers to use a complete parser implementation, a field definition can specify that “grease” Parameters be added by senders. A specification could stipulate that all Parameters that fit a defined pattern are reserved for this use and then encourage them to be sent on some portion of requests. This helps to discourage recipients from writing a parser that does not account for Parameters.</p></div><div id="rfc.section.2.p.7"><p>Specifications that use Dictionaries can also allow for forward compatibility by requiring that the presence of – as well as value and type associated with – unknown members be ignored. Later specifications can then add additional members, specifying constraints on them as appropriate.</p></div><div id="rfc.section.2.p.8"><p>An extension to a structured field can then require that an entire field value be ignored by a recipient that understands the extension if constraints on the value it defines are not met.</p></div><div id="rfc.section.2.p.9"><p>A field definition cannot relax the requirements of this specification because doing so would preclude handling by generic software; they can only add additional constraints (for example, on the numeric range of Integers and Decimals, the format of Strings and Tokens, the types allowed in a Dictionary’s values, or the number of Items in a List). Likewise, field definitions can only use this specification for the entire field value, not a portion thereof.</p></div><div id="rfc.section.2.p.10"><p>This specification defines minimums for the length or number of various structures supported by implementations. It does not specify maximum sizes in most cases, but authors should be aware that HTTP implementations do impose various limits on the size of individual fields, the total number of fields, and/or the size of the entire header or trailer section.</p></div><div id="rfc.section.2.p.11"><p>Specifications can refer to a field name as a “structured header name”, “structured trailer name” or “structured field name” as appropriate. Likewise, they can refer its field value as a “structured header value”, “structured trailer value” or “structured field value” as necessary. Field definitions are encouraged to use the ABNF rules beginning with “sf-“ defined in this specification; other rules in this specification are not intended for their use.</p></div><div id="rfc.section.2.p.12" class="avoidbreakafter"><p>For example, a fictitious Foo-Example header field might be specified as:</p></div><div id="rfc.figure.u.1"><div><pre class="text">
--8&lt;--
42. Foo-Example Header

The Foo-Example HTTP header field conveys information about how
much Foo the message has.

Foo-Example is a Item Structured Header [RFCxxxx]. Its value MUST be
an Integer (Section Y.Y of [RFCxxxx]). Its ABNF is:

  Foo-Example = sf-integer

Its value indicates the amount of Foo in the message, and MUST
be between 0 and 10, inclusive; other values MUST cause
the entire header field to be ignored.

The following parameters are defined:
* A Parameter whose name is "foourl", and whose value is a String
  (Section Y.Y of [RFCxxxx]), conveying the Foo URL
  for the message. See below for processing requirements.

"foourl" contains a URI-reference (Section 4.1 of [RFC3986]). If
its value is not a valid URI-reference, the entire header field
MUST be ignored. If its value is a relative reference (Section 4.2
of [RFC3986]), it MUST be resolved (Section 5 of [RFC3986]) before
being used.

For example:

  Foo-Example: 2; foourl="https://foo.example.com/"
--&gt;8--
</pre></div></div></section><section id="types"><h2 id="rfc.section.3"><a href="#rfc.section.3">3.</a> <a href="#types">Structured Data Types</a></h2><div id="rfc.section.3.p.1"><p>This section defines the abstract types for Structured Fields. The ABNF provided represents the on-wire format in HTTP field values.</p></div><div id="rfc.section.3.p.2" class="avoidbreakafter"><p>In summary:</p></div><div id="rfc.section.3.p.3"><ul><li>There are three top-level types that a HTTP field can be defined as: Lists, Dictionaries, and Items.</li><li>Lists and Dictionaries are containers; their members can be Items or Inner Lists (which are themselves arrays of Items).</li><li>Both Items and Inner Lists can be parameterized with key/value pairs.</li></ul></div><section id="list"><h3 id="rfc.section.3.1"><a href="#rfc.section.3.1">3.1.</a> <a href="#list">Lists</a></h3><div id="rfc.section.3.1.p.1"><p>Lists are arrays of zero or more members, each of which can be an Item (<a href="#item" title="Items">Section 3.3</a>) or an Inner List (<a href="#inner-list" title="Inner Lists">Section 3.1.1</a>), both of which can be Parameterized (<a href="#param" title="Parameters">Section 3.1.2</a>).</p></div><div id="rfc.section.3.1.p.2" class="avoidbreakafter"><p>The ABNF for Lists in HTTP fields is:</p></div><div id="rfc.figure.u.2"><div><pre class="inline">
sf-list       = list-member *( OWS "," OWS list-member )
list-member   = sf-item / inner-list
</pre></div></div><div id="rfc.section.3.1.p.3" class="avoidbreakafter"><p>Each member is separated by a comma and optional whitespace. For example, a field whose value is defined as a List of Strings could look like:</p></div><div id="rfc.figure.u.3"><div><pre class="text">
Example-StrList: "foo", "bar", "It was the best of times."
</pre></div></div><div id="rfc.section.3.1.p.4"><p>An empty List is denoted by not serializing the field at all. This implies that fields defined as Lists have a default empty value.</p></div><div id="rfc.section.3.1.p.5" class="avoidbreakafter"><p>Note that Lists can have their members split across multiple lines inside a header or trailer section, as per Section 3.2.2 of <a href="#RFC7230"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing">[RFC7230]</cite></a>; for example, the following are equivalent:</p></div><div id="rfc.figure.u.4"><div><pre class="text">
Example-Hdr: foo, bar
</pre></div></div><div id="rfc.section.3.1.p.6"><p>and</p></div><div id="rfc.figure.u.5"><div><pre class="text">
Example-Hdr: foo
Example-Hdr: bar
</pre></div></div><div id="rfc.section.3.1.p.7"><p>However, individual members of a List cannot be safely split between across lines; see <a href="#text-parse" title="Parsing Structured Fields">Section 4.2</a> for details.</p></div><div id="rfc.section.3.1.p.8"><p>Parsers MUST support Lists containing at least 1024 members. Field specifications can constrain the types and cardinality of individual List values as they require.</p></div><section id="inner-list"><h4 id="rfc.section.3.1.1"><a href="#rfc.section.3.1.1">3.1.1.</a> <a href="#inner-list">Inner Lists</a></h4><div id="rfc.section.3.1.1.p.1"><p>An Inner List is an array of zero or more Items (<a href="#item" title="Items">Section 3.3</a>). Both the individual Items and the Inner List itself can be Parameterized (<a href="#param" title="Parameters">Section 3.1.2</a>).</p></div><div id="rfc.section.3.1.1.p.2" class="avoidbreakafter"><p>The ABNF for Inner Lists is:</p></div><div id="rfc.figure.u.6"><div><pre class="inline">
inner-list    = "(" *SP [ sf-item *( 1*SP sf-item ) *SP ] ")"
                parameters
</pre></div></div><div id="rfc.section.3.1.1.p.3" class="avoidbreakafter"><p>Inner Lists are denoted by surrounding parenthesis, and have their values delimited by one or more spaces. A field whose value is defined as a List of Inner Lists of Strings could look like:</p></div><div id="rfc.figure.u.7"><div><pre class="text">
Example-StrListList: ("foo" "bar"), ("baz"), ("bat" "one"), ()
</pre></div></div><div id="rfc.section.3.1.1.p.4"><p>Note that the last member in this example is an empty Inner List.</p></div><div id="rfc.section.3.1.1.p.5" class="avoidbreakafter"><p>A header field whose value is defined as a List of Inner Lists with Parameters at both levels could look like:</p></div><div id="rfc.figure.u.8"><div><pre class="text">
Example-ListListParam: ("foo"; a=1;b=2);lvl=5, ("bar" "baz");lvl=1
</pre></div></div><div id="rfc.section.3.1.1.p.6"><p>Parsers MUST support Inner Lists containing at least 256 members. Field specifications can constrain the types and cardinality of individual Inner List members as they require.</p></div></section><section id="param"><h4 id="rfc.section.3.1.2"><a href="#rfc.section.3.1.2">3.1.2.</a> <a href="#param">Parameters</a></h4><div id="rfc.section.3.1.2.p.1"><p>Parameters are an ordered map of key-value pairs that are associated with an Item (<a href="#item" title="Items">Section 3.3</a>) or Inner List (<a href="#inner-list" title="Inner Lists">Section 3.1.1</a>). The keys are unique within the scope the Parameters they occur within, and the values are bare items (i.e., they themselves cannot be parameterized; see <a href="#item" title="Items">Section 3.3</a>).</p></div><div id="rfc.section.3.1.2.p.2" class="avoidbreakafter"><p>The ABNF for Parameters is:</p></div><div id="rfc.figure.u.9"><div><pre class="inline">
parameters    = *( ";" *SP parameter )
parameter     = param-name [ "=" param-value ]
param-name    = key
key           = ( lcalpha / "*" )
                *( lcalpha / DIGIT / "_" / "-" / "." / "*" )
lcalpha       = %x61-7A ; a-z
param-value   = bare-item
</pre></div></div><div id="rfc.section.3.1.2.p.3" class="avoidbreakafter"><p>Note that Parameters are ordered as serialized, and Parameter keys cannot contain uppercase letters. A parameter is separated from its Item or Inner List and other parameters by a semicolon. For example:</p></div><div id="rfc.figure.u.10"><div><pre class="text">
Example-ParamList: abc;a=1;b=2; cde_456, (ghi;jk=4 l);q="9";r=w
</pre></div></div><div id="rfc.section.3.1.2.p.4" class="avoidbreakafter"><p>Parameters whose value is Boolean (see <a href="#boolean" title="Booleans">Section 3.3.6</a>) true MUST omit that value when serialized. For example, the “a” parameter here is true, while the “b” parameter is false:</p></div><div id="rfc.figure.u.11"><div><pre class="text">
Example-Int: 1; a; b=?0
</pre></div></div><div id="rfc.section.3.1.2.p.5"><p>Note that this requirement is only on serialization; parsers are still required to correctly handle the true value when it appears in a parameter.</p></div><div id="rfc.section.3.1.2.p.6"><p>Parsers MUST support at least 256 parameters on an Item or Inner List, and support parameter keys with at least 64 characters. Field specifications can constrain the order of individual Parameters, as well as their values’ types as required.</p></div></section></section><section id="dictionary"><h3 id="rfc.section.3.2"><a href="#rfc.section.3.2">3.2.</a> <a href="#dictionary">Dictionaries</a></h3><div id="rfc.section.3.2.p.1"><p>Dictionaries are ordered maps of name-value pairs, where the names are short textual strings and the values are Items (<a href="#item" title="Items">Section 3.3</a>) or arrays of Items, both of which can be Parameterized (<a href="#param" title="Parameters">Section 3.1.2</a>). There can be zero or more members, and their names are unique in the scope of the Dictionary they occur within.</p></div><div id="rfc.section.3.2.p.2"><p>Implementations MUST provide access to Dictionaries both by index and by name. Specifications MAY use either means of accessing the members.</p></div><div id="rfc.section.3.2.p.3" class="avoidbreakafter"><p>The ABNF for Dictionaries is:</p></div><div id="rfc.figure.u.12"><div><pre class="inline">
sf-dictionary  = dict-member *( OWS "," OWS dict-member )
dict-member    = member-name [ "=" member-value ]
member-name    = key
member-value   = sf-item / inner-list
</pre></div></div><div id="rfc.section.3.2.p.4" class="avoidbreakafter"><p>Members are ordered as serialized, and separated by a comma with optional whitespace. Member names cannot contain uppercase characters. Names and values are separated by “=” (without whitespace). For example:</p></div><div id="rfc.figure.u.13"><div><pre class="text">
Example-Dict: en="Applepie", da=:w4ZibGV0w6ZydGU=:
</pre></div></div><div id="rfc.section.3.2.p.5"><p>Note that in this example, the final “=” is due to the inclusion of a Byte Sequence; see <a href="#binary" title="Byte Sequences">Section 3.3.5</a>.</p></div><div id="rfc.section.3.2.p.6" class="avoidbreakafter"><p>Members whose value is Boolean (see <a href="#boolean" title="Booleans">Section 3.3.6</a>) true MUST omit that value when serialized. For example, here both “b” and “c” are true:</p></div><div id="rfc.figure.u.14"><div><pre class="text">
Example-Dict: a=?0, b, c; foo=bar
</pre></div></div><div id="rfc.section.3.2.p.7"><p>Note that this requirement is only on serialization; parsers are still required to correctly handle the true Boolean value when it appears in Dictionary values.</p></div><div id="rfc.section.3.2.p.8" class="avoidbreakafter"><p>A Dictionary with a member whose value is an Inner List of Tokens:</p></div><div id="rfc.figure.u.15"><div><pre class="text">
Example-DictList: rating=1.5, feelings=(joy sadness)
</pre></div></div><div id="rfc.section.3.2.p.9" class="avoidbreakafter"><p>A Dictionary with a mix of Items and Inner Lists, some with Parameters:</p></div><div id="rfc.figure.u.16"><div><pre class="text">
Example-MixDict: a=(1 2), b=3, c=4;aa=bb, d=(5 6);valid
</pre></div></div><div id="rfc.section.3.2.p.10"><p>As with lists, an empty Dictionary is represented by omitting the entire field. This implies that fields defined as Dictionaries have a default empty value.</p></div><div id="rfc.section.3.2.p.11"><p>Typically, a field specification will define the semantics of Dictionaries by specifying the allowed type(s) for individual members by their names, as well as whether their presence is required or optional. Recipients MUST ignore names that are undefined or unknown, unless the field’s specification specifically disallows them.</p></div><div id="rfc.section.3.2.p.12" class="avoidbreakafter"><p>Note that Dictionaries can have their members split across multiple lines inside a header or trailer section; for example, the following are equivalent:</p></div><div id="rfc.figure.u.17"><div><pre class="text">
Example-Hdr: foo=1, bar=2
</pre></div></div><div id="rfc.section.3.2.p.13"><p>and</p></div><div id="rfc.figure.u.18"><div><pre class="text">
Example-Hdr: foo=1
Example-Hdr: bar=2
</pre></div></div><div id="rfc.section.3.2.p.14"><p>However, individual members of a Dictionary cannot be safely split between lines; see <a href="#text-parse" title="Parsing Structured Fields">Section 4.2</a> for details.</p></div><div id="rfc.section.3.2.p.15"><p>Parsers MUST support Dictionaries containing at least 1024 name/value pairs, and names with at least 64 characters. Field specifications can constrain the order of individual Dictionary members, as well as their values’ types as required.</p></div></section><section id="item"><h3 id="rfc.section.3.3"><a href="#rfc.section.3.3">3.3.</a> <a href="#item">Items</a></h3><div id="rfc.section.3.3.p.1"><p>An Item can be a Integer (<a href="#integer" title="Integers">Section 3.3.1</a>), Decimal (<a href="#decimal" title="Decimals">Section 3.3.2</a>), String (<a href="#string" title="Strings">Section 3.3.3</a>), Token (<a href="#token" title="Tokens">Section 3.3.4</a>), Byte Sequence (<a href="#binary" title="Byte Sequences">Section 3.3.5</a>), or Boolean (<a href="#boolean" title="Booleans">Section 3.3.6</a>). It can have associated Parameters (<a href="#param" title="Parameters">Section 3.1.2</a>).</p></div><div id="rfc.section.3.3.p.2" class="avoidbreakafter"><p>The ABNF for Items is:</p></div><div id="rfc.figure.u.19"><div><pre class="inline">
sf-item   = bare-item parameters
bare-item = sf-integer / sf-decimal / sf-string / sf-token
            / sf-binary / sf-boolean
</pre></div></div><div id="rfc.section.3.3.p.3" class="avoidbreakafter"><p>For example, a header field that is defined to be an Item that is an Integer might look like:</p></div><div id="rfc.figure.u.20"><div><pre class="text">
Example-IntItemHeader: 5
</pre></div></div><div id="rfc.section.3.3.p.4" class="avoidbreakafter"><p>or with Parameters:</p></div><div id="rfc.figure.u.21"><div><pre class="text">
Example-IntItem: 5; foo=bar
</pre></div></div><section id="integer"><h4 id="rfc.section.3.3.1"><a href="#rfc.section.3.3.1">3.3.1.</a> <a href="#integer">Integers</a></h4><div id="rfc.section.3.3.1.p.1"><p>Integers have a range of -999,999,999,999,999 to 999,999,999,999,999 inclusive (i.e., up to fifteen digits, signed), for IEEE 754 compatibility (<a href="#IEEE754"><cite title="IEEE Standard for Floating-Point Arithmetic">[IEEE754]</cite></a>).</p></div><div id="rfc.section.3.3.1.p.2" class="avoidbreakafter"><p>The ABNF for Integers is:</p></div><div id="rfc.figure.u.22"><div><pre class="inline">
sf-integer = ["-"] 1*15DIGIT
</pre></div></div><div id="rfc.section.3.3.1.p.3" class="avoidbreakafter"><p>For example:</p></div><div id="rfc.figure.u.23"><div><pre class="text">
Example-Integer: 42
</pre></div></div><div id="rfc.section.3.3.1.p.4"><p>Integers larger than 15 digits can be supported in a variety of ways; for example, by using a String (<a href="#string" title="Strings">Section 3.3.3</a>), Byte Sequence (<a href="#binary" title="Byte Sequences">Section 3.3.5</a>), or a parameter on an Integer that acts as a scaling factor.</p></div><div id="rfc.section.3.3.1.p.5"><p>While it is possible to serialise Integers with leading zeros (e.g., “0002”, “-01”) and signed zero (“-0”), these distinctions may not be preserved by implementations.</p></div><div id="rfc.section.3.3.1.p.6"><p>Note that commas in Integers are used in this section’s prose only for readability; they are not valid in the wire format.</p></div></section><section id="decimal"><h4 id="rfc.section.3.3.2"><a href="#rfc.section.3.3.2">3.3.2.</a> <a href="#decimal">Decimals</a></h4><div id="rfc.section.3.3.2.p.1"><p>Decimals are numbers with an integer and a fractional component. The integer component has at most 12 digits; the fractional component has at most three digits.</p></div><div id="rfc.section.3.3.2.p.2" class="avoidbreakafter"><p>The ABNF for decimals is:</p></div><div id="rfc.figure.u.24"><div><pre class="inline">
sf-decimal  = ["-"] 1*12DIGIT "." 1*3DIGIT
</pre></div></div><div id="rfc.section.3.3.2.p.3" class="avoidbreakafter"><p>For example, a header whose value is defined as a Decimal could look like:</p></div><div id="rfc.figure.u.25"><div><pre class="text">
Example-Decimal: 4.5
</pre></div></div><div id="rfc.section.3.3.2.p.4"><p>While it is possible to serialise Decimals with leading zeros (e.g., “0002.5”, “-01.334”), trailing zeros (e.g., “5.230”, “-0.40”), and signed zero (e.g., “-0.0”), these distinctions may not be preserved by implementations.</p></div><div id="rfc.section.3.3.2.p.5"><p>Note that the serialisation algorithm (<a href="#ser-decimal" title="Serializing a Decimal">Section 4.1.5</a>) rounds input with more than three digits of precision in the fractional component. If an alternative rounding strategy is desired, this should be specified by the header definition to occur before serialisation.</p></div></section><section id="string"><h4 id="rfc.section.3.3.3"><a href="#rfc.section.3.3.3">3.3.3.</a> <a href="#string">Strings</a></h4><div id="rfc.section.3.3.3.p.1"><p>Strings are zero or more printable ASCII <a href="#RFC0020"><cite title="ASCII format for network interchange">[RFC0020]</cite></a> characters (i.e., the range %x20 to %x7E). Note that this excludes tabs, newlines, carriage returns, etc.</p></div><div id="rfc.section.3.3.3.p.2" class="avoidbreakafter"><p>The ABNF for Strings is:</p></div><div id="rfc.figure.u.26"><div><pre class="inline">
sf-string = DQUOTE *chr DQUOTE
chr       = unescaped / escaped
unescaped = %x20-21 / %x23-5B / %x5D-7E
escaped   = "\" ( DQUOTE / "\" )
</pre></div></div><div id="rfc.section.3.3.3.p.3" class="avoidbreakafter"><p>Strings are delimited with double quotes, using a backslash (“\”) to escape double quotes and backslashes. For example:</p></div><div id="rfc.figure.u.27"><div><pre class="text">
Example-String: "hello world"
</pre></div></div><div id="rfc.section.3.3.3.p.4"><p>Note that Strings only use DQUOTE as a delimiter; single quotes do not delimit Strings. Furthermore, only DQUOTE and “\” can be escaped; other characters after “\” MUST cause parsing to fail.</p></div><div id="rfc.section.3.3.3.p.5"><p>Unicode is not directly supported in Strings, because it causes a number of interoperability issues, and – with few exceptions – field values do not require it.</p></div><div id="rfc.section.3.3.3.p.6"><p>When it is necessary for a field value to convey non-ASCII content, a Byte Sequence (<a href="#binary" title="Byte Sequences">Section 3.3.5</a>) can be specified, along with a character encoding (preferably <a href="#UTF-8"><cite title="UTF-8, a transformation format of ISO 10646">[UTF-8]</cite></a>).</p></div><div id="rfc.section.3.3.3.p.7"><p>Parsers MUST support Strings (after any decoding) with at least 1024 characters.</p></div></section><section id="token"><h4 id="rfc.section.3.3.4"><a href="#rfc.section.3.3.4">3.3.4.</a> <a href="#token">Tokens</a></h4><div id="rfc.section.3.3.4.p.1"><p>Tokens are short textual words; their abstract model is identical to their expression in the HTTP field value serialization.</p></div><div id="rfc.section.3.3.4.p.2" class="avoidbreakafter"><p>The ABNF for Tokens is:</p></div><div id="rfc.figure.u.28"><div><pre class="inline">
sf-token = ( ALPHA / "*" ) *( tchar / ":" / "/" )
</pre></div></div><div id="rfc.section.3.3.4.p.3" class="avoidbreakafter"><p>For example:</p></div><div id="rfc.figure.u.29"><div><pre class="text">
Example-Token: foo123/456
</pre></div></div><div id="rfc.section.3.3.4.p.4"><p>Parsers MUST support Tokens with at least 512 characters.</p></div><div id="rfc.section.3.3.4.p.5"><p>Note that Token allows the same characters as the “token” ABNF rule defined in <a href="#RFC7230"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing">[RFC7230]</cite></a>, with the exceptions that the first character is required to be either ALPHA or “*”, and “:” and “/” are also allowed in subsequent characters.</p></div></section><section id="binary"><h4 id="rfc.section.3.3.5"><a href="#rfc.section.3.3.5">3.3.5.</a> <a href="#binary">Byte Sequences</a></h4><div id="rfc.section.3.3.5.p.1"><p>Byte Sequences can be conveyed in Structured Fields.</p></div><div id="rfc.section.3.3.5.p.2" class="avoidbreakafter"><p>The ABNF for a Byte Sequence is:</p></div><div id="rfc.figure.u.30"><div><pre class="inline">
sf-binary = ":" *(base64) ":"
base64    = ALPHA / DIGIT / "+" / "/" / "="
</pre></div></div><div id="rfc.section.3.3.5.p.3" class="avoidbreakafter"><p>A Byte Sequence is delimited with colons and encoded using base64 (<a href="#RFC4648"><cite title="The Base16, Base32, and Base64 Data Encodings">[RFC4648]</cite></a>, Section 4). For example:</p></div><div id="rfc.figure.u.31"><div><pre class="text">
Example-Binary: :cHJldGVuZCB0aGlzIGlzIGJpbmFyeSBjb250ZW50Lg==:
</pre></div></div><div id="rfc.section.3.3.5.p.4"><p>Parsers MUST support Byte Sequences with at least 16384 octets after decoding.</p></div></section><section id="boolean"><h4 id="rfc.section.3.3.6"><a href="#rfc.section.3.3.6">3.3.6.</a> <a href="#boolean">Booleans</a></h4><div id="rfc.section.3.3.6.p.1"><p>Boolean values can be conveyed in Structured Fields.</p></div><div id="rfc.section.3.3.6.p.2" class="avoidbreakafter"><p>The ABNF for a Boolean is:</p></div><div id="rfc.figure.u.32"><div><pre class="inline">
sf-boolean = "?" boolean
boolean    = "0" / "1"
</pre></div></div><div id="rfc.section.3.3.6.p.3" class="avoidbreakafter"><p>A Boolean is indicated with a leading “?” character followed by a “1” for a true value or “0” for false. For example:</p></div><div id="rfc.figure.u.33"><div><pre class="text">
Example-Bool: ?1
</pre></div></div><div id="rfc.section.3.3.6.p.4"><p>Note that in Dictionary (<a href="#dictionary" title="Dictionaries">Section 3.2</a>) and Parameter (<a href="#param" title="Parameters">Section 3.1.2</a>) values, Boolean true is indicated by omitting the value.</p></div></section></section></section><section id="text"><h2 id="rfc.section.4"><a href="#rfc.section.4">4.</a> <a href="#text">Working With Structured Fields in HTTP</a></h2><div id="rfc.section.4.p.1"><p>This section defines how to serialize and parse Structured Fields in textual HTTP field values and other encodings compatible with them (e.g., in HTTP/2 <a href="#RFC7540"><cite title="Hypertext Transfer Protocol Version 2 (HTTP/2)">[RFC7540]</cite></a> before compression with HPACK <a href="#RFC7541"><cite title="HPACK: Header Compression for HTTP/2">[RFC7541]</cite></a>).</p></div><section id="text-serialize"><h3 id="rfc.section.4.1"><a href="#rfc.section.4.1">4.1.</a> <a href="#text-serialize">Serializing Structured Fields</a></h3><div id="rfc.section.4.1.p.1"><p>Given a structure defined in this specification, return an ASCII string suitable for use in a HTTP field value.</p></div><div id="rfc.section.4.1.p.2"><ol><li>If the structure is a Dictionary or List and its value is empty (i.e., it has no members), do not serialize the field at all (i.e., omit both the field-name and field-value).</li><li>If the structure is a List, let output_string be the result of running Serializing a List (<a href="#ser-list" title="Serializing a List">Section 4.1.1</a>) with the structure.</li><li>Else if the structure is a Dictionary, let output_string be the result of running Serializing a Dictionary (<a href="#ser-dictionary" title="Serializing a Dictionary">Section 4.1.2</a>) with the structure.</li><li>Else if the structure is an Item, let output_string be the result of running Serializing an Item (<a href="#ser-item" title="Serializing an Item">Section 4.1.3</a>) with the structure.</li><li>Else, fail serialization.</li><li>Return output_string converted into an array of bytes, using ASCII encoding <a href="#RFC0020"><cite title="ASCII format for network interchange">[RFC0020]</cite></a>.</li></ol></div><section id="ser-list"><h4 id="rfc.section.4.1.1"><a href="#rfc.section.4.1.1">4.1.1.</a> <a href="#ser-list">Serializing a List</a></h4><div id="rfc.section.4.1.1.p.1"><p>Given an array of (member_value, parameters) tuples as input_list, return an ASCII string suitable for use in a HTTP field value.</p></div><div id="rfc.section.4.1.1.p.2"><ol><li>Let output be an empty string.</li><li>For each (member_value, parameters) of input_list: <ol><li>If member_value is an array, append the result of running Serializing an Inner List (<a href="#ser-innerlist" title="Serializing an Inner List">Section 4.1.1.1</a>) with (member_value, parameters) to output.</li><li>Otherwise, append the result of running Serializing an Item (<a href="#ser-item" title="Serializing an Item">Section 4.1.3</a>) with (member_value, parameters) to output.</li><li>If more member_values remain in input_list: <ol><li>Append “,” to output.</li><li>Append a single SP to output.</li></ol></li></ol></li><li>Return output.</li></ol></div><section id="ser-innerlist"><h5 id="rfc.section.4.1.1.1"><a href="#rfc.section.4.1.1.1">4.1.1.1.</a> <a href="#ser-innerlist">Serializing an Inner List</a></h5><div id="rfc.section.4.1.1.1.p.1"><p>Given an array of (member_value, parameters) tuples as inner_list, and parameters as list_parameters, return an ASCII string suitable for use in a HTTP field value.</p></div><div id="rfc.section.4.1.1.1.p.2"><ol><li>Let output be the string “(“.</li><li>For each (member_value, parameters) of inner_list: <ol><li>Append the result of running Serializing an Item (<a href="#ser-item" title="Serializing an Item">Section 4.1.3</a>) with (member_value, parameters) to output.</li><li>If more values remain in inner_list, append a single SP to output.</li></ol></li><li>Append “)” to output.</li><li>Append the result of running Serializing Parameters (<a href="#ser-params" title="Serializing Parameters">Section 4.1.1.2</a>) with list_parameters to output.</li><li>Return output.</li></ol></div></section><section id="ser-params"><h5 id="rfc.section.4.1.1.2"><a href="#rfc.section.4.1.1.2">4.1.1.2.</a> <a href="#ser-params">Serializing Parameters</a></h5><div id="rfc.section.4.1.1.2.p.1"><p>Given an ordered Dictionary as input_parameters (each member having a param_name and a param_value), return an ASCII string suitable for use in a HTTP field value.</p></div><div id="rfc.section.4.1.1.2.p.2"><ol><li>Let output be an empty string.</li><li>For each param_name with a value of param_value in input_parameters: <ol><li>Append “;” to output.</li><li>Append the result of running Serializing a Key (<a href="#ser-key" title="Serializing a Key">Section 4.1.1.3</a>) with param_name to output.</li><li>If param_value is not Boolean true: <ol><li>Append “=” to output.</li><li>Append the result of running Serializing a bare Item (<a href="#ser-bare-item" title="Serializing a Bare Item">Section 4.1.3.1</a>) with param_value to output.</li></ol></li></ol></li><li>Return output.</li></ol></div></section><section id="ser-key"><h5 id="rfc.section.4.1.1.3"><a href="#rfc.section.4.1.1.3">4.1.1.3.</a> <a href="#ser-key">Serializing a Key</a></h5><div id="rfc.section.4.1.1.3.p.1"><p>Given a key as input_key, return an ASCII string suitable for use in a HTTP field value.</p></div><div id="rfc.section.4.1.1.3.p.2"><ol><li>Convert input_key into a sequence of ASCII characters; if conversion fails, fail serialization.</li><li>If input_key contains characters not in lcalpha, DIGIT, “_”, “-“, “.”, or “*” fail serialization.</li><li>If the first character of input_key is not lcalpha or “*”, fail serialization.</li><li>Let output be an empty string.</li><li>Append input_key to output.</li><li>Return output.</li></ol></div></section></section><section id="ser-dictionary"><h4 id="rfc.section.4.1.2"><a href="#rfc.section.4.1.2">4.1.2.</a> <a href="#ser-dictionary">Serializing a Dictionary</a></h4><div id="rfc.section.4.1.2.p.1"><p>Given an ordered Dictionary as input_dictionary (each member having a member_name and a tuple value of (member_value, parameters)), return an ASCII string suitable for use in a HTTP field value.</p></div><div id="rfc.section.4.1.2.p.2"><ol><li>Let output be an empty string.</li><li>For each member_name with a value of (member_value, parameters) in input_dictionary: <ol><li>Append the result of running Serializing a Key (<a href="#ser-key" title="Serializing a Key">Section 4.1.1.3</a>) with member’s member_name to output.</li><li>If member_value is Boolean true: <ol><li>Append the result of running Serializing Parameters (<a href="#ser-params" title="Serializing Parameters">Section 4.1.1.2</a>) with parameters to output.</li></ol></li><li>Otherwise: <ol><li>Append “=” to output.</li><li>If member_value is an array, append the result of running Serializing an Inner List (<a href="#ser-innerlist" title="Serializing an Inner List">Section 4.1.1.1</a>) with (member_value, parameters) to output.</li><li>Otherwise, append the result of running Serializing an Item (<a href="#ser-item" title="Serializing an Item">Section 4.1.3</a>) with (member_value, parameters) to output.</li></ol></li><li>If more members remain in input_dictionary: <ol><li>Append “,” to output.</li><li>Append a single SP to output.</li></ol></li></ol></li><li>Return output.</li></ol></div></section><section id="ser-item"><h4 id="rfc.section.4.1.3"><a href="#rfc.section.4.1.3">4.1.3.</a> <a href="#ser-item">Serializing an Item</a></h4><div id="rfc.section.4.1.3.p.1"><p>Given an Item as bare_item and Parameters as item_parameters, return an ASCII string suitable for use in a HTTP field value.</p></div><div id="rfc.section.4.1.3.p.2"><ol><li>Let output be an empty string.</li><li>Append the result of running Serializing a Bare Item <a href="#ser-bare-item" title="Serializing a Bare Item">Section 4.1.3.1</a> with bare_item to output.</li><li>Append the result of running Serializing Parameters <a href="#ser-params" title="Serializing Parameters">Section 4.1.1.2</a> with item_parameters to output.</li><li>Return output.</li></ol></div><section id="ser-bare-item"><h5 id="rfc.section.4.1.3.1"><a href="#rfc.section.4.1.3.1">4.1.3.1.</a> <a href="#ser-bare-item">Serializing a Bare Item</a></h5><div id="rfc.section.4.1.3.1.p.1"><p>Given an Item as input_item, return an ASCII string suitable for use in a HTTP field value.</p></div><div id="rfc.section.4.1.3.1.p.2"><ol><li>If input_item is an Integer, return the result of running Serializing an Integer (<a href="#ser-integer" title="Serializing an Integer">Section 4.1.4</a>) with input_item.</li><li>If input_item is a Decimal, return the result of running Serializing a Decimal (<a href="#ser-decimal" title="Serializing a Decimal">Section 4.1.5</a>) with input_item.</li><li>If input_item is a String, return the result of running Serializing a String (<a href="#ser-string" title="Serializing a String">Section 4.1.6</a>) with input_item.</li><li>If input_item is a Token, return the result of running Serializing a Token (<a href="#ser-token" title="Serializing a Token">Section 4.1.7</a>) with input_item.</li><li>If input_item is a Boolean, return the result of running Serializing a Boolean (<a href="#ser-boolean" title="Serializing a Boolean">Section 4.1.9</a>) with input_item.</li><li>If input_item is a Byte Sequence, return the result of running Serializing a Byte Sequence (<a href="#ser-binary" title="Serializing a Byte Sequence">Section 4.1.8</a>) with input_item.</li><li>Otherwise, fail serialization.</li></ol></div></section></section><section id="ser-integer"><h4 id="rfc.section.4.1.4"><a href="#rfc.section.4.1.4">4.1.4.</a> <a href="#ser-integer">Serializing an Integer</a></h4><div id="rfc.section.4.1.4.p.1"><p>Given an Integer as input_integer, return an ASCII string suitable for use in a HTTP field value.</p></div><div id="rfc.section.4.1.4.p.2"><ol><li>If input_integer is not an integer in the range of -999,999,999,999,999 to 999,999,999,999,999 inclusive, fail serialization.</li><li>Let output be an empty string.</li><li>If input_integer is less than (but not equal to) 0, append “-“ to output.</li><li>Append input_integer’s numeric value represented in base 10 using only decimal digits to output.</li><li>Return output.</li></ol></div></section><section id="ser-decimal"><h4 id="rfc.section.4.1.5"><a href="#rfc.section.4.1.5">4.1.5.</a> <a href="#ser-decimal">Serializing a Decimal</a></h4><div id="rfc.section.4.1.5.p.1"><p>Given a decimal number as input_decimal, return an ASCII string suitable for use in a HTTP field value.</p></div><div id="rfc.section.4.1.5.p.2"><ol><li>If input_decimal is not a decimal number, fail serialization.</li><li>If input_decimal has more than three significant digits to the right of the decimal point, round it to three decimal places, rounding the final digit to the nearest value, or to the even value if it is equidistant.</li><li>If input_decimal has more than 12 significant digits to the left of the decimal point after rounding, fail serialization.</li><li>Let output be an empty string.</li><li>If input_decimal is less than (but not equal to) 0, append “-“ to output.</li><li>Append input_decimal’s integer component represented in base 10 (using only decimal digits) to output; if it is zero, append “0”.</li><li>Append “.” to output.</li><li>If input_decimal’s fractional component is zero, append “0” to output.</li><li>Otherwise, append the significant digits of input_decimal’s fractional component represented in base 10 (using only decimal digits) to output.</li><li>Return output.</li></ol></div></section><section id="ser-string"><h4 id="rfc.section.4.1.6"><a href="#rfc.section.4.1.6">4.1.6.</a> <a href="#ser-string">Serializing a String</a></h4><div id="rfc.section.4.1.6.p.1"><p>Given a String as input_string, return an ASCII string suitable for use in a HTTP field value.</p></div><div id="rfc.section.4.1.6.p.2"><ol><li>Convert input_string into a sequence of ASCII characters; if conversion fails, fail serialization.</li><li>If input_string contains characters in the range %x00-1f or %x7f (i.e., not in VCHAR or SP), fail serialization.</li><li>Let output be the string DQUOTE.</li><li>For each character char in input_string: <ol><li>If char is “\” or DQUOTE: <ol><li>Append “\” to output.</li></ol></li><li>Append char to output.</li></ol></li><li>Append DQUOTE to output.</li><li>Return output.</li></ol></div></section><section id="ser-token"><h4 id="rfc.section.4.1.7"><a href="#rfc.section.4.1.7">4.1.7.</a> <a href="#ser-token">Serializing a Token</a></h4><div id="rfc.section.4.1.7.p.1"><p>Given a Token as input_token, return an ASCII string suitable for use in a HTTP field value.</p></div><div id="rfc.section.4.1.7.p.2"><ol><li>Convert input_token into a sequence of ASCII characters; if conversion fails, fail serialization.</li><li>If the first character of input_token is not ALPHA or “*”, or the remaining portion contains a character not in tchar, “:” or “/”, fail serialization.</li><li>Let output be an empty string.</li><li>Append input_token to output.</li><li>Return output.</li></ol></div></section><section id="ser-binary"><h4 id="rfc.section.4.1.8"><a href="#rfc.section.4.1.8">4.1.8.</a> <a href="#ser-binary">Serializing a Byte Sequence</a></h4><div id="rfc.section.4.1.8.p.1"><p>Given a Byte Sequence as input_bytes, return an ASCII string suitable for use in a HTTP field value.</p></div><div id="rfc.section.4.1.8.p.2"><ol><li>If input_bytes is not a sequence of bytes, fail serialization.</li><li>Let output be an empty string.</li><li>Append “:” to output.</li><li>Append the result of base64-encoding input_bytes as per <a href="#RFC4648"><cite title="The Base16, Base32, and Base64 Data Encodings">[RFC4648]</cite></a>, Section 4, taking account of the requirements below.</li><li>Append “:” to output.</li><li>Return output.</li></ol></div><div id="rfc.section.4.1.8.p.3"><p>The encoded data is required to be padded with “=”, as per <a href="#RFC4648"><cite title="The Base16, Base32, and Base64 Data Encodings">[RFC4648]</cite></a>, Section 3.2.</p></div><div id="rfc.section.4.1.8.p.4"><p>Likewise, encoded data SHOULD have pad bits set to zero, as per <a href="#RFC4648"><cite title="The Base16, Base32, and Base64 Data Encodings">[RFC4648]</cite></a>, Section 3.5, unless it is not possible to do so due to implementation constraints.</p></div></section><section id="ser-boolean"><h4 id="rfc.section.4.1.9"><a href="#rfc.section.4.1.9">4.1.9.</a> <a href="#ser-boolean">Serializing a Boolean</a></h4><div id="rfc.section.4.1.9.p.1"><p>Given a Boolean as input_boolean, return an ASCII string suitable for use in a HTTP field value.</p></div><div id="rfc.section.4.1.9.p.2"><ol><li>If input_boolean is not a boolean, fail serialization.</li><li>Let output be an empty string.</li><li>Append “?” to output.</li><li>If input_boolean is true, append “1” to output.</li><li>If input_boolean is false, append “0” to output.</li><li>Return output.</li></ol></div></section></section><section id="text-parse"><h3 id="rfc.section.4.2"><a href="#rfc.section.4.2">4.2.</a> <a href="#text-parse">Parsing Structured Fields</a></h3><div id="rfc.section.4.2.p.1"><p>When a receiving implementation parses HTTP fields that are known to be Structured Fields, it is important that care be taken, as there are a number of edge cases that can cause interoperability or even security problems. This section specifies the algorithm for doing so.</p></div><div id="rfc.section.4.2.p.2"><p>Given an array of bytes input_bytes that represents the chosen field’s field-value (which is empty if that field is not present), and field_type (one of “dictionary”, “list”, or “item”), return the parsed header value.</p></div><div id="rfc.section.4.2.p.3"><ol><li>Convert input_bytes into an ASCII string input_string; if conversion fails, fail parsing.</li><li>Discard any leading SP characters from input_string.</li><li>If field_type is “list”, let output be the result of running Parsing a List (<a href="#parse-list" title="Parsing a List">Section 4.2.1</a>) with input_string.</li><li>If field_type is “dictionary”, let output be the result of running Parsing a Dictionary (<a href="#parse-dictionary" title="Parsing a Dictionary">Section 4.2.2</a>) with input_string.</li><li>If field_type is “item”, let output be the result of running Parsing an Item (<a href="#parse-item" title="Parsing an Item">Section 4.2.3</a>) with input_string.</li><li>Discard any leading SP characters from input_string.</li><li>If input_string is not empty, fail parsing.</li><li>Otherwise, return output.</li></ol></div><div id="rfc.section.4.2.p.4"><p>When generating input_bytes, parsers MUST combine all field lines in the same section (header or trailer) that case-insensitively match the field name into one comma-separated field-value, as per <a href="#RFC7230"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing">[RFC7230]</cite></a>, Section 3.2.2; this assures that the entire field value is processed correctly.</p></div><div id="rfc.section.4.2.p.5"><p>For Lists and Dictionaries, this has the effect of correctly concatenating all of the field’s lines, as long as individual members of the top-level data structure are not split across multiple header instances. The parsing algorithms for both types allow tab characters, since these might be used to combine field lines by some implementations.</p></div><div id="rfc.section.4.2.p.6"><p>Strings split across multiple field lines will have unpredictable results, because comma(s) and whitespace inserted upon combination will become part of the string output by the parser. Since concatenation might be done by an upstream intermediary, the results are not under the control of the serializer or the parser, even when they are both under the control of the same party.</p></div><div id="rfc.section.4.2.p.7"><p>Tokens, Integers, Decimals and Byte Sequences cannot be split across multiple field lines because the inserted commas will cause parsing to fail.</p></div><div id="rfc.section.4.2.p.8" class="avoidbreakafter"><p>Parsers MAY fail when processing a field value spread across multiple field lines, when one of those lines does not parse as that field. For example, a parsing handling an Example-String field that’s defined as a sf-string is allowed to fail when processing this field section:</p></div><div id="rfc.figure.u.34"><div><pre class="text">
Example-String: "foo
Example-String: bar"
</pre></div></div><div id="rfc.section.4.2.p.9"><p>If parsing fails – including when calling another algorithm – the entire field value MUST be ignored (i.e., treated as if the field were not present in the section). This is intentionally strict, to improve interoperability and safety, and specifications referencing this document are not allowed to loosen this requirement.</p></div><div id="rfc.section.4.2.p.10"><p>Note that this requirement does not apply to an implementation that is not parsing the field; for example, an intermediary is not required to strip a failing field from a message before forwarding it.</p></div><section id="parse-list"><h4 id="rfc.section.4.2.1"><a href="#rfc.section.4.2.1">4.2.1.</a> <a href="#parse-list">Parsing a List</a></h4><div id="rfc.section.4.2.1.p.1"><p>Given an ASCII string as input_string, return an array of (item_or_inner_list, parameters) tuples. input_string is modified to remove the parsed value.</p></div><div id="rfc.section.4.2.1.p.2"><ol><li>Let members be an empty array.</li><li>While input_string is not empty: <ol><li>Append the result of running Parsing an Item or Inner List (<a href="#parse-item-or-list" title="Parsing an Item or Inner List">Section 4.2.1.1</a>) with input_string to members.</li><li>Discard any leading OWS characters from input_string.</li><li>If input_string is empty, return members.</li><li>Consume the first character of input_string; if it is not “,”, fail parsing.</li><li>Discard any leading OWS characters from input_string.</li><li>If input_string is empty, there is a trailing comma; fail parsing.</li></ol></li><li>No structured data has been found; return members (which is empty).</li></ol></div><section id="parse-item-or-list"><h5 id="rfc.section.4.2.1.1"><a href="#rfc.section.4.2.1.1">4.2.1.1.</a> <a href="#parse-item-or-list">Parsing an Item or Inner List</a></h5><div id="rfc.section.4.2.1.1.p.1"><p>Given an ASCII string as input_string, return the tuple (item_or_inner_list, parameters), where item_or_inner_list can be either a single bare item, or an array of (bare_item, parameters) tuples. input_string is modified to remove the parsed value.</p></div><div id="rfc.section.4.2.1.1.p.2"><ol><li>If the first character of input_string is “(“, return the result of running Parsing an Inner List (<a href="#parse-innerlist" title="Parsing an Inner List">Section 4.2.1.2</a>) with input_string.</li><li>Return the result of running Parsing an Item (<a href="#parse-item" title="Parsing an Item">Section 4.2.3</a>) with input_string.</li></ol></div></section><section id="parse-innerlist"><h5 id="rfc.section.4.2.1.2"><a href="#rfc.section.4.2.1.2">4.2.1.2.</a> <a href="#parse-innerlist">Parsing an Inner List</a></h5><div id="rfc.section.4.2.1.2.p.1"><p>Given an ASCII string as input_string, return the tuple (inner_list, parameters), where inner_list is an array of (bare_item, parameters) tuples. input_string is modified to remove the parsed value.</p></div><div id="rfc.section.4.2.1.2.p.2"><ol><li>Consume the first character of input_string; if it is not “(“, fail parsing.</li><li>Let inner_list be an empty array.</li><li>While input_string is not empty: <ol><li>Discard any leading SP characters from input_string.</li><li>If the first character of input_string is “)”: <ol><li>Consume the first character of input_string.</li><li>Let parameters be the result of running Parsing Parameters (<a href="#parse-param" title="Parsing Parameters">Section 4.2.3.2</a>) with input_string.</li><li>Return the tuple (inner_list, parameters).</li></ol></li><li>Let item be the result of running Parsing an Item (<a href="#parse-item" title="Parsing an Item">Section 4.2.3</a>) with input_string.</li><li>Append item to inner_list.</li><li>If the first character of input_string is not SP or “)”, fail parsing.</li></ol></li><li>The end of the inner list was not found; fail parsing.</li></ol></div></section></section><section id="parse-dictionary"><h4 id="rfc.section.4.2.2"><a href="#rfc.section.4.2.2">4.2.2.</a> <a href="#parse-dictionary">Parsing a Dictionary</a></h4><div id="rfc.section.4.2.2.p.1"><p>Given an ASCII string as input_string, return an ordered map whose values are (item_or_inner_list, parameters) tuples. input_string is modified to remove the parsed value.</p></div><div id="rfc.section.4.2.2.p.2"><ol><li>Let dictionary be an empty, ordered map.</li><li>While input_string is not empty: <ol><li>Let this_key be the result of running Parsing a Key (<a href="#parse-key" title="Parsing a Key">Section 4.2.3.3</a>) with input_string.</li><li>If the first character of input_string is “=”: <ol><li>Consume the first character of input_string.</li><li>Let member be the result of running Parsing an Item or Inner List (<a href="#parse-item-or-list" title="Parsing an Item or Inner List">Section 4.2.1.1</a>) with input_string.</li></ol></li><li>Otherwise: <ol><li>Let value be Boolean true.</li><li>Let parameters be the result of running Parsing Parameters <a href="#parse-param" title="Parsing Parameters">Section 4.2.3.2</a> with input_string.</li><li>Let member be the tuple (value, parameters).</li></ol></li><li>Add name this_key with value member to dictionary. If dictionary already contains a name this_key (comparing character-for-character), overwrite its value.</li><li>Discard any leading OWS characters from input_string.</li><li>If input_string is empty, return dictionary.</li><li>Consume the first character of input_string; if it is not “,”, fail parsing.</li><li>Discard any leading OWS characters from input_string.</li><li>If input_string is empty, there is a trailing comma; fail parsing.</li></ol></li><li>No structured data has been found; return dictionary (which is empty).</li></ol></div><div id="rfc.section.4.2.2.p.3"><p>Note that when duplicate Dictionary keys are encountered, this has the effect of ignoring all but the last instance.</p></div></section><section id="parse-item"><h4 id="rfc.section.4.2.3"><a href="#rfc.section.4.2.3">4.2.3.</a> <a href="#parse-item">Parsing an Item</a></h4><div id="rfc.section.4.2.3.p.1"><p>Given an ASCII string as input_string, return a (bare_item, parameters) tuple. input_string is modified to remove the parsed value.</p></div><div id="rfc.section.4.2.3.p.2"><ol><li>Let bare_item be the result of running Parsing a Bare Item (<a href="#parse-bare-item" title="Parsing a Bare Item">Section 4.2.3.1</a>) with input_string.</li><li>Let parameters be the result of running Parsing Parameters (<a href="#parse-param" title="Parsing Parameters">Section 4.2.3.2</a>) with input_string.</li><li>Return the tuple (bare_item, parameters).</li></ol></div><section id="parse-bare-item"><h5 id="rfc.section.4.2.3.1"><a href="#rfc.section.4.2.3.1">4.2.3.1.</a> <a href="#parse-bare-item">Parsing a Bare Item</a></h5><div id="rfc.section.4.2.3.1.p.1"><p>Given an ASCII string as input_string, return a bare Item. input_string is modified to remove the parsed value.</p></div><div id="rfc.section.4.2.3.1.p.2"><ol><li>If the first character of input_string is a “-“ or a DIGIT, return the result of running Parsing an Integer or Decimal (<a href="#parse-number" title="Parsing an Integer or Decimal">Section 4.2.4</a>) with input_string.</li><li>If the first character of input_string is a DQUOTE, return the result of running Parsing a String (<a href="#parse-string" title="Parsing a String">Section 4.2.5</a>) with input_string.</li><li>If the first character of input_string is “:”, return the result of running Parsing a Byte Sequence (<a href="#parse-binary" title="Parsing a Byte Sequence">Section 4.2.7</a>) with input_string.</li><li>If the first character of input_string is “?”, return the result of running Parsing a Boolean (<a href="#parse-boolean" title="Parsing a Boolean">Section 4.2.8</a>) with input_string.</li><li>If the first character of input_string is an ALPHA or “*”, return the result of running Parsing a Token (<a href="#parse-token" title="Parsing a Token">Section 4.2.6</a>) with input_string.</li><li>Otherwise, the item type is unrecognized; fail parsing.</li></ol></div></section><section id="parse-param"><h5 id="rfc.section.4.2.3.2"><a href="#rfc.section.4.2.3.2">4.2.3.2.</a> <a href="#parse-param">Parsing Parameters</a></h5><div id="rfc.section.4.2.3.2.p.1"><p>Given an ASCII string as input_string, return an ordered map whose values are bare Items. input_string is modified to remove the parsed value.</p></div><div id="rfc.section.4.2.3.2.p.2"><ol><li>Let parameters be an empty, ordered map.</li><li>While input_string is not empty: <ol><li>If the first character of input_string is not “;”, exit the loop.</li><li>Consume a “;” character from the beginning of input_string.</li><li>Discard any leading SP characters from input_string.</li><li>let param_name be the result of running Parsing a Key (<a href="#parse-key" title="Parsing a Key">Section 4.2.3.3</a>) with input_string.</li><li>Let param_value be Boolean true.</li><li>If the first character of input_string is “=”: <ol><li>Consume the “=” character at the beginning of input_string.</li><li>Let param_value be the result of running Parsing a Bare Item (<a href="#parse-bare-item" title="Parsing a Bare Item">Section 4.2.3.1</a>) with input_string.</li></ol></li><li>Append key param_name with value param_value to parameters. If parameters already contains a name param_name (comparing character-for-character), overwrite its value.</li></ol></li><li>Return parameters.</li></ol></div><div id="rfc.section.4.2.3.2.p.3"><p>Note that when duplicate Parameter keys are encountered, this has the effect of ignoring all but the last instance.</p></div></section><section id="parse-key"><h5 id="rfc.section.4.2.3.3"><a href="#rfc.section.4.2.3.3">4.2.3.3.</a> <a href="#parse-key">Parsing a Key</a></h5><div id="rfc.section.4.2.3.3.p.1"><p>Given an ASCII string as input_string, return a key. input_string is modified to remove the parsed value.</p></div><div id="rfc.section.4.2.3.3.p.2"><ol><li>If the first character of input_string is not lcalpha or “*”, fail parsing.</li><li>Let output_string be an empty string.</li><li>While input_string is not empty: <ol><li>If the first character of input_string is not one of lcalpha, DIGIT, “_”, “-“, “.”, or “*”, return output_string.</li><li>Let char be the result of consuming the first character of input_string.</li><li>Append char to output_string.</li></ol></li><li>Return output_string.</li></ol></div></section></section><section id="parse-number"><h4 id="rfc.section.4.2.4"><a href="#rfc.section.4.2.4">4.2.4.</a> <a href="#parse-number">Parsing an Integer or Decimal</a></h4><div id="rfc.section.4.2.4.p.1"><p>Given an ASCII string as input_string, return an Integer or Decimal. input_string is modified to remove the parsed value.</p></div><div id="rfc.section.4.2.4.p.2"><p>NOTE: This algorithm parses both Integers (<a href="#integer" title="Integers">Section 3.3.1</a>) and Decimals (<a href="#decimal" title="Decimals">Section 3.3.2</a>), and returns the corresponding structure.</p></div><div id="rfc.section.4.2.4.p.3"><ol><li>Let type be “integer”.</li><li>Let sign be 1.</li><li>Let input_number be an empty string.</li><li>If the first character of input_string is “-“, consume it and set sign to -1.</li><li>If input_string is empty, there is an empty integer; fail parsing.</li><li>If the first character of input_string is not a DIGIT, fail parsing.</li><li>While input_string is not empty: <ol><li>Let char be the result of consuming the first character of input_string.</li><li>If char is a DIGIT, append it to input_number.</li><li>Else, if type is “integer” and char is “.”: <ol><li>If input_number contains more than 12 characters, fail parsing.</li><li>Otherwise, append char to input_number and set type to “decimal”.</li></ol></li><li>Otherwise, prepend char to input_string, and exit the loop.</li><li>If type is “integer” and input_number contains more than 15 characters, fail parsing.</li><li>If type is “decimal” and input_number contains more than 16 characters, fail parsing.</li></ol></li><li>If type is “integer”: <ol><li>Parse input_number as an integer and let output_number be the product of the result and sign.</li><li>If output_number is outside the range -999,999,999,999,999 to 999,999,999,999,999 inclusive, fail parsing.</li></ol></li><li>Otherwise: <ol><li>If the final character of input_number is “.”, fail parsing.</li><li>If the number of characters after “.” in input_number is greater than three, fail parsing.</li><li>Parse input_number as a decimal number and let output_number be the product of the result and sign.</li></ol></li><li>Return output_number.</li></ol></div></section><section id="parse-string"><h4 id="rfc.section.4.2.5"><a href="#rfc.section.4.2.5">4.2.5.</a> <a href="#parse-string">Parsing a String</a></h4><div id="rfc.section.4.2.5.p.1"><p>Given an ASCII string as input_string, return an unquoted String. input_string is modified to remove the parsed value.</p></div><div id="rfc.section.4.2.5.p.2"><ol><li>Let output_string be an empty string.</li><li>If the first character of input_string is not DQUOTE, fail parsing.</li><li>Discard the first character of input_string.</li><li>While input_string is not empty: <ol><li>Let char be the result of consuming the first character of input_string.</li><li>If char is a backslash (“\”): <ol><li>If input_string is now empty, fail parsing.</li><li>Let next_char be the result of consuming the first character of input_string.</li><li>If next_char is not DQUOTE or “\”, fail parsing.</li><li>Append next_char to output_string.</li></ol></li><li>Else, if char is DQUOTE, return output_string.</li><li>Else, if char is in the range %x00-1f or %x7f (i.e., is not in VCHAR or SP), fail parsing.</li><li>Else, append char to output_string.</li></ol></li><li>Reached the end of input_string without finding a closing DQUOTE; fail parsing.</li></ol></div></section><section id="parse-token"><h4 id="rfc.section.4.2.6"><a href="#rfc.section.4.2.6">4.2.6.</a> <a href="#parse-token">Parsing a Token</a></h4><div id="rfc.section.4.2.6.p.1"><p>Given an ASCII string as input_string, return a Token. input_string is modified to remove the parsed value.</p></div><div id="rfc.section.4.2.6.p.2"><ol><li>If the first character of input_string is not ALPHA or “*”, fail parsing.</li><li>Let output_string be an empty string.</li><li>While input_string is not empty: <ol><li>If the first character of input_string is not in tchar, “:” or “/”, return output_string.</li><li>Let char be the result of consuming the first character of input_string.</li><li>Append char to output_string.</li></ol></li><li>Return output_string.</li></ol></div></section><section id="parse-binary"><h4 id="rfc.section.4.2.7"><a href="#rfc.section.4.2.7">4.2.7.</a> <a href="#parse-binary">Parsing a Byte Sequence</a></h4><div id="rfc.section.4.2.7.p.1"><p>Given an ASCII string as input_string, return a Byte Sequence. input_string is modified to remove the parsed value.</p></div><div id="rfc.section.4.2.7.p.2"><ol><li>If the first character of input_string is not “:”, fail parsing.</li><li>Discard the first character of input_string.</li><li>If there is not a “:” character before the end of input_string, fail parsing.</li><li>Let b64_content be the result of consuming content of input_string up to but not including the first instance of the character “:”.</li><li>Consume the “:” character at the beginning of input_string.</li><li>If b64_content contains a character not included in ALPHA, DIGIT, “+”, “/” and “=”, fail parsing.</li><li>Let binary_content be the result of Base 64 Decoding <a href="#RFC4648"><cite title="The Base16, Base32, and Base64 Data Encodings">[RFC4648]</cite></a> b64_content, synthesizing padding if necessary (note the requirements about recipient behavior below).</li><li>Return binary_content.</li></ol></div><div id="rfc.section.4.2.7.p.3"><p>Because some implementations of base64 do not allow rejection of encoded data that is not properly “=” padded (see <a href="#RFC4648"><cite title="The Base16, Base32, and Base64 Data Encodings">[RFC4648]</cite></a>, Section 3.2), parsers SHOULD NOT fail when “=” padding is not present, unless they cannot be configured to do so.</p></div><div id="rfc.section.4.2.7.p.4"><p>Because some implementations of base64 do not allow rejection of encoded data that has non-zero pad bits (see <a href="#RFC4648"><cite title="The Base16, Base32, and Base64 Data Encodings">[RFC4648]</cite></a>, Section 3.5), parsers SHOULD NOT fail when non-zero pad bits are present, unless they cannot be configured to do so.</p></div><div id="rfc.section.4.2.7.p.5"><p>This specification does not relax the requirements in <a href="#RFC4648"><cite title="The Base16, Base32, and Base64 Data Encodings">[RFC4648]</cite></a>, Section 3.1 and 3.3; therefore, parsers MUST fail on characters outside the base64 alphabet, and on line feeds in encoded data.</p></div></section><section id="parse-boolean"><h4 id="rfc.section.4.2.8"><a href="#rfc.section.4.2.8">4.2.8.</a> <a href="#parse-boolean">Parsing a Boolean</a></h4><div id="rfc.section.4.2.8.p.1"><p>Given an ASCII string as input_string, return a Boolean. input_string is modified to remove the parsed value.</p></div><div id="rfc.section.4.2.8.p.2"><ol><li>If the first character of input_string is not “?”, fail parsing.</li><li>Discard the first character of input_string.</li><li>If the first character of input_string matches “1”, discard the first character, and return true.</li><li>If the first character of input_string matches “0”, discard the first character, and return false.</li><li>No value has matched; fail parsing.</li></ol></div></section></section></section><section id="iana-considerations"><h2 id="rfc.section.5"><a href="#rfc.section.5">5.</a> <a href="#iana-considerations">IANA Considerations</a></h2><div id="rfc.section.5.p.1"><p>This document has no actions for IANA.</p></div></section><section id="security-considerations"><h2 id="rfc.section.6"><a href="#rfc.section.6">6.</a> <a href="#security-considerations">Security Considerations</a></h2><div id="rfc.section.6.p.1"><p>The size of most types defined by Structured Fields is not limited; as a result, extremely large fields could be an attack vector (e.g., for resource consumption). Most HTTP implementations limit the sizes of individual fields as well as the overall header or trailer section size to mitigate such attacks.</p></div><div id="rfc.section.6.p.2"><p>It is possible for parties with the ability to inject new HTTP fields to change the meaning of a Structured Field. In some circumstances, this will cause parsing to fail, but it is not possible to reliably fail in all such circumstances.</p></div></section><section id="rfc.references"><h2 id="rfc.section.7"><a href="#rfc.section.7">7.</a> References</h2><section><div id="rfc.references.1"><h3 id="rfc.section.7.1"><a href="#rfc.section.7.1">7.1.</a> Normative References</h3><dl class="reference"><dt id="RFC0020">[RFC0020]</dt><dd>Cerf, V., “<a href="https://www.rfc-editor.org/rfc/rfc20.html">ASCII format for network interchange</a>”, STD 80, RFC 20, <a href="https://dx.doi.org/10.17487/RFC0020">DOI 10.17487/RFC0020</a>, October 1969, &lt;<a href="https://www.rfc-editor.org/info/rfc20">https://www.rfc-editor.org/info/rfc20</a>&gt;.</dd><dt id="RFC2119">[RFC2119]</dt><dd>Bradner, S., “<a href="https://www.rfc-editor.org/rfc/rfc2119.html">Key words for use in RFCs to Indicate Requirement Levels</a>”, BCP 14, RFC 2119, <a href="https://dx.doi.org/10.17487/RFC2119">DOI 10.17487/RFC2119</a>, March 1997, &lt;<a href="https://www.rfc-editor.org/info/rfc2119">https://www.rfc-editor.org/info/rfc2119</a>&gt;.</dd><dt id="RFC4648">[RFC4648]</dt><dd>Josefsson, S., “<a href="https://www.rfc-editor.org/rfc/rfc4648.html">The Base16, Base32, and Base64 Data Encodings</a>”, RFC 4648, <a href="https://dx.doi.org/10.17487/RFC4648">DOI 10.17487/RFC4648</a>, October 2006, &lt;<a href="https://www.rfc-editor.org/info/rfc4648">https://www.rfc-editor.org/info/rfc4648</a>&gt;.</dd><dt id="RFC5234">[RFC5234]</dt><dd>Crocker, D., Ed. and P. Overell, “<a href="https://www.rfc-editor.org/rfc/rfc5234.html">Augmented BNF for Syntax Specifications: ABNF</a>”, STD 68, RFC 5234, <a href="https://dx.doi.org/10.17487/RFC5234">DOI 10.17487/RFC5234</a>, January 2008, &lt;<a href="https://www.rfc-editor.org/info/rfc5234">https://www.rfc-editor.org/info/rfc5234</a>&gt;.</dd><dt id="RFC7230">[RFC7230]</dt><dd>Fielding, R., Ed. and J. Reschke, Ed., “<a href="https://www.rfc-editor.org/rfc/rfc7230.html">Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</a>”, RFC 7230, <a href="https://dx.doi.org/10.17487/RFC7230">DOI 10.17487/RFC7230</a>, June 2014, &lt;<a href="https://www.rfc-editor.org/info/rfc7230">https://www.rfc-editor.org/info/rfc7230</a>&gt;.</dd><dt id="RFC8174">[RFC8174]</dt><dd>Leiba, B., “<a href="https://www.rfc-editor.org/rfc/rfc8174.html">Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</a>”, BCP 14, RFC 8174, <a href="https://dx.doi.org/10.17487/RFC8174">DOI 10.17487/RFC8174</a>, May 2017, &lt;<a href="https://www.rfc-editor.org/info/rfc8174">https://www.rfc-editor.org/info/rfc8174</a>&gt;.</dd></dl></div></section><section><div id="rfc.references.2"><h3 id="rfc.section.7.2"><a href="#rfc.section.7.2">7.2.</a> Informative References</h3><dl class="reference"><dt id="IEEE754">[IEEE754]</dt><dd>IEEE, “<a href="https://ieeexplore.ieee.org/document/8766229">IEEE Standard for Floating-Point Arithmetic</a>”, IEEE 754-2019, <a href="https://dx.doi.org/10.1109/IEEESTD.2019.8766229">DOI 10.1109/IEEESTD.2019.8766229</a>, <a href="https://www.worldcat.org/search?q=isbn:9781504459242">ISBN 978-1-5044-5924-2</a>, July 2019, &lt;<a href="https://ieeexplore.ieee.org/document/8766229">https://ieeexplore.ieee.org/document/8766229</a>&gt;.</dd><dt id="RFC7231">[RFC7231]</dt><dd>Fielding, R., Ed. and J. Reschke, Ed., “<a href="https://www.rfc-editor.org/rfc/rfc7231.html">Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content</a>”, RFC 7231, <a href="https://dx.doi.org/10.17487/RFC7231">DOI 10.17487/RFC7231</a>, June 2014, &lt;<a href="https://www.rfc-editor.org/info/rfc7231">https://www.rfc-editor.org/info/rfc7231</a>&gt;.</dd><dt id="RFC7493">[RFC7493]</dt><dd>Bray, T., Ed., “<a href="https://www.rfc-editor.org/rfc/rfc7493.html">The I-JSON Message Format</a>”, RFC 7493, <a href="https://dx.doi.org/10.17487/RFC7493">DOI 10.17487/RFC7493</a>, March 2015, &lt;<a href="https://www.rfc-editor.org/info/rfc7493">https://www.rfc-editor.org/info/rfc7493</a>&gt;.</dd><dt id="RFC7540">[RFC7540]</dt><dd>Belshe, M., Peon, R., and M. Thomson, Ed., “<a href="https://www.rfc-editor.org/rfc/rfc7540.html">Hypertext Transfer Protocol Version 2 (HTTP/2)</a>”, RFC 7540, <a href="https://dx.doi.org/10.17487/RFC7540">DOI 10.17487/RFC7540</a>, May 2015, &lt;<a href="https://www.rfc-editor.org/info/rfc7540">https://www.rfc-editor.org/info/rfc7540</a>&gt;.</dd><dt id="RFC7541">[RFC7541]</dt><dd>Peon, R. and H. Ruellan, “<a href="https://www.rfc-editor.org/rfc/rfc7541.html">HPACK: Header Compression for HTTP/2</a>”, RFC 7541, <a href="https://dx.doi.org/10.17487/RFC7541">DOI 10.17487/RFC7541</a>, May 2015, &lt;<a href="https://www.rfc-editor.org/info/rfc7541">https://www.rfc-editor.org/info/rfc7541</a>&gt;.</dd><dt id="RFC8259">[RFC8259]</dt><dd>Bray, T., Ed., “<a href="https://www.rfc-editor.org/rfc/rfc8259.html">The JavaScript Object Notation (JSON) Data Interchange Format</a>”, STD 90, RFC 8259, <a href="https://dx.doi.org/10.17487/RFC8259">DOI 10.17487/RFC8259</a>, December 2017, &lt;<a href="https://www.rfc-editor.org/info/rfc8259">https://www.rfc-editor.org/info/rfc8259</a>&gt;.</dd><dt id="UTF-8">[UTF-8]</dt><dd>Yergeau, F., “<a href="http://www.rfc-editor.org/info/std63">UTF-8, a transformation format of ISO 10646</a>”, STD 63, RFC 3629, <a href="https://dx.doi.org/10.17487/RFC3629">DOI 10.17487/RFC3629</a>, November 2003, &lt;<a href="http://www.rfc-editor.org/info/std63">http://www.rfc-editor.org/info/std63</a>&gt;.</dd></dl></div></section></section><section id="faq"><h2 id="rfc.section.A" class="np"><a href="#rfc.section.A">Appendix A.</a> <a href="#faq">Frequently Asked Questions</a></h2><section id="why-not-json"><h3 id="rfc.section.A.1"><a href="#rfc.section.A.1">A.1.</a> <a href="#why-not-json">Why not JSON?</a></h3><div id="rfc.section.A.1.p.1"><p>Earlier proposals for Structured Fields were based upon JSON <a href="#RFC8259"><cite title="The JavaScript Object Notation (JSON) Data Interchange Format">[RFC8259]</cite></a>. However, constraining its use to make it suitable for HTTP header fields required senders and recipients to implement specific additional handling.</p></div><div id="rfc.section.A.1.p.2"><p>For example, JSON has specification issues around large numbers and objects with duplicate members. Although advice for avoiding these issues is available (e.g., <a href="#RFC7493"><cite title="The I-JSON Message Format">[RFC7493]</cite></a>), it cannot be relied upon.</p></div><div id="rfc.section.A.1.p.3"><p>Likewise, JSON strings are by default Unicode strings, which have a number of potential interoperability issues (e.g., in comparison). Although implementers can be advised to avoid non-ASCII content where unnecessary, this is difficult to enforce.</p></div><div id="rfc.section.A.1.p.4"><p>Another example is JSON’s ability to nest content to arbitrary depths. Since the resulting memory commitment might be unsuitable (e.g., in embedded and other limited server deployments), it’s necessary to limit it in some fashion; however, existing JSON implementations have no such limits, and even if a limit is specified, it’s likely that some field definition will find a need to violate it.</p></div><div id="rfc.section.A.1.p.5"><p>Because of JSON’s broad adoption and implementation, it is difficult to impose such additional constraints across all implementations; some deployments would fail to enforce them, thereby harming interoperability. In short, if it looks like JSON, people will be tempted to use a JSON parser / serializer on field values.</p></div><div id="rfc.section.A.1.p.6"><p>Since a major goal for Structured Fields is to improve interoperability and simplify implementation, these concerns led to a format that requires a dedicated parser and serializer.</p></div><div id="rfc.section.A.1.p.7"><p>Additionally, there were widely shared feelings that JSON doesn’t “look right” in HTTP fields.</p></div></section></section><section id="implementation-notes"><h2 id="rfc.section.B"><a href="#rfc.section.B">Appendix B.</a> <a href="#implementation-notes">Implementation Notes</a></h2><div id="rfc.section.B.p.1"><p>A generic implementation of this specification should expose the top-level serialize (<a href="#text-serialize" title="Serializing Structured Fields">Section 4.1</a>) and parse (<a href="#text-parse" title="Parsing Structured Fields">Section 4.2</a>) functions. They need not be functions; for example, it could be implemented as an object, with methods for each of the different top-level types.</p></div><div id="rfc.section.B.p.2"><p>For interoperability, it’s important that generic implementations be complete and follow the algorithms closely; see <a href="#strict" title="Intentionally Strict Processing">Section 1.1</a>. To aid this, a common test suite is being maintained by the community at <a href="https://github.com/httpwg/structured-field-tests">https://github.com/httpwg/structured-field-tests</a>.</p></div><div id="rfc.section.B.p.3"><p>Implementers should note that Dictionaries and Parameters are order-preserving maps. Some fields may not convey meaning in the ordering of these data types, but it should still be exposed so that applications which need to use it will have it available.</p></div><div id="rfc.section.B.p.4"><p>Likewise, implementations should note that it’s important to preserve the distinction between Tokens and Strings. While most programming languages have native types that map to the other types well, it may be necessary to create a wrapper “token” object or use a parameter on functions to assure that these types remain separate.</p></div><div id="rfc.section.B.p.5"><p>The serialization algorithm is defined in a way that it is not strictly limited to the data types defined in <a href="#types" title="Structured Data Types">Section 3</a> in every case. For example, Decimals are designed to take broader input and round to allowed values.</p></div><div id="rfc.section.B.p.6"><p>Implementations are allowed to limit the allowed size of different structures, subject to the minimums defined for each type. When a structure exceeds an implementation limit, that structure fails parsing or serialisation.</p></div></section><section id="changes"><h2 id="rfc.section.C"><a href="#rfc.section.C">Appendix C.</a> <a href="#changes">Changes</a></h2><div id="rfc.section.C.p.1"><p><em>RFC Editor: Please remove this section before publication.</em></p></div><section id="since-draft-ietf-httpbis-header-structure-18"><h3 id="rfc.section.C.1"><a href="#rfc.section.C.1">C.1.</a> <a href="#since-draft-ietf-httpbis-header-structure-18">Since draft-ietf-httpbis-header-structure-18</a></h3><div id="rfc.section.C.1.p.1"><ul><li>Use “sf-“ prefix for ABNF, not “sh-“.</li><li>Fix indentation in Dictionary serialisation (#1164).</li><li>Add example for Token; tweak example field names (#1147).</li><li>Editorial improvements.</li><li>Note that exceeding implementation limits implies failure.</li><li>Talk about specifying order of Dictionary members and Parameters, not cardinality.</li><li>Allow (but don’t require) parsers to fail when a single field line isn’t valid.</li><li>Note that some aspects of Integers and Decimals are not necessarily preserved.</li><li>Allow Lists and Dictionaries to be delimited by OWS, rather than *SP, to make parsing more robust.</li></ul></div></section><section id="since-draft-ietf-httpbis-header-structure-17"><h3 id="rfc.section.C.2"><a href="#rfc.section.C.2">C.2.</a> <a href="#since-draft-ietf-httpbis-header-structure-17">Since draft-ietf-httpbis-header-structure-17</a></h3><div id="rfc.section.C.2.p.1"><ul><li>Editorial improvements.</li></ul></div></section><section id="since-draft-ietf-httpbis-header-structure-16"><h3 id="rfc.section.C.3"><a href="#rfc.section.C.3">C.3.</a> <a href="#since-draft-ietf-httpbis-header-structure-16">Since draft-ietf-httpbis-header-structure-16</a></h3><div id="rfc.section.C.3.p.1"><ul><li>Editorial improvements.</li><li>Discussion on forwards compatibility.</li></ul></div></section><section id="since-draft-ietf-httpbis-header-structure-15"><h3 id="rfc.section.C.4"><a href="#rfc.section.C.4">C.4.</a> <a href="#since-draft-ietf-httpbis-header-structure-15">Since draft-ietf-httpbis-header-structure-15</a></h3><div id="rfc.section.C.4.p.1"><ul><li>Editorial improvements.</li><li>Use HTTP field terminology more consistently, in line with recent changes to HTTP-core.</li><li>String length requirements apply to decoded strings (#1051).</li><li>Correctly round decimals in serialisation (#1043).</li><li>Clarify input to serialisation algorithms (#1055).</li><li>Omitted True dictionary value can have parameters (#1083).</li><li>Keys can now start with ‘*’ (#1068).</li></ul></div></section><section id="since-draft-ietf-httpbis-header-structure-14"><h3 id="rfc.section.C.5"><a href="#rfc.section.C.5">C.5.</a> <a href="#since-draft-ietf-httpbis-header-structure-14">Since draft-ietf-httpbis-header-structure-14</a></h3><div id="rfc.section.C.5.p.1"><ul><li>Editorial improvements.</li><li>Allow empty dictionary values (#992).</li><li>Change value of omitted parameter value to True (#995).</li><li>Explain more about splitting dictionaries and lists across header instances (#997).</li><li>Disallow HTAB, replace OWS with spaces (#998).</li><li>Change byte sequence delimiters from “*” to “:” (#991).</li><li>Allow tokens to start with “*” (#991).</li><li>Change Floats to fixed-precision Decimals (#982).</li><li>Round the fractional component of decimal, rather than truncating it (#982).</li><li>Handle duplicate dictionary and parameter keys by overwriting their values, rather than failing (#997).</li><li>Allow “.” in key (#1027).</li><li>Check first character of key in serialisation (#1037).</li><li>Talk about greasing headers (#1015).</li></ul></div></section><section id="since-draft-ietf-httpbis-header-structure-13"><h3 id="rfc.section.C.6"><a href="#rfc.section.C.6">C.6.</a> <a href="#since-draft-ietf-httpbis-header-structure-13">Since draft-ietf-httpbis-header-structure-13</a></h3><div id="rfc.section.C.6.p.1"><ul><li>Editorial improvements.</li><li>Define “structured header name” and “structured header value” terms (#908).</li><li>Corrected text about valid characters in strings (#931).</li><li>Removed most instances of the word “textual”, as it was redundant (#915).</li><li>Allowed parameters on Items and Inner Lists (#907).</li><li>Expand the range of characters in token (#961).</li><li>Disallow OWS before “;” delimiter in parameters (#961).</li></ul></div></section><section id="since-draft-ietf-httpbis-header-structure-12"><h3 id="rfc.section.C.7"><a href="#rfc.section.C.7">C.7.</a> <a href="#since-draft-ietf-httpbis-header-structure-12">Since draft-ietf-httpbis-header-structure-12</a></h3><div id="rfc.section.C.7.p.1"><ul><li>Editorial improvements.</li><li>Reworked float serialisation (#896).</li><li>Don’t add a trailing space in inner-list (#904).</li></ul></div></section><section id="since-draft-ietf-httpbis-header-structure-11"><h3 id="rfc.section.C.8"><a href="#rfc.section.C.8">C.8.</a> <a href="#since-draft-ietf-httpbis-header-structure-11">Since draft-ietf-httpbis-header-structure-11</a></h3><div id="rfc.section.C.8.p.1"><ul><li>Allow * in key (#844).</li><li>Constrain floats to six digits of precision (#848).</li><li>Allow dictionary members to have parameters (#842).</li></ul></div></section><section id="since-draft-ietf-httpbis-header-structure-10"><h3 id="rfc.section.C.9"><a href="#rfc.section.C.9">C.9.</a> <a href="#since-draft-ietf-httpbis-header-structure-10">Since draft-ietf-httpbis-header-structure-10</a></h3><div id="rfc.section.C.9.p.1"><ul><li>Update abstract (#799).</li><li>Input and output are now arrays of bytes (#662).</li><li>Implementations need to preserve difference between token and string (#790).</li><li>Allow empty dictionaries and lists (#781).</li><li>Change parameterized lists to have primary items (#797).</li><li>Allow inner lists in both dictionaries and lists; removes lists of lists (#816).</li><li>Subsume Parameterised Lists into Lists (#839).</li></ul></div></section><section id="since-draft-ietf-httpbis-header-structure-09"><h3 id="rfc.section.C.10"><a href="#rfc.section.C.10">C.10.</a> <a href="#since-draft-ietf-httpbis-header-structure-09">Since draft-ietf-httpbis-header-structure-09</a></h3><div id="rfc.section.C.10.p.1"><ul><li>Changed Boolean from T/F to 1/0 (#784).</li><li>Parameters are now ordered maps (#765).</li><li>Clamp integers to 15 digits (#737).</li></ul></div></section><section id="since-draft-ietf-httpbis-header-structure-08"><h3 id="rfc.section.C.11"><a href="#rfc.section.C.11">C.11.</a> <a href="#since-draft-ietf-httpbis-header-structure-08">Since draft-ietf-httpbis-header-structure-08</a></h3><div id="rfc.section.C.11.p.1"><ul><li>Disallow whitespace before items properly (#703).</li><li>Created “key” for use in dictionaries and parameters, rather than relying on identifier (#702). Identifiers have a separate minimum supported size.</li><li>Expanded the range of special characters allowed in identifier to include all of ALPHA, “.”, “:”, and “%” (#702).</li><li>Use “?” instead of “!” to indicate a Boolean (#719).</li><li>Added “Intentionally Strict Processing” (#684).</li><li>Gave better names for referring specs to use in Parameterised Lists (#720).</li><li>Added Lists of Lists (#721).</li><li>Rename Identifier to Token (#725).</li><li>Add implementation guidance (#727).</li></ul></div></section><section id="since-draft-ietf-httpbis-header-structure-07"><h3 id="rfc.section.C.12"><a href="#rfc.section.C.12">C.12.</a> <a href="#since-draft-ietf-httpbis-header-structure-07">Since draft-ietf-httpbis-header-structure-07</a></h3><div id="rfc.section.C.12.p.1"><ul><li>Make Dictionaries ordered mappings (#659).</li><li>Changed “binary content” to “byte sequence” to align with Infra specification (#671).</li><li>Changed “mapping” to “map” for #671.</li><li>Don’t fail if byte sequences aren’t “=” padded (#658).</li><li>Add Booleans (#683).</li><li>Allow identifiers in items again (#629).</li><li>Disallowed whitespace before items (#703).</li><li>Explain the consequences of splitting a string across multiple headers (#686).</li></ul></div></section><section id="since-draft-ietf-httpbis-header-structure-06"><h3 id="rfc.section.C.13"><a href="#rfc.section.C.13">C.13.</a> <a href="#since-draft-ietf-httpbis-header-structure-06">Since draft-ietf-httpbis-header-structure-06</a></h3><div id="rfc.section.C.13.p.1"><ul><li>Add a FAQ.</li><li>Allow non-zero pad bits.</li><li>Explicitly check for integers that violate constraints.</li></ul></div></section><section id="since-draft-ietf-httpbis-header-structure-05"><h3 id="rfc.section.C.14"><a href="#rfc.section.C.14">C.14.</a> <a href="#since-draft-ietf-httpbis-header-structure-05">Since draft-ietf-httpbis-header-structure-05</a></h3><div id="rfc.section.C.14.p.1"><ul><li>Reorganise specification to separate parsing out.</li><li>Allow referencing specs to use ABNF.</li><li>Define serialisation algorithms.</li><li>Refine relationship between ABNF, parsing and serialisation algorithms.</li></ul></div></section><section id="since-draft-ietf-httpbis-header-structure-04"><h3 id="rfc.section.C.15"><a href="#rfc.section.C.15">C.15.</a> <a href="#since-draft-ietf-httpbis-header-structure-04">Since draft-ietf-httpbis-header-structure-04</a></h3><div id="rfc.section.C.15.p.1"><ul><li>Remove identifiers from item.</li><li>Remove most limits on sizes.</li><li>Refine number parsing.</li></ul></div></section><section id="since-draft-ietf-httpbis-header-structure-03"><h3 id="rfc.section.C.16"><a href="#rfc.section.C.16">C.16.</a> <a href="#since-draft-ietf-httpbis-header-structure-03">Since draft-ietf-httpbis-header-structure-03</a></h3><div id="rfc.section.C.16.p.1"><ul><li>Strengthen language around failure handling.</li></ul></div></section><section id="since-draft-ietf-httpbis-header-structure-02"><h3 id="rfc.section.C.17"><a href="#rfc.section.C.17">C.17.</a> <a href="#since-draft-ietf-httpbis-header-structure-02">Since draft-ietf-httpbis-header-structure-02</a></h3><div id="rfc.section.C.17.p.1"><ul><li>Split Numbers into Integers and Floats.</li><li>Define number parsing.</li><li>Tighten up binary parsing and give it an explicit end delimiter.</li><li>Clarify that mappings are unordered.</li><li>Allow zero-length strings.</li><li>Improve string parsing algorithm.</li><li>Improve limits in algorithms.</li><li>Require parsers to combine header fields before processing.</li><li>Throw an error on trailing garbage.</li></ul></div></section><section id="since-draft-ietf-httpbis-header-structure-01"><h3 id="rfc.section.C.18"><a href="#rfc.section.C.18">C.18.</a> <a href="#since-draft-ietf-httpbis-header-structure-01">Since draft-ietf-httpbis-header-structure-01</a></h3><div id="rfc.section.C.18.p.1"><ul><li>Replaced with draft-nottingham-structured-headers.</li></ul></div></section><section id="since-draft-ietf-httpbis-header-structure-00"><h3 id="rfc.section.C.19"><a href="#rfc.section.C.19">C.19.</a> <a href="#since-draft-ietf-httpbis-header-structure-00">Since draft-ietf-httpbis-header-structure-00</a></h3><div id="rfc.section.C.19.p.1"><ul><li>Added signed 64bit integer type.</li><li>Drop UTF8, and settle on BCP137 ::EmbeddedUnicodeChar for h1-unicode-string.</li><li>Change h1_blob delimiter to “:” since “’” is valid t_char</li></ul></div></section></section><section id="acknowledgements"><h2 id="rfc.section.unnumbered-1"><a href="#acknowledgements">Acknowledgements</a></h2><div id="rfc.section.unnumbered-1.p.1"><p>Many thanks to Matthew Kerwin for his detailed feedback and careful consideration during the development of this specification.</p></div><div id="rfc.section.unnumbered-1.p.2"><p>Thanks also to Ian Clelland, Roy Fielding, Anne van Kesteren, Kazuho Oku, Evert Pot, Julian Reschke, Martin Thomson, Mike West, and Jeffrey Yasskin for their contributions.</p></div></section><section id="rfc.authors" class="avoidbreakinside"><h2><a href="#rfc.authors">Authors' Addresses</a></h2><address><b>Mark Nottingham</b><br>Fastly<br>made in<br>Prahran, VIC<br>Australia<br>EMail: <a href="mailto:mnot@mnot.net">mnot@mnot.net</a><br>URI: <a href="https://www.mnot.net/">https://www.mnot.net/</a></address><address><b>Poul-Henning Kamp</b><br>The Varnish Cache Project<br>EMail: <a href="mailto:phk@varnish-cache.org">phk@varnish-cache.org</a></address></section></body></html>
