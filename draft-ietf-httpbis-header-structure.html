<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>HTTP Header Common Structure</title><script type="application/javascript">
function anchorRewrite() {
  map = { };
  if (window.location.hash.length >= 1) {
    var fragid = window.location.hash.substr(1);
    if (fragid) {
      if (! document.getElementById(fragid)) {
        var prefix = "rfc.";
        var mapped = map[fragid];
        if (mapped) {
          window.location.hash = mapped;
        } else if (fragid.indexOf("section-") == 0) {
          window.location.hash = prefix + "section." + fragid.substring(8);
        } else if (fragid.indexOf("appendix-") == 0) {
          window.location.hash = prefix + "section." + fragid.substring(9);
        } else if (fragid.indexOf("s-") == 0) {
          var postfix = fragid.substring(2);
          if (postfix.startsWith("abstract")) {
            window.location.hash = prefix + postfix;
          } else if (postfix.startsWith("note-")) {
            window.location.hash = prefix + "note." + postfix.substring(5);
          } else {
            window.location.hash = prefix + "section." + postfix;
          }
        } else if (fragid.indexOf("p-") == 0) {
          var r = fragid.substring(2);
          var p = r.indexOf("-");
          if (p >= 0) {
            window.location.hash = prefix + "section." + r.substring(0, p) + ".p." + r.substring(p + 1);
          }
        }
      }
    }  
  }
}
window.addEventListener('hashchange', anchorRewrite);
window.addEventListener('DOMContentLoaded', anchorRewrite);
</script><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="stylesheet" type="text/css" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap.min.css"><style type="text/css">
      body {
        padding-top: 80px;
        padding-bottom: 80px;
        position: relative;
      }
      .table.header th, .table.header td {
        border-top: none;
        padding: 0;
      }
      #rfc\.meta {
        width: 40%;
        float: right
      }
      #rfc\.toc > ul ul {
        list-style: none;
      }
      #sidebar {
        position: fixed;
        height: 90%;
        overflow-y: auto;
        font-size: 90%;
      }
      .container .nav-sublist {
        padding-left: 20px;
        padding-right: 10px;
        font-size: 90%;
      }
      .container .navbar-brand {
        padding-top: 0;
      }
      .container .nav > li > a {
        padding: 10px 7px 5px 15px;
        display: inline-block;
      }
      .container .nav > li > a + a {
        padding: 10px 15px 5px 7px;
        display: inline-block;
      }
      .container .nav > li > a {
        padding: 5px 10px;
      }
      .filename {
        color: rgb(119, 119, 119);
        font-size: 23px;
        font-weight: normal;
        height: auto;
        line-height: 23px;
      }
      dl {
        margin-left: 1em;
      }
      dl.dl-horizontal: {
        margin-left: 0;
      }
      dl > dt {
        float: left;
        margin-right: 1em;
      }
      dl.nohang > dt {
        float: none;
      }
      dl > dd {
        margin-bottom: .5em;
      }
      dl.compact > dd {
        margin-bottom: 0em;
      }
      dl > dd > dl {
        margin-top: 0.5em;
        margin-bottom: 0em;
      }
      ul.empty {
        list-style-type: none;
      }
      ul.empty li {
        margin-top: .5em;
      }
      td.reference {
        padding-right: 1em;
        vertical-align: top;
      }
      .feedback {
        position: fixed;
        bottom: 5px;
        right: 5px;
      }
      .fbbutton {
        margin-left: 5px;
      }
      h1 a, h2 a, h3 a, h4 a, h5 a, h6 a {
        color: rgb(51, 51, 51);
      }
      span.tt {
        font: 11pt consolas, monospace;
        font-size-adjust: none;
      }
    </style><link rel="Author" href="#rfc.authors"><link rel="Copyright" href="#rfc.copyrightnotice"><link rel="Chapter" title="1 Introduction" href="#rfc.section.1"><link rel="Chapter" title="2 Definition of HTTP Header Common Structure" href="#rfc.section.2"><link rel="Chapter" title="3 HTTP/1 Serialization of HTTP Header Common Structure" href="#rfc.section.3"><link rel="Chapter" title="4 When to use Common Structure Parser" href="#rfc.section.4"><link rel="Chapter" title="5 Desired Normative Effects" href="#rfc.section.5"><link rel="Chapter" title="6 Open/Outstanding issues to resolve" href="#rfc.section.6"><link rel="Chapter" title="7 Future Work" href="#rfc.section.7"><link rel="Chapter" title="8 IANA Considerations" href="#rfc.section.8"><link rel="Chapter" title="9 Security Considerations" href="#rfc.section.9"><link rel="Chapter" href="#rfc.section.10" title="10 References"><link rel="Appendix" title="A Do HTTP headers have any common structure ?" href="#rfc.section.A"><link rel="Appendix" title="B Changes" href="#rfc.section.B"><meta name="generator" content="https://github.com/mnot/RFCBootstrap XSLT vendor: SAXON 9.1.0.8 from Saxonica http://www.saxonica.com/"><meta name="keywords" content="Internet-Draft"><link rel="schema.dcterms" href="http://purl.org/dc/terms/"><meta name="dcterms.creator" content="Kamp, P-H."><meta name="dcterms.identifier" content="urn:ietf:id:draft-ietf-httpbis-header-structure-latest"><meta name="dcterms.issued" content="2017-10-23"><meta name="dcterms.abstract" content="An abstract data model for HTTP headers, “Common Structure”, and a HTTP/1 serialization of it, generalized from current HTTP headers."><meta name="description" content="An abstract data model for HTTP headers, “Common Structure”, and a HTTP/1 serialization of it, generalized from current HTTP headers."></head><body><div class="container" id="top"><div class="row"><div class="col-md-4 col-md-push-8 hidden-sm hidden-xs" id="sidebar" role="navigation"><div class="navbar"><div class="navbar-brand"><a href="#top">draft-ietf-httpbis-header-structure-latest</a></div><br clear="all"><div class=""><div id="rfc.toc"><ul class="nav"><li><a href="#rfc.section.1">1.</a>&nbsp;&nbsp;&nbsp;<a href="#introduction">Introduction</a><ul><li><a href="#rfc.section.1.1">1.1.</a>&nbsp;&nbsp;&nbsp;<a href="#terminology">Terminology</a></li></ul></li><li><a href="#rfc.section.2">2.</a>&nbsp;&nbsp;&nbsp;<a href="#definition-of-http-header-common-structure">Definition of HTTP Header Common Structure</a></li><li><a href="#rfc.section.3">3.</a>&nbsp;&nbsp;&nbsp;<a href="#http1-serialization-of-http-header-common-structure">HTTP/1 Serialization of HTTP Header Common Structure</a></li><li><a href="#rfc.section.4">4.</a>&nbsp;&nbsp;&nbsp;<a href="#when-to-use-common-structure-parser">When to use Common Structure Parser</a></li><li><a href="#rfc.section.5">5.</a>&nbsp;&nbsp;&nbsp;<a href="#desired-normative-effects">Desired Normative Effects</a></li><li><a href="#rfc.section.6">6.</a>&nbsp;&nbsp;&nbsp;<a href="#openoutstanding-issues-to-resolve">Open/Outstanding issues to resolve</a><ul><li><a href="#rfc.section.6.1">6.1.</a>&nbsp;&nbsp;&nbsp;<a href="#singlemultiple-headers">Single/Multiple Headers</a></li></ul></li><li><a href="#rfc.section.7">7.</a>&nbsp;&nbsp;&nbsp;<a href="#future-work">Future Work</a><ul><li><a href="#rfc.section.7.1">7.1.</a>&nbsp;&nbsp;&nbsp;<a href="#redefining-existing-headers-for-better-performance">Redefining existing headers for better performance</a></li><li><a href="#rfc.section.7.2">7.2.</a>&nbsp;&nbsp;&nbsp;<a href="#define-a-validation-dictionary">Define a validation dictionary</a></li></ul></li><li><a href="#rfc.section.8">8.</a>&nbsp;&nbsp;&nbsp;<a href="#iana">IANA Considerations</a></li><li><a href="#rfc.section.9">9.</a>&nbsp;&nbsp;&nbsp;<a href="#security-considerations">Security Considerations</a></li><li><a href="#rfc.section.10">10.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.references">References</a><ul><li><a href="#rfc.section.10.1">10.1.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.references.1">Normative References</a></li><li><a href="#rfc.section.10.2">10.2.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.references.2">Informative References</a></li></ul></li><li><a href="#rfc.section.A">A.</a>&nbsp;&nbsp;&nbsp;<a href="#survey">Do HTTP headers have any common structure ?</a><ul><li><a href="#rfc.section.A.1">A.1.</a>&nbsp;&nbsp;&nbsp;<a href="#survey-of-http-header-structure">Survey of HTTP header structure</a></li><li><a href="#rfc.section.A.2">A.2.</a>&nbsp;&nbsp;&nbsp;<a href="#survey-of-values-in-http-headers">Survey of values in HTTP headers</a><ul><li><a href="#rfc.section.A.2.1">A.2.1.</a>&nbsp;&nbsp;&nbsp;<a href="#numbers">Numbers</a></li><li><a href="#rfc.section.A.2.2">A.2.2.</a>&nbsp;&nbsp;&nbsp;<a href="#timestamps">Timestamps</a></li><li><a href="#rfc.section.A.2.3">A.2.3.</a>&nbsp;&nbsp;&nbsp;<a href="#strings">Strings</a></li><li><a href="#rfc.section.A.2.4">A.2.4.</a>&nbsp;&nbsp;&nbsp;<a href="#binary-blobs">Binary blobs</a></li><li><a href="#rfc.section.A.2.5">A.2.5.</a>&nbsp;&nbsp;&nbsp;<a href="#identifiers">Identifiers</a></li></ul></li><li><a href="#rfc.section.A.3">A.3.</a>&nbsp;&nbsp;&nbsp;<a href="#is-this-actually-a-useful-thing-to-generalize-">Is this actually a useful thing to generalize ?</a></li><li><a href="#rfc.section.A.4">A.4.</a>&nbsp;&nbsp;&nbsp;<a href="#common">RFC723x headers with “common structure”</a></li><li><a href="#rfc.section.A.5">A.5.</a>&nbsp;&nbsp;&nbsp;<a href="#uncommon">RFC723x headers with “uncommon structure”</a></li></ul></li><li><a href="#rfc.section.B">B.</a>&nbsp;&nbsp;&nbsp;<a href="#changes">Changes</a><ul><li><a href="#rfc.section.B.1">B.1.</a>&nbsp;&nbsp;&nbsp;<a href="#since-draft-ietf-httpbis-header-structure-01">Since draft-ietf-httpbis-header-structure-01</a></li><li><a href="#rfc.section.B.2">B.2.</a>&nbsp;&nbsp;&nbsp;<a href="#since-draft-ietf-httpbis-header-structure-00">Since draft-ietf-httpbis-header-structure-00</a></li></ul></li><li><a href="#rfc.authors">Author's Address</a></li></ul></div></div></div></div><div class="col-md-8 main" role="main"><header><table class="table table-condensed header" id="rfc.headerblock"><tbody><tr><td class="text-left">HTTP Working Group</td><td class="text-right">P-H. Kamp</td></tr><tr><td class="text-left">Internet-Draft</td><td class="text-right">The Varnish Cache Project</td></tr><tr><td class="text-left">Intended status: Standards Track</td><td class="text-right">October 23, 2017</td></tr><tr><td class="text-left">Expires: April 26, 2018</td><td class="text-right"></td></tr></tbody></table><div id="rfc.title"><h1>HTTP Header Common Structure</h1><div class="filename">draft-ietf-httpbis-header-structure-latest</div></div></header><hr><h2 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h2><div class="lead"><div id="rfc.abstract.p.1"><p>An abstract data model for HTTP headers, “Common Structure”, and a HTTP/1 serialization of it, generalized from current HTTP headers.</p></div></div><section id="rfc.note.1" class="note"><h2><a href="#rfc.note.1">Note to Readers</a></h2><div id="rfc.note.1.p.1"><p>Discussion of this draft takes place on the HTTP working group mailing list (ietf-http-wg@w3.org), which is archived at <a href="https://lists.w3.org/Archives/Public/ietf-http-wg/">https://lists.w3.org/Archives/Public/ietf-http-wg/</a>.</p></div><div id="rfc.note.1.p.2"><p>Working Group information can be found at <a href="http://httpwg.github.io/">http://httpwg.github.io/</a>; source code and issues list for this draft can be found at <a href="https://github.com/httpwg/http-extensions/labels/header-structure">https://github.com/httpwg/http-extensions/labels/header-structure</a>.</p></div></section><section id="rfc.status"><h2><a href="#rfc.status">Status of this Memo</a></h2><div id="rfc.boilerplate.1.p.1"><p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p></div><div id="rfc.boilerplate.1.p.2"><p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF). Note that other groups may also distribute working documents as Internet-Drafts. The list of current Internet-Drafts is at <a href="http://datatracker.ietf.org/drafts/current/">http://datatracker.ietf.org/drafts/current/</a>.</p></div><div id="rfc.boilerplate.1.p.3"><p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time. It is inappropriate to use Internet-Drafts as reference material or to cite them other than as “work in progress”.</p></div><div id="rfc.boilerplate.1.p.4"><p>This Internet-Draft will expire on April 26, 2018.</p></div></section><section id="rfc.copyrightnotice"><h2><a href="#rfc.copyrightnotice">Copyright Notice</a></h2><div id="rfc.boilerplate.2.p.1"><p>Copyright © 2017 IETF Trust and the persons identified as the document authors. All rights reserved.</p></div><div id="rfc.boilerplate.2.p.2"><p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (<a href="http://trustee.ietf.org/license-info">http://trustee.ietf.org/license-info</a>) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p></div></section><hr class="hidden-print"><section id="introduction"><h2 id="rfc.section.1" class="np"><a href="#rfc.section.1">1.</a>&nbsp;<a href="#introduction">Introduction</a></h2><div id="rfc.section.1.p.1"><p>The HTTP protocol does not impose any structure or datamodel on the information in HTTP headers, the HTTP/1 serialization is the datamodel: An ASCII string without control characters.</p></div><div id="rfc.section.1.p.2"><p>HTTP header definitions specify how the string must be formatted and while families of similar headers exist, it still requires an uncomfortable large number of bespoke parser and validation routines to process HTTP traffic correctly.</p></div><div id="rfc.section.1.p.3"><p>In order to improve performance HTTP/2 and HPACK uses naive text-compression, which incidentally decoupled the on-the-wire serialization from the data model.</p></div><div id="rfc.section.1.p.4"><p>During the development of HPACK it became evident that significantly bigger gains were available if semantic compression could be used, most notably with timestamps. However, the lack of a common data structure for HTTP headers would make semantic compression one long list of special cases.</p></div><div id="rfc.section.1.p.5"><p>Parallel to this, various proposals for how to fulfill data-transportation needs, and to a lesser degree to impose some kind of order on HTTP headers, at least going forward, were floated.</p></div><div id="rfc.section.1.p.6"><p>All of these proposals, JSON, CBOR etc. run into the same basic problem: Their serialization is incompatible with RFC 7230’s <a href="#RFC7230"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing">[RFC7230]</cite></a> ABNF definition of ‘field-value’.</p></div><div id="rfc.section.1.p.7"><p>For binary formats, such as CBOR, a wholesale base64/85 reserialization would be needed, with negative results for both debugability and bandwidth.</p></div><div id="rfc.section.1.p.8"><p>For textual formats, such as JSON, the format must first be neutered to not violate field-value’s ABNF, and then workarounds added to reintroduce the features just lost, for instance UNICODE strings.</p></div><div id="rfc.section.1.p.9"><p>The post-surgery format is no longer JSON, and it experience indicates that almost-but-not-quite compatibility is worse than no compatibility.</p></div><div id="rfc.section.1.p.10"><p>This proposal starts from the other end, and builds and generalizes a data structure definition from existing HTTP headers, which means that HTTP/1 serialization and ‘field-value’ compatibility is built in.</p></div><div id="rfc.section.1.p.11"><p>If all future HTTP headers are defined to fit into this Common Structure we have at least halted the proliferation of bespoke parsers and started to pave the road for semantic compression serializations of HTTP traffic.</p></div><section id="terminology"><h3 id="rfc.section.1.1"><a href="#rfc.section.1.1">1.1.</a>&nbsp;<a href="#terminology">Terminology</a></h3><div id="rfc.section.1.1.p.1"><p>In this document, the key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” are to be interpreted as described in BCP 14, RFC 2119 <a href="#RFC2119"><cite title="Key words for use in RFCs to Indicate Requirement Levels">[RFC2119]</cite></a>.</p></div></section></section><hr class="hidden-print"><section id="definition-of-http-header-common-structure"><h2 id="rfc.section.2" class="np"><a href="#rfc.section.2">2.</a>&nbsp;<a href="#definition-of-http-header-common-structure">Definition of HTTP Header Common Structure</a></h2><div id="rfc.section.2.p.1"><p>The data model of Common Structure is an ordered sequence of named dictionaries. Please see <a href="#survey" title="Do HTTP headers have any common structure ?">Appendix&nbsp;A</a> for how this model was derived.</p></div><div id="rfc.section.2.p.2"><p>The definition of the data model is on purpose abstract, uncoupled from any protocol serialization or programming environment representation, it is meant as the foundation on which all such manifestations of the model can be built.</p></div><div id="rfc.section.2.p.3" class="avoidbreakafter"><p>Common Structure in ABNF (Slightly bastardized relative to RFC5234 <a href="#RFC5234"><cite title="Augmented BNF for Syntax Specifications: ABNF">[RFC5234]</cite></a>):</p></div><div id="rfc.figure.u.1"><pre class="inline">
  import token from RFC7230
  import DIGIT from RFC5234

  common-structure = 1* ( identifier dictionary )

  dictionary = * ( identifier [ value ] )

  value = identifier /
          integer /
          number /
          ascii-string /
          unicode-string /
          blob /
          timestamp /
          common-structure
</pre></div><div id="rfc.section.2.p.4"><p>Recursion is included as a way to to support deep and more general data structures, but its use is highly discouraged and where it is used the depth of recursion SHALL always be explicitly limited in the specifications of the HTTP headers which allow it.</p></div><div id="rfc.figure.u.2"><pre class="inline">
  identifier = token  [ "/" token ]

  integer = ["-"] 1*19 DIGIT
</pre></div><div id="rfc.section.2.p.5"><p>Integers SHALL be in the range +/- 2^63-1 (= +/- 9223372036854775807)</p></div><div id="rfc.figure.u.3"><pre class="inline">
  number = ["-"] DIGIT '.' 1*14DIGIT /
           ["-"] 2DIGIT '.' 1*13DIGIT /
           ["-"] 3DIGIT '.' 1*12DIGIT /
           ... /
           ["-"] 12DIGIT '.' 1*3DIGIT /
           ["-"] 13DIGIT '.' 1*2DIGIT /
           ["-"] 14DIGIT '.' 1DIGIT
</pre></div><div id="rfc.section.2.p.6"><p>The limit of 15 significant digits is chosen so that numbers can be correctly represented by IEEE754 64 bit binary floating point.</p></div><div id="rfc.figure.u.4"><pre class="inline">
  ascii-string = * %x20-7e
</pre></div><div id="rfc.section.2.p.7"><p>This is intended to be an efficient, “safe” and uncomplicated string type, for uses where the string content is culturally neutral or where it will not be user visible.</p></div><div id="rfc.figure.u.5"><pre class="inline">
  unicode-string = * UNICODE

  UNICODE = &lt;U+0000-U+D7FF / U+E000-U+10FFFF&gt;
  # UNICODE nicked from draft-seantek-unicode-in-abnf-02
</pre></div><div id="rfc.section.2.p.8"><p>Unicode-strings are unrestricted because there is no sane and/or culturally neutral way to subset or otherwise make unicode “safe”, and Unicode is still evolving new and interesting code points.</p></div><div id="rfc.section.2.p.9"><p>Users of unicode-string SHALL be prepared for the full gammut of glyph-gymnastics in order to avoid U+1F4A9 U+08 U+1F574.</p></div><div id="rfc.figure.u.6"><pre class="inline">
  blob = * %0x00-ff
</pre></div><div id="rfc.section.2.p.10"><p>Blobs are intended primarily for cryptographic data, but can be used for any otherwise unsatisfied needs.</p></div><div id="rfc.figure.u.7"><pre class="inline">
  timestamp = number
</pre></div><div id="rfc.section.2.p.11"><p>A timestamp counts seconds since the UNIX time_t epoch, including the “invisible leap-seconds” misfeature.</p></div></section><hr class="hidden-print"><section id="http1-serialization-of-http-header-common-structure"><h2 id="rfc.section.3" class="np"><a href="#rfc.section.3">3.</a>&nbsp;<a href="#http1-serialization-of-http-header-common-structure">HTTP/1 Serialization of HTTP Header Common Structure</a></h2><div id="rfc.section.3.p.1" class="avoidbreakafter"><p>In ABNF:</p></div><div id="rfc.figure.u.8"><pre class="inline">
  import OWS from RFC7230
  import HEXDIG, DQUOTE from RFC5234
  import EmbeddedUnicodeChar from RFC5137

  h1-common-structure-header =
          h1-common-structure-legacy-header /
          h1-common-structure-self-identifying-header

  h1-common-structure-legacy-header =
          field-name ":" OWS h1-common-structure
</pre></div><div id="rfc.section.3.p.2"><p>Only white-listed legacy headers (see <a href="#iana" title="IANA Considerations">Section&nbsp;8</a>) can use this format.</p></div><div id="rfc.figure.u.9"><pre class="inline">
  h1-common-structure-self-identifying-header:
          field-name ":" OWS "&gt;" h1-common-structure "&lt;"

  h1-common-structure = h1-element * ("," h1-element)

  h1-element = identifier * (";" identifier ["=" h1-value])

  h1-value = identifier /
          integer /
          number /
          h1-ascii-string /
          h1-unicode-string /
          h1-blob /
          h1-timestamp /
          "&gt;" h1-common-structure "&lt;"

  h1-ascii-string = DQUOTE *(
                    ( "\" DQUOTE ) /
                    ( "\" "\" ) /
                    0x20-21 /
                    0x23-5B /
                    0x5D-7E
                    ) DQUOTE

  h1-unicode-string = DQUOTE *(
                      ( "\" DQUOTE )
                      ( "\" "\" ) /
                      EmbeddedUnicodeChar /
                      0x20-21 /
                      0x23-5B /
                      0x5D-7E /
                      ) DQUOTE
</pre></div><div id="rfc.section.3.p.3"><p>The dim prospects of ever getting a majority of HTTP1 paths 8-bit clean makes UTF-8 unviable as H1 serialization. Given that very little of the information in HTTP headers is presented to users in the first place, improving H1 and HPACK efficiency by inventing a more efficient RFC5137 compliant escape-sequences seems unwarranted.</p></div><div id="rfc.figure.u.10"><pre class="inline">
  h1-blob = ":" base64 ":"
  # XXX: where to import base64 from ?

  h1-timestamp = number
</pre></div><div id="rfc.section.3.p.4"><p>XXX: Allow OWS in parsers, but not in generators ?</p></div><div id="rfc.section.3.p.5"><p>In programming environments which do not define a native representation or serialization of Common Structure, the HTTP/1 serialization should be used.</p></div></section><hr class="hidden-print"><section id="when-to-use-common-structure-parser"><h2 id="rfc.section.4" class="np"><a href="#rfc.section.4">4.</a>&nbsp;<a href="#when-to-use-common-structure-parser">When to use Common Structure Parser</a></h2><div id="rfc.section.4.p.1"><p>All future standardized and all private HTTP headers using Common Structure should self identify as such. In the HTTP/1 serialization by making the first character “&gt;” and the last “&lt;”. (These two characters are deliberately “the wrong way” to not clash with exsisting usages.)</p></div><div id="rfc.section.4.p.2"><p>Legacy HTTP headers which fit into Common Structure, are marked as such in the IANA Message Header Registry (see <a href="#iana" title="IANA Considerations">Section&nbsp;8</a>), and a snapshot of the registry can be used to trigger parsing according to Common Structure of these headers.</p></div></section><hr class="hidden-print"><section id="desired-normative-effects"><h2 id="rfc.section.5" class="np"><a href="#rfc.section.5">5.</a>&nbsp;<a href="#desired-normative-effects">Desired Normative Effects</a></h2><div id="rfc.section.5.p.1"><p>All new HTTP headers SHOULD use the Common Structure if at all possible.</p></div></section><hr class="hidden-print"><section id="openoutstanding-issues-to-resolve"><h2 id="rfc.section.6" class="np"><a href="#rfc.section.6">6.</a>&nbsp;<a href="#openoutstanding-issues-to-resolve">Open/Outstanding issues to resolve</a></h2><section id="singlemultiple-headers"><h3 id="rfc.section.6.1"><a href="#rfc.section.6.1">6.1.</a>&nbsp;<a href="#singlemultiple-headers">Single/Multiple Headers</a></h3><div id="rfc.section.6.1.p.1"><p>Should we allow splitting common structure data over multiple headers ?</p></div><div id="rfc.section.6.1.p.2" class="avoidbreakafter"><p>Pro:</p></div><div id="rfc.section.6.1.p.3"><p>Avoids size restrictions, easier on-the-fly editing</p></div><div id="rfc.section.6.1.p.4" class="avoidbreakafter"><p>Contra:</p></div><div id="rfc.section.6.1.p.5"><p>Cannot act on any such header until all headers have been received.</p></div><div id="rfc.section.6.1.p.6"><p>We must define where headers can be split (between identifier and dictionary ?, in the middle of dictionaries ?)</p></div><div id="rfc.section.6.1.p.7"><p>Most on-the-fly editing is hackish at best.</p></div></section></section><hr class="hidden-print"><section id="future-work"><h2 id="rfc.section.7" class="np"><a href="#rfc.section.7">7.</a>&nbsp;<a href="#future-work">Future Work</a></h2><section id="redefining-existing-headers-for-better-performance"><h3 id="rfc.section.7.1"><a href="#rfc.section.7.1">7.1.</a>&nbsp;<a href="#redefining-existing-headers-for-better-performance">Redefining existing headers for better performance</a></h3><div id="rfc.section.7.1.p.1"><p>The HTTP/1 serializations self-identification mechanism makes it possible to extend the definition of existing <a href="#uncommon" title="RFC723x headers with “uncommon structure”">Appendix&nbsp;A.5</a> headers into Common Structure.</p></div><div id="rfc.section.7.1.p.2" class="avoidbreakafter"><p>For instance one could imagine:</p></div><div id="rfc.figure.u.11"><pre>
  Date: &gt;1475061449.201&lt;
</pre></div><div id="rfc.section.7.1.p.3"><p>Which would be faster to parse and validate than the current definition of the Date header and more precise too.</p></div><div id="rfc.section.7.1.p.4"><p>Some kind of signal/negotiation mechanism would be required to make this work in practice.</p></div></section><section id="define-a-validation-dictionary"><h3 id="rfc.section.7.2"><a href="#rfc.section.7.2">7.2.</a>&nbsp;<a href="#define-a-validation-dictionary">Define a validation dictionary</a></h3><div id="rfc.section.7.2.p.1"><p>A machine-readable specification of the legal contents of HTTP headers would go a long way to improve efficiency and security in HTTP implementations.</p></div></section></section><hr class="hidden-print"><section id="iana"><h2 id="rfc.section.8" class="np"><a href="#rfc.section.8">8.</a>&nbsp;<a href="#iana">IANA Considerations</a></h2><div id="rfc.section.8.p.1"><p>The IANA Message Header Registry will be extended with an additional field named “Common Structure” which can have the values “True”, “False” or “Unknown”.</p></div><div id="rfc.section.8.p.2"><p>The RFC723x headers listed in <a href="#common" title="RFC723x headers with “common structure”">Appendix&nbsp;A.4</a> will get the value “True” in the new field.</p></div><div id="rfc.section.8.p.3"><p>The RFC723x headers listed in <a href="#uncommon" title="RFC723x headers with “uncommon structure”">Appendix&nbsp;A.5</a> will get the value “False” in the new field.</p></div><div id="rfc.section.8.p.4"><p>All other existing entries in the registry will be set to “Unknown” until and if the owner of the entry requests otherwise.</p></div></section><hr class="hidden-print"><section id="security-considerations"><h2 id="rfc.section.9" class="np"><a href="#rfc.section.9">9.</a>&nbsp;<a href="#security-considerations">Security Considerations</a></h2><div id="rfc.section.9.p.1"><p>Unique dictionary keys are required to reduce the risk of smuggling attacks.</p></div></section><hr class="hidden-print"><section id="rfc.references" class="np"><h2 id="rfc.section.10"><a href="#rfc.section.10">10.</a> References</h2><section id="rfc.references.1" class="np"><h3 id="rfc.section.10.1"><a href="#rfc.section.10.1">10.1.</a> Normative References</h3><dl class="dl-horizontal"><dt id="RFC2119">[RFC2119]</dt><dd>Bradner, S., “<a href="https://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>”, BCP&nbsp;14, RFC&nbsp;2119, <a href="http://dx.doi.org/10.17487/RFC2119">DOI&nbsp;10.17487/RFC2119</a>, March&nbsp;1997, &lt;<a href="https://www.rfc-editor.org/info/rfc2119">https://www.rfc-editor.org/info/rfc2119</a>&gt;.</dd><dt id="RFC5137">[RFC5137]</dt><dd>Klensin, J., “<a href="https://tools.ietf.org/html/rfc5137">ASCII Escaping of Unicode Characters</a>”, BCP&nbsp;137, RFC&nbsp;5137, <a href="http://dx.doi.org/10.17487/RFC5137">DOI&nbsp;10.17487/RFC5137</a>, February&nbsp;2008, &lt;<a href="https://www.rfc-editor.org/info/rfc5137">https://www.rfc-editor.org/info/rfc5137</a>&gt;.</dd><dt id="RFC5234">[RFC5234]</dt><dd>Crocker, D., Ed. and P. Overell, “<a href="https://tools.ietf.org/html/rfc5234">Augmented BNF for Syntax Specifications: ABNF</a>”, STD&nbsp;68, RFC&nbsp;5234, <a href="http://dx.doi.org/10.17487/RFC5234">DOI&nbsp;10.17487/RFC5234</a>, January&nbsp;2008, &lt;<a href="https://www.rfc-editor.org/info/rfc5234">https://www.rfc-editor.org/info/rfc5234</a>&gt;.</dd><dt id="RFC7230">[RFC7230]</dt><dd>Fielding, R., Ed. and J. Reschke, Ed., “<a href="https://tools.ietf.org/html/rfc7230">Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</a>”, RFC&nbsp;7230, <a href="http://dx.doi.org/10.17487/RFC7230">DOI&nbsp;10.17487/RFC7230</a>, June&nbsp;2014, &lt;<a href="https://www.rfc-editor.org/info/rfc7230">https://www.rfc-editor.org/info/rfc7230</a>&gt;.</dd></dl></section><section id="rfc.references.2"><h3 id="rfc.section.10.2"><a href="#rfc.section.10.2">10.2.</a> Informative References</h3><dl class="dl-horizontal"><dt id="RFC7231">[RFC7231]</dt><dd>Fielding, R., Ed. and J. Reschke, Ed., “<a href="https://tools.ietf.org/html/rfc7231">Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content</a>”, RFC&nbsp;7231, <a href="http://dx.doi.org/10.17487/RFC7231">DOI&nbsp;10.17487/RFC7231</a>, June&nbsp;2014, &lt;<a href="https://www.rfc-editor.org/info/rfc7231">https://www.rfc-editor.org/info/rfc7231</a>&gt;.</dd><dt id="RFC7232">[RFC7232]</dt><dd>Fielding, R., Ed. and J. Reschke, Ed., “<a href="https://tools.ietf.org/html/rfc7232">Hypertext Transfer Protocol (HTTP/1.1): Conditional Requests</a>”, RFC&nbsp;7232, <a href="http://dx.doi.org/10.17487/RFC7232">DOI&nbsp;10.17487/RFC7232</a>, June&nbsp;2014, &lt;<a href="https://www.rfc-editor.org/info/rfc7232">https://www.rfc-editor.org/info/rfc7232</a>&gt;.</dd><dt id="RFC7233">[RFC7233]</dt><dd>Fielding, R., Ed., Lafon, Y., Ed., and J. Reschke, Ed., “<a href="https://tools.ietf.org/html/rfc7233">Hypertext Transfer Protocol (HTTP/1.1): Range Requests</a>”, RFC&nbsp;7233, <a href="http://dx.doi.org/10.17487/RFC7233">DOI&nbsp;10.17487/RFC7233</a>, June&nbsp;2014, &lt;<a href="https://www.rfc-editor.org/info/rfc7233">https://www.rfc-editor.org/info/rfc7233</a>&gt;.</dd><dt id="RFC7234">[RFC7234]</dt><dd>Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke, Ed., “<a href="https://tools.ietf.org/html/rfc7234">Hypertext Transfer Protocol (HTTP/1.1): Caching</a>”, RFC&nbsp;7234, <a href="http://dx.doi.org/10.17487/RFC7234">DOI&nbsp;10.17487/RFC7234</a>, June&nbsp;2014, &lt;<a href="https://www.rfc-editor.org/info/rfc7234">https://www.rfc-editor.org/info/rfc7234</a>&gt;.</dd><dt id="RFC7235">[RFC7235]</dt><dd>Fielding, R., Ed. and J. Reschke, Ed., “<a href="https://tools.ietf.org/html/rfc7235">Hypertext Transfer Protocol (HTTP/1.1): Authentication</a>”, RFC&nbsp;7235, <a href="http://dx.doi.org/10.17487/RFC7235">DOI&nbsp;10.17487/RFC7235</a>, June&nbsp;2014, &lt;<a href="https://www.rfc-editor.org/info/rfc7235">https://www.rfc-editor.org/info/rfc7235</a>&gt;.</dd><dt id="RFC7239">[RFC7239]</dt><dd>Petersson, A. and M. Nilsson, “<a href="https://tools.ietf.org/html/rfc7239">Forwarded HTTP Extension</a>”, RFC&nbsp;7239, <a href="http://dx.doi.org/10.17487/RFC7239">DOI&nbsp;10.17487/RFC7239</a>, June&nbsp;2014, &lt;<a href="https://www.rfc-editor.org/info/rfc7239">https://www.rfc-editor.org/info/rfc7239</a>&gt;.</dd><dt id="RFC7694">[RFC7694]</dt><dd>Reschke, J., “<a href="https://tools.ietf.org/html/rfc7694">Hypertext Transfer Protocol (HTTP) Client-Initiated Content-Encoding</a>”, RFC&nbsp;7694, <a href="http://dx.doi.org/10.17487/RFC7694">DOI&nbsp;10.17487/RFC7694</a>, November&nbsp;2015, &lt;<a href="https://www.rfc-editor.org/info/rfc7694">https://www.rfc-editor.org/info/rfc7694</a>&gt;.</dd></dl></section></section><hr class="hidden-print"><section id="survey"><h2 id="rfc.section.A" class="np"><a href="#rfc.section.A">A.</a>&nbsp;<a href="#survey">Do HTTP headers have any common structure ?</a></h2><div id="rfc.section.A.p.1"><p>Several proposals have been floated in recent years to use some preexisting structured data serialization or other for HTTP headers, to impose some sanity.</p></div><div id="rfc.section.A.p.2"><p>None of these proposals have gained traction and no obvious candidate data serializations have been left unexamined.</p></div><div id="rfc.section.A.p.3"><p>This effort tries to tackle the question from the other side, by asking if there is a common structure in existing HTTP headers we can generalize for this purpose.</p></div><section id="survey-of-http-header-structure"><h3 id="rfc.section.A.1"><a href="#rfc.section.A.1">A.1.</a>&nbsp;<a href="#survey-of-http-header-structure">Survey of HTTP header structure</a></h3><div id="rfc.section.A.1.p.1"><p>The RFC723x family of HTTP/1 standards control 49 entries in the IANA Message Header Registry, and they share two common motifs.</p></div><div id="rfc.section.A.1.p.2"><p>The majority of RFC723x HTTP headers are lists. A few of them are ordered, (‘Content-Encoding’), some are unordered (‘Connection’) and some are ordered by ‘q=%f’ weight parameters (‘Accept’)</p></div><div id="rfc.section.A.1.p.3"><p>In most cases, the list elements are some kind of identifier, usually derived from ABNF ‘token’ as defined by <a href="#RFC7230"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing">[RFC7230]</cite></a>.</p></div><div id="rfc.section.A.1.p.4" class="avoidbreakafter"><p>A subgroup of headers, mostly related to MIME, uses what one could call a ‘qualified token’::</p></div><div id="rfc.figure.u.12"><pre class="inline">
  qualified-token = token-or-asterix [ "/" token-or-asterix ]
</pre></div><div id="rfc.section.A.1.p.5"><p>The second motif is parameterized list elements. The best known is the “q=0.5” weight parameter, but other parameters exist as well.</p></div><div id="rfc.section.A.1.p.6"><p>Generalizing from these motifs, our candidate “Common Structure” data model becomes an ordered list of named dictionaries.</p></div><div id="rfc.section.A.1.p.7" class="avoidbreakafter"><p>In pidgin ABNF, ignoring white-space for the sake of clarity, the HTTP/1.1 serialization of Common Structure is is something like:</p></div><div id="rfc.figure.u.13"><pre class="inline">
  token-or-asterix = token from RFC7230, but also allowing "*"

  qualified-token = token-or-asterix [ "/" token-or-asterix ]

  field-name, see RFC7230

  Common-Structure-Header = field-name ":" 1#named-dictionary

  named-dictionary = qualified-token [ *(";" param) ]

  param = token [ "=" value ]

  value = we'll get back to this in a moment.
</pre></div><div id="rfc.section.A.1.p.8"><p>Nineteen out of the RFC723x’s 48 headers, almost 40%, can already be parsed using this definition, and none the rest have requirements which could not be met by this data model. See <a href="#common" title="RFC723x headers with “common structure”">Appendix&nbsp;A.4</a> and <a href="#uncommon" title="RFC723x headers with “uncommon structure”">Appendix&nbsp;A.5</a> for the full survey details.</p></div></section><section id="survey-of-values-in-http-headers"><h3 id="rfc.section.A.2"><a href="#rfc.section.A.2">A.2.</a>&nbsp;<a href="#survey-of-values-in-http-headers">Survey of values in HTTP headers</a></h3><div id="rfc.section.A.2.p.1" class="avoidbreakafter"><p>Surveying the datatypes of HTTP headers, standardized as well as private, the following picture emerges:</p></div><section id="numbers"><h4 id="rfc.section.A.2.1"><a href="#rfc.section.A.2.1">A.2.1.</a>&nbsp;<a href="#numbers">Numbers</a></h4><div id="rfc.section.A.2.1.p.1"><p>Integer and floating point are both used. Range and precision is mostly unspecified in controlling documents.</p></div><div id="rfc.section.A.2.1.p.2"><p>Scientific notation (9.192631770e9) does not seem to be used anywhere.</p></div><div id="rfc.section.A.2.1.p.3"><p>The ranges used seem to be minus several thousand to plus a couple of billions, the high end almost exclusively being POSIX time_t timestamps.</p></div></section><section id="timestamps"><h4 id="rfc.section.A.2.2"><a href="#rfc.section.A.2.2">A.2.2.</a>&nbsp;<a href="#timestamps">Timestamps</a></h4><div id="rfc.section.A.2.2.p.1"><p>RFC723x text format, but POSIX time_t represented as integer or floating point is not uncommon. ISO8601 have also been spotted.</p></div></section><section id="strings"><h4 id="rfc.section.A.2.3"><a href="#rfc.section.A.2.3">A.2.3.</a>&nbsp;<a href="#strings">Strings</a></h4><div id="rfc.section.A.2.3.p.1"><p>The vast majority are pure ASCII strings, with either no escapes, %xx URL-like escapes or C-style back-slash escapes, possibly with the addition of \uxxxx UNICODE escapes.</p></div><div id="rfc.section.A.2.3.p.2"><p>Where non-ASCII character sets are used, they are almost always implicit, rather than explicit. UTF8 and ISO-8859-1 seem to be most common.</p></div></section><section id="binary-blobs"><h4 id="rfc.section.A.2.4"><a href="#rfc.section.A.2.4">A.2.4.</a>&nbsp;<a href="#binary-blobs">Binary blobs</a></h4><div id="rfc.section.A.2.4.p.1"><p>Often used for cryptographic data. Usually in base64 encoding, sometimes ““-quoted more often not. base85 encoding is also seen, usually quoted.</p></div></section><section id="identifiers"><h4 id="rfc.section.A.2.5"><a href="#rfc.section.A.2.5">A.2.5.</a>&nbsp;<a href="#identifiers">Identifiers</a></h4><div id="rfc.section.A.2.5.p.1"><p>Seems to almost always fit in the RFC723x ‘token’ definition.</p></div></section></section><section id="is-this-actually-a-useful-thing-to-generalize-"><h3 id="rfc.section.A.3"><a href="#rfc.section.A.3">A.3.</a>&nbsp;<a href="#is-this-actually-a-useful-thing-to-generalize-">Is this actually a useful thing to generalize ?</a></h3><div id="rfc.section.A.3.p.1"><p>The number one wishlist item seems to be UNICODE strings, with a big side order of not having to write a new parser routine every time somebody comes up with a new header.</p></div><div id="rfc.section.A.3.p.2"><p>Having a common parser would indeed be a good thing, and having an underlying data model which makes it possible define a compressed serialization, rather than rely on serialization to text followed by text compression (ie: HPACK) seems like a good idea too.</p></div><div id="rfc.section.A.3.p.3"><p>However, when using a datamodel and a parser general enough to transport useful data, it will have to be followed by a validation step, which checks that the data also makes sense.</p></div><div id="rfc.section.A.3.p.4"><p>Today validation, such as it is, is often done by the bespoke parsers.</p></div><div id="rfc.section.A.3.p.5" class="avoidbreakafter"><p>This then is probably where the next big potential for improvement lies:</p></div><div id="rfc.section.A.3.p.6"><p>Ideally a machine readable “data dictionary” which makes it possibly to copy that text out of RFCs, run it through a code generator which spits out validation code which operates on the output of the common parser.</p></div><div id="rfc.section.A.3.p.7"><p>But history has been particularly unkind to that idea.</p></div><div id="rfc.section.A.3.p.8"><p>Most attempts studied as part of this effort, have sunk under complexity caused by reaching for generality, but where scope has been wisely limited, it seems to be possible.</p></div><div id="rfc.section.A.3.p.9"><p>So file that idea under “future work”.</p></div></section><section id="common"><h3 id="rfc.section.A.4"><a href="#rfc.section.A.4">A.4.</a>&nbsp;<a href="#common">RFC723x headers with “common structure”</a></h3><div id="rfc.section.A.4.p.1"><ul><li>Accept <a href="#RFC7231"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content">[RFC7231]</cite></a>, Section 5.3.2</li><li>Accept-Charset <a href="#RFC7231"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content">[RFC7231]</cite></a>, Section 5.3.3</li><li>Accept-Encoding <a href="#RFC7231"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content">[RFC7231]</cite></a>, Section 5.3.4, <a href="#RFC7694"><cite title="Hypertext Transfer Protocol (HTTP) Client-Initiated Content-Encoding">[RFC7694]</cite></a>, Section 3</li><li>Accept-Language <a href="#RFC7231"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content">[RFC7231]</cite></a>, Section 5.3.5</li><li>Age <a href="#RFC7234"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Caching">[RFC7234]</cite></a>, Section 5.1</li><li>Allow <a href="#RFC7231"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content">[RFC7231]</cite></a>, Section 7.4.1</li><li>Connection <a href="#RFC7230"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing">[RFC7230]</cite></a>, Section 6.1</li><li>Content-Encoding <a href="#RFC7231"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content">[RFC7231]</cite></a>, Section 3.1.2.2</li><li>Content-Language <a href="#RFC7231"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content">[RFC7231]</cite></a>, Section 3.1.3.2</li><li>Content-Length <a href="#RFC7230"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing">[RFC7230]</cite></a>, Section 3.3.2</li><li>Content-Type <a href="#RFC7231"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content">[RFC7231]</cite></a>, Section 3.1.1.5</li><li>Expect <a href="#RFC7231"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content">[RFC7231]</cite></a>, Section 5.1.1</li><li>Max-Forwards <a href="#RFC7231"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content">[RFC7231]</cite></a>, Section 5.1.2</li><li>MIME-Version <a href="#RFC7231"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content">[RFC7231]</cite></a>, Appendix A.1</li><li>TE <a href="#RFC7230"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing">[RFC7230]</cite></a>, Section 4.3</li><li>Trailer <a href="#RFC7230"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing">[RFC7230]</cite></a>, Section 4.4</li><li>Transfer-Encoding <a href="#RFC7230"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing">[RFC7230]</cite></a>, Section 3.3.1</li><li>Upgrade <a href="#RFC7230"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing">[RFC7230]</cite></a>, Section 6.7</li><li>Vary <a href="#RFC7231"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content">[RFC7231]</cite></a>, Section 7.1.4</li></ul></div></section><section id="uncommon"><h3 id="rfc.section.A.5"><a href="#rfc.section.A.5">A.5.</a>&nbsp;<a href="#uncommon">RFC723x headers with “uncommon structure”</a></h3><div id="rfc.section.A.5.p.1" class="avoidbreakafter"><p>1 of the RFC723x headers is only reserved, and therefore have no structure at all:</p></div><div id="rfc.section.A.5.p.2"><ul><li>Close <a href="#RFC7230"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing">[RFC7230]</cite></a>, Section 8.1</li></ul></div><div id="rfc.section.A.5.p.3" class="avoidbreakafter"><p>5 of the RFC723x headers are HTTP dates:</p></div><div id="rfc.section.A.5.p.4"><ul><li>Date <a href="#RFC7231"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content">[RFC7231]</cite></a>, Section 7.1.1.2</li><li>Expires <a href="#RFC7234"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Caching">[RFC7234]</cite></a>, Section 5.3</li><li>If-Modified-Since <a href="#RFC7232"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Conditional Requests">[RFC7232]</cite></a>, Section 3.3</li><li>If-Unmodified-Since <a href="#RFC7232"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Conditional Requests">[RFC7232]</cite></a>, Section 3.4</li><li>Last-Modified <a href="#RFC7232"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Conditional Requests">[RFC7232]</cite></a>, Section 2.2</li></ul></div><div id="rfc.section.A.5.p.5" class="avoidbreakafter"><p>24 of the RFC723x headers use bespoke formats which only a single or in rare cases two headers share:</p></div><div id="rfc.section.A.5.p.6"><ul><li>Accept-Ranges <a href="#RFC7233"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Range Requests">[RFC7233]</cite></a>, Section 2.3 <ul><li>bytes-unit / other-range-unit</li></ul></li><li>Authorization <a href="#RFC7235"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Authentication">[RFC7235]</cite></a>, Section 4.2</li><li>Proxy-Authorization <a href="#RFC7235"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Authentication">[RFC7235]</cite></a>, Section 4.4 <ul><li>credentials</li></ul></li><li>Cache-Control <a href="#RFC7234"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Caching">[RFC7234]</cite></a>, Section 5.2 <ul><li>1#cache-directive</li></ul></li><li>Content-Location <a href="#RFC7231"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content">[RFC7231]</cite></a>, Section 3.1.4.2 <ul><li>absolute-URI / partial-URI</li></ul></li><li>Content-Range <a href="#RFC7233"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Range Requests">[RFC7233]</cite></a>, Section 4.2 <ul><li>byte-content-range / other-content-range</li></ul></li><li>ETag <a href="#RFC7232"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Conditional Requests">[RFC7232]</cite></a>, Section 2.3 <ul><li>entity-tag</li></ul></li><li>Forwarded <a href="#RFC7239"><cite title="Forwarded HTTP Extension">[RFC7239]</cite></a> <ul><li>1#forwarded-element</li></ul></li><li>From <a href="#RFC7231"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content">[RFC7231]</cite></a>, Section 5.5.1 <ul><li>mailbox</li></ul></li><li>If-Match <a href="#RFC7232"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Conditional Requests">[RFC7232]</cite></a>, Section 3.1</li><li>If-None-Match <a href="#RFC7232"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Conditional Requests">[RFC7232]</cite></a>, Section 3.2 <ul><li>“*” / 1#entity-tag</li></ul></li><li>If-Range <a href="#RFC7233"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Range Requests">[RFC7233]</cite></a>, Section 3.2 <ul><li>entity-tag / HTTP-date</li></ul></li><li>Host <a href="#RFC7230"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing">[RFC7230]</cite></a>, Section 5.4 <ul><li>uri-host [ “:” port ]</li></ul></li><li>Location <a href="#RFC7231"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content">[RFC7231]</cite></a>, Section 7.1.2 <ul><li>URI-reference</li></ul></li><li>Pragma <a href="#RFC7234"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Caching">[RFC7234]</cite></a>, Section 5.4 <ul><li>1#pragma-directive</li></ul></li><li>Range <a href="#RFC7233"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Range Requests">[RFC7233]</cite></a>, Section 3.1 <ul><li>byte-ranges-specifier / other-ranges-specifier</li></ul></li><li>Referer <a href="#RFC7231"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content">[RFC7231]</cite></a>, Section 5.5.2 <ul><li>absolute-URI / partial-URI</li></ul></li><li>Retry-After <a href="#RFC7231"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content">[RFC7231]</cite></a>, Section 7.1.3 <ul><li>HTTP-date / delay-seconds</li></ul></li><li>Server <a href="#RFC7231"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content">[RFC7231]</cite></a>, Section 7.4.2</li><li>User-Agent <a href="#RFC7231"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content">[RFC7231]</cite></a>, Section 5.5.3 <ul><li>product *( RWS ( product / comment ) )</li></ul></li><li>Via <a href="#RFC7230"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing">[RFC7230]</cite></a>, Section 5.7.1 <ul><li>1#( received-protocol RWS received-by [ RWS comment ] )</li></ul></li><li>Warning <a href="#RFC7234"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Caching">[RFC7234]</cite></a>, Section 5.5 <ul><li>1#warning-value</li></ul></li><li>Proxy-Authenticate <a href="#RFC7235"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Authentication">[RFC7235]</cite></a>, Section 4.3</li><li>WWW-Authenticate <a href="#RFC7235"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Authentication">[RFC7235]</cite></a>, Section 4.1 <ul><li>1#challenge</li></ul></li></ul></div></section></section><hr class="hidden-print"><section id="changes"><h2 id="rfc.section.B" class="np"><a href="#rfc.section.B">B.</a>&nbsp;<a href="#changes">Changes</a></h2><section id="since-draft-ietf-httpbis-header-structure-01"><h3 id="rfc.section.B.1"><a href="#rfc.section.B.1">B.1.</a>&nbsp;<a href="#since-draft-ietf-httpbis-header-structure-01">Since draft-ietf-httpbis-header-structure-01</a></h3><div id="rfc.section.B.1.p.1"><p>None yet.</p></div></section><section id="since-draft-ietf-httpbis-header-structure-00"><h3 id="rfc.section.B.2"><a href="#rfc.section.B.2">B.2.</a>&nbsp;<a href="#since-draft-ietf-httpbis-header-structure-00">Since draft-ietf-httpbis-header-structure-00</a></h3><div id="rfc.section.B.2.p.1"><p>Added signed 64bit integer type.</p></div><div id="rfc.section.B.2.p.2"><p>Drop UTF8, and settle on BCP137 <a href="#RFC5137"><cite title="ASCII Escaping of Unicode Characters">[RFC5137]</cite></a>::EmbeddedUnicodeChar for h1-unicode-string.</p></div><div id="rfc.section.B.2.p.3"><p>Change h1_blob delimiter to “:” since “’” is valid t_char</p></div></section></section><hr class="hidden-print"><section id="rfc.authors" class="np"><h2><a href="#rfc.authors">Author's Address</a></h2><address><b>Poul-Henning Kamp</b><br>The Varnish Cache Project<br>EMail: <a href="mailto:phk@varnish-cache.org">phk@varnish-cache.org</a></address></section></div></div></div><script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script><script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.2.0/js/bootstrap.min.js"></script></body></html>