<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Cookies: HTTP State Management Mechanism</title><script type="application/javascript">
function anchorRewrite() {
  map = { };
  if (window.location.hash.length >= 1) {
    var fragid = window.location.hash.substr(1);
    if (fragid) {
      if (! document.getElementById(fragid)) {
        var prefix = "rfc.";
        var mapped = map[fragid];
        if (mapped) {
          window.location.hash = mapped;
        } else if (fragid.indexOf("section-") == 0) {
          window.location.hash = prefix + "section." + fragid.substring(8);
        } else if (fragid.indexOf("appendix-") == 0) {
          window.location.hash = prefix + "section." + fragid.substring(9);
        } else if (fragid.indexOf("s-") == 0) {
          var postfix = fragid.substring(2);
          if (postfix.startsWith("abstract")) {
            window.location.hash = prefix + postfix;
          } else if (postfix.startsWith("note-")) {
            window.location.hash = prefix + "note." + postfix.substring(5);
          } else {
            window.location.hash = prefix + "section." + postfix;
          }
        } else if (fragid.indexOf("p-") == 0) {
          var r = fragid.substring(2);
          var p = r.indexOf("-");
          if (p >= 0) {
            window.location.hash = prefix + "section." + r.substring(0, p) + ".p." + r.substring(p + 1);
          }
        }
      }
    }  
  }
}
window.addEventListener('hashchange', anchorRewrite);
window.addEventListener('DOMContentLoaded', anchorRewrite);
</script><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="stylesheet" type="text/css" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap.min.css"><style type="text/css">
      body {
        padding-top: 80px;
        padding-bottom: 80px;
        position: relative;
      }
      .table.header th, .table.header td {
        border-top: none;
        padding: 0;
      }
      #rfc\.meta {
        width: 40%;
        float: right
      }
      #rfc\.toc > ul ul {
        list-style: none;
      }
      #sidebar {
        position: fixed;
        height: 90%;
        overflow-y: auto;
        font-size: 90%;
      }
      .container .nav-sublist {
        padding-left: 20px;
        padding-right: 10px;
        font-size: 90%;
      }
      .container .navbar-brand {
        padding-top: 0;
      }
      .container .nav > li > a {
        padding: 10px 7px 5px 15px;
        display: inline-block;
      }
      .container .nav > li > a + a {
        padding: 10px 15px 5px 7px;
        display: inline-block;
      }
      .container .nav > li > a {
        padding: 5px 10px;
      }
      .filename {
        color: rgb(119, 119, 119);
        font-size: 23px;
        font-weight: normal;
        height: auto;
        line-height: 23px;
      }
      dl {
        margin-left: 1em;
      }
      dl.dl-horizontal: {
        margin-left: 0;
      }
      dl > dt {
        float: left;
        margin-right: 1em;
      }
      dl.nohang > dt {
        float: none;
      }
      dl > dd {
        margin-bottom: .5em;
      }
      dl.compact > dd {
        margin-bottom: 0em;
      }
      dl > dd > dl {
        margin-top: 0.5em;
        margin-bottom: 0em;
      }
      ul.empty {
        list-style-type: none;
      }
      ul.empty li {
        margin-top: .5em;
      }
      td.reference {
        padding-right: 1em;
        vertical-align: top;
      }
      .feedback {
        position: fixed;
        bottom: 5px;
        right: 5px;
      }
      .fbbutton {
        margin-left: 5px;
      }
      h1 a, h2 a, h3 a, h4 a, h5 a, h6 a {
        color: rgb(51, 51, 51);
      }
      span.tt {
        font: 11pt consolas, monospace;
        font-size-adjust: none;
      }
    </style><link rel="Author" href="#rfc.authors"><link rel="Copyright" href="#rfc.copyrightnotice"><link rel="Chapter" title="1 Introduction" href="#rfc.section.1"><link rel="Chapter" title="2 Conventions" href="#rfc.section.2"><link rel="Chapter" title="3 Overview" href="#rfc.section.3"><link rel="Chapter" title="4 Server Requirements" href="#rfc.section.4"><link rel="Chapter" title="5 User Agent Requirements" href="#rfc.section.5"><link rel="Chapter" title="6 Implementation Considerations" href="#rfc.section.6"><link rel="Chapter" title="7 Privacy Considerations" href="#rfc.section.7"><link rel="Chapter" title="8 Security Considerations" href="#rfc.section.8"><link rel="Chapter" title="9 IANA Considerations" href="#rfc.section.9"><link rel="Chapter" href="#rfc.section.10" title="10 References"><link rel="Appendix" title="A Changes" href="#rfc.section.A"><link rel="Appendix" title="B Acknowledgements" href="#rfc.section.B"><meta name="generator" content="https://github.com/mnot/RFCBootstrap XSLT vendor: SAXON 9.1.0.8 from Saxonica http://www.saxonica.com/"><link rel="schema.dcterms" href="http://purl.org/dc/terms/"><meta name="dcterms.creator" content="Barth, A."><meta name="dcterms.creator" content="West, M."><meta name="dcterms.identifier" content="urn:ietf:id:draft-ietf-httpbis-rfc6265bis-latest"><meta name="dcterms.issued" content="2017-10-23"><meta name="dct.replaces" content="urn:ietf:rfc:6265"><meta name="dcterms.abstract" content="This document defines the HTTP Cookie and Set-Cookie header fields. These header fields can be used by HTTP servers to store state (called cookies) at HTTP user agents, letting the servers maintain a stateful session over the mostly stateless HTTP protocol. Although cookies have many historical infelicities that degrade their security and privacy, the Cookie and Set-Cookie header fields are widely used on the Internet. This document obsoletes RFC 6265."><meta name="description" content="This document defines the HTTP Cookie and Set-Cookie header fields. These header fields can be used by HTTP servers to store state (called cookies) at HTTP user agents, letting the servers maintain a stateful session over the mostly stateless HTTP protocol. Although cookies have many historical infelicities that degrade their security and privacy, the Cookie and Set-Cookie header fields are widely used on the Internet. This document obsoletes RFC 6265."></head><body><div class="container" id="top"><div class="row"><div class="col-md-4 col-md-push-8 hidden-sm hidden-xs" id="sidebar" role="navigation"><div class="navbar"><div class="navbar-brand"><a href="#top">draft-ietf-httpbis-rfc6265bis-latest</a></div><br clear="all"><div class=""><div id="rfc.toc"><ul class="nav"><li><a href="#rfc.section.1">1.</a>&nbsp;&nbsp;&nbsp;<a href="#introduction">Introduction</a></li><li><a href="#rfc.section.2">2.</a>&nbsp;&nbsp;&nbsp;<a href="#conventions">Conventions</a><ul><li><a href="#rfc.section.2.1">2.1.</a>&nbsp;&nbsp;&nbsp;<a href="#conformance-criteria">Conformance Criteria</a></li><li><a href="#rfc.section.2.2">2.2.</a>&nbsp;&nbsp;&nbsp;<a href="#syntax-notation">Syntax Notation</a></li><li><a href="#rfc.section.2.3">2.3.</a>&nbsp;&nbsp;&nbsp;<a href="#terminology">Terminology</a></li></ul></li><li><a href="#rfc.section.3">3.</a>&nbsp;&nbsp;&nbsp;<a href="#overview">Overview</a><ul><li><a href="#rfc.section.3.1">3.1.</a>&nbsp;&nbsp;&nbsp;<a href="#examples">Examples</a></li></ul></li><li><a href="#rfc.section.4">4.</a>&nbsp;&nbsp;&nbsp;<a href="#sane-profile">Server Requirements</a><ul><li><a href="#rfc.section.4.1">4.1.</a>&nbsp;&nbsp;&nbsp;<a href="#sane-set-cookie">Set-Cookie</a><ul><li><a href="#rfc.section.4.1.1">4.1.1.</a>&nbsp;&nbsp;&nbsp;<a href="#syntax">Syntax</a></li><li><a href="#rfc.section.4.1.2">4.1.2.</a>&nbsp;&nbsp;&nbsp;<a href="#sane-set-cookie-semantics">Semantics (Non-Normative)</a></li><li><a href="#rfc.section.4.1.3">4.1.3.</a>&nbsp;&nbsp;&nbsp;<a href="#cookie-name-prefixes">Cookie Name Prefixes</a></li></ul></li><li><a href="#rfc.section.4.2">4.2.</a>&nbsp;&nbsp;&nbsp;<a href="#sane-cookie">Cookie</a><ul><li><a href="#rfc.section.4.2.1">4.2.1.</a>&nbsp;&nbsp;&nbsp;<a href="#syntax-1">Syntax</a></li><li><a href="#rfc.section.4.2.2">4.2.2.</a>&nbsp;&nbsp;&nbsp;<a href="#semantics">Semantics</a></li></ul></li></ul></li><li><a href="#rfc.section.5">5.</a>&nbsp;&nbsp;&nbsp;<a href="#ua-requirements">User Agent Requirements</a><ul><li><a href="#rfc.section.5.1">5.1.</a>&nbsp;&nbsp;&nbsp;<a href="#subcomponent-algorithms">Subcomponent Algorithms</a><ul><li><a href="#rfc.section.5.1.1">5.1.1.</a>&nbsp;&nbsp;&nbsp;<a href="#cookie-date">Dates</a></li><li><a href="#rfc.section.5.1.2">5.1.2.</a>&nbsp;&nbsp;&nbsp;<a href="#canonicalized-host-names">Canonicalized Host Names</a></li><li><a href="#rfc.section.5.1.3">5.1.3.</a>&nbsp;&nbsp;&nbsp;<a href="#domain-matching">Domain Matching</a></li><li><a href="#rfc.section.5.1.4">5.1.4.</a>&nbsp;&nbsp;&nbsp;<a href="#cookie-path">Paths and Path-Match</a></li></ul></li><li><a href="#rfc.section.5.2">5.2.</a>&nbsp;&nbsp;&nbsp;<a href="#same-site-requests">“Same-site” and “cross-site” Requests</a><ul><li><a href="#rfc.section.5.2.1">5.2.1.</a>&nbsp;&nbsp;&nbsp;<a href="#document-requests">Document-based requests</a></li><li><a href="#rfc.section.5.2.2">5.2.2.</a>&nbsp;&nbsp;&nbsp;<a href="#worker-requests">Worker-based requests</a></li></ul></li><li><a href="#rfc.section.5.3">5.3.</a>&nbsp;&nbsp;&nbsp;<a href="#set-cookie">The Set-Cookie Header</a><ul><li><a href="#rfc.section.5.3.1">5.3.1.</a>&nbsp;&nbsp;&nbsp;<a href="#the-expires-attribute-1">The Expires Attribute</a></li><li><a href="#rfc.section.5.3.2">5.3.2.</a>&nbsp;&nbsp;&nbsp;<a href="#the-max-age-attribute-1">The Max-Age Attribute</a></li><li><a href="#rfc.section.5.3.3">5.3.3.</a>&nbsp;&nbsp;&nbsp;<a href="#the-domain-attribute-1">The Domain Attribute</a></li><li><a href="#rfc.section.5.3.4">5.3.4.</a>&nbsp;&nbsp;&nbsp;<a href="#the-path-attribute-1">The Path Attribute</a></li><li><a href="#rfc.section.5.3.5">5.3.5.</a>&nbsp;&nbsp;&nbsp;<a href="#the-secure-attribute">The Secure Attribute</a></li><li><a href="#rfc.section.5.3.6">5.3.6.</a>&nbsp;&nbsp;&nbsp;<a href="#the-httponly-attribute-1">The HttpOnly Attribute</a></li><li><a href="#rfc.section.5.3.7">5.3.7.</a>&nbsp;&nbsp;&nbsp;<a href="#the-samesite-attribute-1">The SameSite Attribute</a></li></ul></li><li><a href="#rfc.section.5.4">5.4.</a>&nbsp;&nbsp;&nbsp;<a href="#storage-model">Storage Model</a></li><li><a href="#rfc.section.5.5">5.5.</a>&nbsp;&nbsp;&nbsp;<a href="#cookie">The Cookie Header</a></li></ul></li><li><a href="#rfc.section.6">6.</a>&nbsp;&nbsp;&nbsp;<a href="#implementation-considerations">Implementation Considerations</a><ul><li><a href="#rfc.section.6.1">6.1.</a>&nbsp;&nbsp;&nbsp;<a href="#limits">Limits</a></li><li><a href="#rfc.section.6.2">6.2.</a>&nbsp;&nbsp;&nbsp;<a href="#application-programming-interfaces">Application Programming Interfaces</a></li><li><a href="#rfc.section.6.3">6.3.</a>&nbsp;&nbsp;&nbsp;<a href="#idna-migration">IDNA Dependency and Migration</a></li></ul></li><li><a href="#rfc.section.7">7.</a>&nbsp;&nbsp;&nbsp;<a href="#privacy-considerations">Privacy Considerations</a><ul><li><a href="#rfc.section.7.1">7.1.</a>&nbsp;&nbsp;&nbsp;<a href="#third-party-cookies">Third-Party Cookies</a></li><li><a href="#rfc.section.7.2">7.2.</a>&nbsp;&nbsp;&nbsp;<a href="#user-controls">User Controls</a></li><li><a href="#rfc.section.7.3">7.3.</a>&nbsp;&nbsp;&nbsp;<a href="#expiration-dates">Expiration Dates</a></li></ul></li><li><a href="#rfc.section.8">8.</a>&nbsp;&nbsp;&nbsp;<a href="#security-considerations">Security Considerations</a><ul><li><a href="#rfc.section.8.1">8.1.</a>&nbsp;&nbsp;&nbsp;<a href="#overview-1">Overview</a></li><li><a href="#rfc.section.8.2">8.2.</a>&nbsp;&nbsp;&nbsp;<a href="#ambient-authority">Ambient Authority</a></li><li><a href="#rfc.section.8.3">8.3.</a>&nbsp;&nbsp;&nbsp;<a href="#clear-text">Clear Text</a></li><li><a href="#rfc.section.8.4">8.4.</a>&nbsp;&nbsp;&nbsp;<a href="#session-identifiers">Session Identifiers</a></li><li><a href="#rfc.section.8.5">8.5.</a>&nbsp;&nbsp;&nbsp;<a href="#weak-confidentiality">Weak Confidentiality</a></li><li><a href="#rfc.section.8.6">8.6.</a>&nbsp;&nbsp;&nbsp;<a href="#weak-integrity">Weak Integrity</a></li><li><a href="#rfc.section.8.7">8.7.</a>&nbsp;&nbsp;&nbsp;<a href="#reliance-on-dns">Reliance on DNS</a></li><li><a href="#rfc.section.8.8">8.8.</a>&nbsp;&nbsp;&nbsp;<a href="#samesite-cookies">SameSite Cookies</a><ul><li><a href="#rfc.section.8.8.1">8.8.1.</a>&nbsp;&nbsp;&nbsp;<a href="#defense-in-depth">Defense in depth</a></li><li><a href="#rfc.section.8.8.2">8.8.2.</a>&nbsp;&nbsp;&nbsp;<a href="#top-level-navigations">Top-level Navigations</a></li><li><a href="#rfc.section.8.8.3">8.8.3.</a>&nbsp;&nbsp;&nbsp;<a href="#mashups-and-widgets">Mashups and Widgets</a></li><li><a href="#rfc.section.8.8.4">8.8.4.</a>&nbsp;&nbsp;&nbsp;<a href="#server-controlled">Server-controlled</a></li></ul></li></ul></li><li><a href="#rfc.section.9">9.</a>&nbsp;&nbsp;&nbsp;<a href="#iana-considerations">IANA Considerations</a><ul><li><a href="#rfc.section.9.1">9.1.</a>&nbsp;&nbsp;&nbsp;<a href="#iana-cookie">Cookie</a></li><li><a href="#rfc.section.9.2">9.2.</a>&nbsp;&nbsp;&nbsp;<a href="#iana-set-cookie">Set-Cookie</a></li></ul></li><li><a href="#rfc.section.10">10.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.references">References</a><ul><li><a href="#rfc.section.10.1">10.1.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.references.1">Normative References</a></li><li><a href="#rfc.section.10.2">10.2.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.references.2">Informative References</a></li></ul></li><li><a href="#rfc.section.A">A.</a>&nbsp;&nbsp;&nbsp;<a href="#changes">Changes</a><ul><li><a href="#rfc.section.A.1">A.1.</a>&nbsp;&nbsp;&nbsp;<a href="#draft-ietf-httpbis-rfc6265bis-00">draft-ietf-httpbis-rfc6265bis-00</a></li><li><a href="#rfc.section.A.2">A.2.</a>&nbsp;&nbsp;&nbsp;<a href="#draft-ietf-httpbis-rfc6265bis-01">draft-ietf-httpbis-rfc6265bis-01</a></li><li><a href="#rfc.section.A.3">A.3.</a>&nbsp;&nbsp;&nbsp;<a href="#draft-ietf-httpbis-rfc6265bis-02">draft-ietf-httpbis-rfc6265bis-02</a></li></ul></li><li><a href="#rfc.section.B">B.</a>&nbsp;&nbsp;&nbsp;<a href="#acknowledgements">Acknowledgements</a></li><li><a href="#rfc.authors">Authors' Addresses</a></li></ul></div></div></div></div><div class="col-md-8 main" role="main"><header><table class="table table-condensed header" id="rfc.headerblock"><tbody><tr><td class="text-left">HTTP Working Group</td><td class="text-right">A. Barth</td></tr><tr><td class="text-left">Internet-Draft</td><td class="text-right">M. West</td></tr><tr><td class="text-left">Obsoletes: <a href="https://tools.ietf.org/html/rfc6265">6265</a> (if approved)</td><td class="text-right">Google, Inc</td></tr><tr><td class="text-left">Intended status: Standards Track</td><td class="text-right">October 23, 2017</td></tr><tr><td class="text-left">Expires: April 26, 2018</td><td class="text-right"></td></tr></tbody></table><div id="rfc.title"><h1>Cookies: HTTP State Management Mechanism</h1><div class="filename">draft-ietf-httpbis-rfc6265bis-latest</div></div></header><hr><h2 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h2><div class="lead"><div id="rfc.abstract.p.1"><p>This document defines the HTTP Cookie and Set-Cookie header fields. These header fields can be used by HTTP servers to store state (called cookies) at HTTP user agents, letting the servers maintain a stateful session over the mostly stateless HTTP protocol. Although cookies have many historical infelicities that degrade their security and privacy, the Cookie and Set-Cookie header fields are widely used on the Internet. This document obsoletes RFC 6265.</p></div></div><section id="rfc.note.1" class="note"><h2><a href="#rfc.note.1">Note to Readers</a></h2><div id="rfc.note.1.p.1"><p>Discussion of this draft takes place on the HTTP working group mailing list (ietf-http-wg@w3.org), which is archived at <a href="https://lists.w3.org/Archives/Public/ietf-http-wg/">https://lists.w3.org/Archives/Public/ietf-http-wg/</a>.</p></div><div id="rfc.note.1.p.2"><p>Working Group information can be found at <a href="http://httpwg.github.io/">http://httpwg.github.io/</a>; source code and issues list for this draft can be found at <a href="https://github.com/httpwg/http-extensions/labels/6265bis">https://github.com/httpwg/http-extensions/labels/6265bis</a>.</p></div></section><section id="rfc.status"><h2><a href="#rfc.status">Status of this Memo</a></h2><div id="rfc.boilerplate.1.p.1"><p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p></div><div id="rfc.boilerplate.1.p.2"><p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF). Note that other groups may also distribute working documents as Internet-Drafts. The list of current Internet-Drafts is at <a href="http://datatracker.ietf.org/drafts/current/">http://datatracker.ietf.org/drafts/current/</a>.</p></div><div id="rfc.boilerplate.1.p.3"><p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time. It is inappropriate to use Internet-Drafts as reference material or to cite them other than as “work in progress”.</p></div><div id="rfc.boilerplate.1.p.4"><p>This Internet-Draft will expire on April 26, 2018.</p></div></section><section id="rfc.copyrightnotice"><h2><a href="#rfc.copyrightnotice">Copyright Notice</a></h2><div id="rfc.boilerplate.2.p.1"><p>Copyright © 2017 IETF Trust and the persons identified as the document authors. All rights reserved.</p></div><div id="rfc.boilerplate.2.p.2"><p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (<a href="http://trustee.ietf.org/license-info">http://trustee.ietf.org/license-info</a>) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p></div><div id="rfc.boilerplate.2.p.3"><p>This document may contain material from IETF Documents or IETF Contributions published or made publicly available before November 10, 2008. The person(s) controlling the copyright in some of this material may not have granted the IETF Trust the right to allow modifications of such material outside the IETF Standards Process. Without obtaining an adequate license from the person(s) controlling the copyright in such materials, this document may not be modified outside the IETF Standards Process, and derivative works of it may not be created outside the IETF Standards Process, except to format it for publication as an RFC or to translate it into languages other than English.</p></div></section><section id="introduction"><h2 id="rfc.section.1" class="np"><a href="#rfc.section.1">1.</a>&nbsp;<a href="#introduction">Introduction</a></h2><div id="rfc.section.1.p.1"><p>This document defines the HTTP Cookie and Set-Cookie header fields. Using the Set-Cookie header field, an HTTP server can pass name/value pairs and associated metadata (called cookies) to a user agent. When the user agent makes subsequent requests to the server, the user agent uses the metadata and other information to determine whether to return the name/value pairs in the Cookie header.</p></div><div id="rfc.section.1.p.2"><p>Although simple on their surface, cookies have a number of complexities. For example, the server indicates a scope for each cookie when sending it to the user agent. The scope indicates the maximum amount of time in which the user agent should return the cookie, the servers to which the user agent should return the cookie, and the URI schemes for which the cookie is applicable.</p></div><div id="rfc.section.1.p.3"><p>For historical reasons, cookies contain a number of security and privacy infelicities. For example, a server can indicate that a given cookie is intended for “secure” connections, but the Secure attribute does not provide integrity in the presence of an active network attacker. Similarly, cookies for a given host are shared across all the ports on that host, even though the usual “same-origin policy” used by web browsers isolates content retrieved via different ports.</p></div><div id="rfc.section.1.p.4"><p>There are two audiences for this specification: developers of cookie-generating servers and developers of cookie-consuming user agents.</p></div><div id="rfc.section.1.p.5"><p>To maximize interoperability with user agents, servers SHOULD limit themselves to the well-behaved profile defined in <a href="#sane-profile" title="Server Requirements">Section&nbsp;4</a> when generating cookies.</p></div><div id="rfc.section.1.p.6"><p>User agents MUST implement the more liberal processing rules defined in Section 5, in order to maximize interoperability with existing servers that do not conform to the well-behaved profile defined in <a href="#sane-profile" title="Server Requirements">Section&nbsp;4</a>.</p></div><div id="rfc.section.1.p.7"><p>This document specifies the syntax and semantics of these headers as they are actually used on the Internet. In particular, this document does not create new syntax or semantics beyond those in use today. The recommendations for cookie generation provided in <a href="#sane-profile" title="Server Requirements">Section&nbsp;4</a> represent a preferred subset of current server behavior, and even the more liberal cookie processing algorithm provided in <a href="#ua-requirements" title="User Agent Requirements">Section&nbsp;5</a> does not recommend all of the syntactic and semantic variations in use today. Where some existing software differs from the recommended protocol in significant ways, the document contains a note explaining the difference.</p></div><div id="rfc.section.1.p.8"><p>This document obsoletes <a href="#RFC6265"><cite title="HTTP State Management Mechanism">[RFC6265]</cite></a>.</p></div></section><section id="conventions"><h2 id="rfc.section.2"><a href="#rfc.section.2">2.</a>&nbsp;<a href="#conventions">Conventions</a></h2><section id="conformance-criteria"><h3 id="rfc.section.2.1"><a href="#rfc.section.2.1">2.1.</a>&nbsp;<a href="#conformance-criteria">Conformance Criteria</a></h3><div id="rfc.section.2.1.p.1"><p>The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in <a href="#RFC2119"><cite title="Key words for use in RFCs to Indicate Requirement Levels">[RFC2119]</cite></a>.</p></div><div id="rfc.section.2.1.p.2"><p>Requirements phrased in the imperative as part of algorithms (such as “strip any leading space characters” or “return false and abort these steps”) are to be interpreted with the meaning of the key word (“MUST”, “SHOULD”, “MAY”, etc.) used in introducing the algorithm.</p></div><div id="rfc.section.2.1.p.3"><p>Conformance requirements phrased as algorithms or specific steps can be implemented in any manner, so long as the end result is equivalent. In particular, the algorithms defined in this specification are intended to be easy to understand and are not intended to be performant.</p></div></section><section id="syntax-notation"><h3 id="rfc.section.2.2"><a href="#rfc.section.2.2">2.2.</a>&nbsp;<a href="#syntax-notation">Syntax Notation</a></h3><div id="rfc.section.2.2.p.1"><p>This specification uses the Augmented Backus-Naur Form (ABNF) notation of <a href="#RFC5234"><cite title="Augmented BNF for Syntax Specifications: ABNF">[RFC5234]</cite></a>.</p></div><div id="rfc.section.2.2.p.2"><p>The following core rules are included by reference, as defined in <a href="#RFC5234"><cite title="Augmented BNF for Syntax Specifications: ABNF">[RFC5234]</cite></a>, Appendix B.1: ALPHA (letters), CR (carriage return), CRLF (CR LF), CTLs (controls), DIGIT (decimal 0-9), DQUOTE (double quote), HEXDIG (hexadecimal 0-9/A-F/a-f), LF (line feed), NUL (null octet), OCTET (any 8-bit sequence of data except NUL), SP (space), HTAB (horizontal tab), CHAR (any <a href="#USASCII"><cite title="Coded Character Set -- 7-bit American Standard Code for Information Interchange">[USASCII]</cite></a> character), VCHAR (any visible <a href="#USASCII"><cite title="Coded Character Set -- 7-bit American Standard Code for Information Interchange">[USASCII]</cite></a> character), and WSP (whitespace).</p></div><div id="rfc.section.2.2.p.3" class="avoidbreakafter"><p>The OWS (optional whitespace) rule is used where zero or more linear whitespace characters MAY appear:</p></div><div id="rfc.figure.u.1"><pre class="inline">
OWS            = *( [ obs-fold ] WSP )
                 ; "optional" whitespace
obs-fold       = CRLF
</pre></div><div id="rfc.section.2.2.p.4"><p>OWS SHOULD either not be produced or be produced as a single SP character.</p></div></section><section id="terminology"><h3 id="rfc.section.2.3"><a href="#rfc.section.2.3">2.3.</a>&nbsp;<a href="#terminology">Terminology</a></h3><div id="rfc.section.2.3.p.1"><p>The terms “user agent”, “client”, “server”, “proxy”, and “origin server” have the same meaning as in the HTTP/1.1 specification (<a href="#RFC2616"><cite title="Hypertext Transfer Protocol -- HTTP/1.1">[RFC2616]</cite></a>, Section 1.3).</p></div><div id="rfc.section.2.3.p.2"><p>The request-host is the name of the host, as known by the user agent, to which the user agent is sending an HTTP request or from which it is receiving an HTTP response (i.e., the name of the host to which it sent the corresponding HTTP request).</p></div><div id="rfc.section.2.3.p.3"><p>The term request-uri is defined in Section 5.1.2 of <a href="#RFC2616"><cite title="Hypertext Transfer Protocol -- HTTP/1.1">[RFC2616]</cite></a>.</p></div><div id="rfc.section.2.3.p.4"><p>Two sequences of octets are said to case-insensitively match each other if and only if they are equivalent under the i;ascii-casemap collation defined in <a href="#RFC4790"><cite title="Internet Application Protocol Collation Registry">[RFC4790]</cite></a>.</p></div><div id="rfc.section.2.3.p.5"><p>The term string means a sequence of non-NUL octets.</p></div><div id="rfc.section.2.3.p.6"><p>The terms “active document”, “ancestor browsing context”, “browsing context”, “dedicated worker”, “Document”, “WorkerGlobalScope”, “sandboxed origin browsing context flag”, “parent browsing context”, “shared worker”, “the worker’s Documents”, “nested browsing context”, and “top-level browsing context” are defined in <a href="#HTML"><cite title="HTML">[HTML]</cite></a>.</p></div><div id="rfc.section.2.3.p.7"><p>“Service Workers” are defined in the Service Workers specification <a href="#SERVICE-WORKERS"><cite title="Service Workers">[SERVICE-WORKERS]</cite></a>.</p></div><div id="rfc.section.2.3.p.8"><p>The term “origin”, the mechanism of deriving an origin from a URI, and the “the same” matching algorithm for origins are defined in <a href="#RFC6454"><cite title="The Web Origin Concept">[RFC6454]</cite></a>.</p></div><div id="rfc.section.2.3.p.9"><p>“Safe” HTTP methods include <span class="tt">GET</span>, <span class="tt">HEAD</span>, <span class="tt">OPTIONS</span>, and <span class="tt">TRACE</span>, as defined in Section 4.2.1 of <a href="#RFC7231"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content">[RFC7231]</cite></a>.</p></div><div id="rfc.section.2.3.p.10"><p>The term “public suffix” is defined in a note in Section 5.3 of <a href="#RFC6265"><cite title="HTTP State Management Mechanism">[RFC6265]</cite></a> as “a domain that is controlled by a public registry”, and are also know as “effective top-level domains” (eTLDs). For example, <span class="tt">example.com</span>’s public suffix is <span class="tt">com</span>. User agents SHOULD use an up-to-date public suffix list, such as the one maintained by Mozilla at <a href="#PSL"><cite title="Public Suffix List">[PSL]</cite></a>.</p></div><div id="rfc.section.2.3.p.11"><p>An origin’s “registered domain” is the origin’s host’s public suffix plus the label to its left. That is, for <span class="tt">https://www.example.com</span>, the public suffix is <span class="tt">com</span>, and the registered domain is <span class="tt">example.com</span>. This concept is defined more rigorously in <a href="#PSL"><cite title="Public Suffix List">[PSL]</cite></a>, and is also know as “effective top-level domain plus one” (eTLD+1).</p></div><div id="rfc.section.2.3.p.12"><p>The term “request”, as well as a request’s “client”, “current url”, “method”, and “target browsing context”, are defined in <a href="#FETCH"><cite title="Fetch">[FETCH]</cite></a>.</p></div></section></section><section id="overview"><h2 id="rfc.section.3"><a href="#rfc.section.3">3.</a>&nbsp;<a href="#overview">Overview</a></h2><div id="rfc.section.3.p.1"><p>This section outlines a way for an origin server to send state information to a user agent and for the user agent to return the state information to the origin server.</p></div><div id="rfc.section.3.p.2"><p>To store state, the origin server includes a Set-Cookie header in an HTTP response. In subsequent requests, the user agent returns a Cookie request header to the origin server. The Cookie header contains cookies the user agent received in previous Set-Cookie headers. The origin server is free to ignore the Cookie header or use its contents for an application-defined purpose.</p></div><div id="rfc.section.3.p.3"><p>Origin servers MAY send a Set-Cookie response header with any response. User agents MAY ignore Set-Cookie headers contained in responses with 100-level status codes but MUST process Set-Cookie headers contained in other responses (including responses with 400- and 500-level status codes). An origin server can include multiple Set-Cookie header fields in a single response. The presence of a Cookie or a Set-Cookie header field does not preclude HTTP caches from storing and reusing a response.</p></div><div id="rfc.section.3.p.4"><p>Origin servers SHOULD NOT fold multiple Set-Cookie header fields into a single header field. The usual mechanism for folding HTTP headers fields (i.e., as defined in <a href="#RFC2616"><cite title="Hypertext Transfer Protocol -- HTTP/1.1">[RFC2616]</cite></a>) might change the semantics of the Set-Cookie header field because the %x2C (“,”) character is used by Set-Cookie in a way that conflicts with such folding.</p></div><section id="examples"><h3 id="rfc.section.3.1"><a href="#rfc.section.3.1">3.1.</a>&nbsp;<a href="#examples">Examples</a></h3><div id="rfc.section.3.1.p.1"><p>Using the Set-Cookie header, a server can send the user agent a short string in an HTTP response that the user agent will return in future HTTP requests that are within the scope of the cookie. For example, the server can send the user agent a “session identifier” named SID with the value 31d4d96e407aad42. The user agent then returns the session identifier in subsequent requests.</p></div><div id="rfc.figure.u.2"><pre>
== Server -&gt; User Agent ==

Set-Cookie: SID=31d4d96e407aad42

== User Agent -&gt; Server ==

Cookie: SID=31d4d96e407aad42
</pre></div><div id="rfc.section.3.1.p.2"><p>The server can alter the default scope of the cookie using the Path and Domain attributes. For example, the server can instruct the user agent to return the cookie to every path and every subdomain of example.com.</p></div><div id="rfc.figure.u.3"><pre>
== Server -&gt; User Agent ==

Set-Cookie: SID=31d4d96e407aad42; Path=/; Domain=example.com

== User Agent -&gt; Server ==

Cookie: SID=31d4d96e407aad42
</pre></div><div id="rfc.section.3.1.p.3"><p>As shown in the next example, the server can store multiple cookies at the user agent. For example, the server can store a session identifier as well as the user’s preferred language by returning two Set-Cookie header fields. Notice that the server uses the Secure and HttpOnly attributes to provide additional security protections for the more sensitive session identifier (see <a href="#sane-set-cookie-semantics" title="Semantics (Non-Normative)">Section&nbsp;4.1.2</a>).</p></div><div id="rfc.figure.u.4"><pre>
== Server -&gt; User Agent ==

Set-Cookie: SID=31d4d96e407aad42; Path=/; Secure; HttpOnly
Set-Cookie: lang=en-US; Path=/; Domain=example.com

== User Agent -&gt; Server ==

Cookie: SID=31d4d96e407aad42; lang=en-US
</pre></div><div id="rfc.section.3.1.p.4"><p>Notice that the Cookie header above contains two cookies, one named SID and one named lang. If the server wishes the user agent to persist the cookie over multiple “sessions” (e.g., user agent restarts), the server can specify an expiration date in the Expires attribute. Note that the user agent might delete the cookie before the expiration date if the user agent’s cookie store exceeds its quota or if the user manually deletes the server’s cookie.</p></div><div id="rfc.figure.u.5"><pre>
== Server -&gt; User Agent ==

Set-Cookie: lang=en-US; Expires=Wed, 09 Jun 2021 10:18:14 GMT

== User Agent -&gt; Server ==

Cookie: SID=31d4d96e407aad42; lang=en-US
</pre></div><div id="rfc.section.3.1.p.5"><p>Finally, to remove a cookie, the server returns a Set-Cookie header with an expiration date in the past. The server will be successful in removing the cookie only if the Path and the Domain attribute in the Set-Cookie header match the values used when the cookie was created.</p></div><div id="rfc.figure.u.6"><pre>
== Server -&gt; User Agent ==

Set-Cookie: lang=; Expires=Sun, 06 Nov 1994 08:49:37 GMT

== User Agent -&gt; Server ==

Cookie: SID=31d4d96e407aad42
</pre></div></section></section><section id="sane-profile"><h2 id="rfc.section.4"><a href="#rfc.section.4">4.</a>&nbsp;<a href="#sane-profile">Server Requirements</a></h2><div id="rfc.section.4.p.1"><p>This section describes the syntax and semantics of a well-behaved profile of the Cookie and Set-Cookie headers.</p></div><section id="sane-set-cookie"><h3 id="rfc.section.4.1"><a href="#rfc.section.4.1">4.1.</a>&nbsp;<a href="#sane-set-cookie">Set-Cookie</a></h3><div id="rfc.section.4.1.p.1"><p>The Set-Cookie HTTP response header is used to send cookies from the server to the user agent.</p></div><section id="syntax"><h4 id="rfc.section.4.1.1"><a href="#rfc.section.4.1.1">4.1.1.</a>&nbsp;<a href="#syntax">Syntax</a></h4><div id="rfc.section.4.1.1.p.1" class="avoidbreakafter"><p>Informally, the Set-Cookie response header contains the header name “Set-Cookie” followed by a “:” and a cookie. Each cookie begins with a name-value-pair, followed by zero or more attribute-value pairs. Servers SHOULD NOT send Set-Cookie headers that fail to conform to the following grammar:</p></div><div id="rfc.figure.u.7"><pre class="inline">
set-cookie-header = "Set-Cookie:" SP set-cookie-string
set-cookie-string = cookie-pair *( ";" SP cookie-av )
cookie-pair       = cookie-name "=" cookie-value
cookie-name       = token
cookie-value      = *cookie-octet / ( DQUOTE *cookie-octet DQUOTE )
cookie-octet      = %x21 / %x23-2B / %x2D-3A / %x3C-5B / %x5D-7E
                      ; US-ASCII characters excluding CTLs,
                      ; whitespace DQUOTE, comma, semicolon,
                      ; and backslash
token             = &lt;token, defined in [RFC2616], Section 2.2&gt;

cookie-av         = expires-av / max-age-av / domain-av /
                    path-av / secure-av / httponly-av /
                    samesite-av / extension-av
expires-av        = "Expires=" sane-cookie-date
sane-cookie-date  =
    &lt;rfc1123-date, defined in [RFC2616], Section 3.3.1&gt;
max-age-av        = "Max-Age=" non-zero-digit *DIGIT
                      ; In practice, both expires-av and max-age-av
                      ; are limited to dates representable by the
                      ; user agent.
non-zero-digit    = %x31-39
                      ; digits 1 through 9
domain-av         = "Domain=" domain-value
domain-value      = &lt;subdomain&gt;
                      ; defined in [RFC1034], Section 3.5, as
                      ; enhanced by [RFC1123], Section 2.1
path-av           = "Path=" path-value
path-value        = *av-octet
secure-av         = "Secure"
httponly-av       = "HttpOnly"
samesite-av       = "SameSite=" samesite-value
samesite-value    = "Strict" / "Lax"
extension-av      = *av-octet
av-octet          = %x20-3A / %x3C-7E
                      ; any CHAR except CTLs or ";"
</pre></div><div id="rfc.section.4.1.1.p.2"><p>Note that some of the grammatical terms above reference documents that use different grammatical notations than this document (which uses ABNF from <a href="#RFC5234"><cite title="Augmented BNF for Syntax Specifications: ABNF">[RFC5234]</cite></a>).</p></div><div id="rfc.section.4.1.1.p.3"><p>The semantics of the cookie-value are not defined by this document.</p></div><div id="rfc.section.4.1.1.p.4"><p>To maximize compatibility with user agents, servers that wish to store arbitrary data in a cookie-value SHOULD encode that data, for example, using Base64 <a href="#RFC4648"><cite title="The Base16, Base32, and Base64 Data Encodings">[RFC4648]</cite></a>.</p></div><div id="rfc.section.4.1.1.p.5"><p>Per the grammar above, the cookie-value MAY be wrapped in DQUOTE characters. Note that in this case, the initial and trailing DQUOTE characters are not stripped. They are part of the cookie-value, and will be included in Cookie headers sent to the server.</p></div><div id="rfc.section.4.1.1.p.6"><p>The portions of the set-cookie-string produced by the cookie-av term are known as attributes. To maximize compatibility with user agents, servers SHOULD NOT produce two attributes with the same name in the same set-cookie-string. (See <a href="#storage-model" title="Storage Model">Section&nbsp;5.4</a> for how user agents handle this case.)</p></div><div id="rfc.section.4.1.1.p.7"><p>Servers SHOULD NOT include more than one Set-Cookie header field in the same response with the same cookie-name. (See <a href="#set-cookie" title="The Set-Cookie Header">Section&nbsp;5.3</a> for how user agents handle this case.)</p></div><div id="rfc.section.4.1.1.p.8"><p>If a server sends multiple responses containing Set-Cookie headers concurrently to the user agent (e.g., when communicating with the user agent over multiple sockets), these responses create a “race condition” that can lead to unpredictable behavior.</p></div><div id="rfc.section.4.1.1.p.9"><p>NOTE: Some existing user agents differ in their interpretation of two-digit years. To avoid compatibility issues, servers SHOULD use the rfc1123-date format, which requires a four-digit year.</p></div><div id="rfc.section.4.1.1.p.10"><p>NOTE: Some user agents store and process dates in cookies as 32-bit UNIX time_t values. Implementation bugs in the libraries supporting time_t processing on some systems might cause such user agents to process dates after the year 2038 incorrectly.</p></div></section><section id="sane-set-cookie-semantics"><h4 id="rfc.section.4.1.2"><a href="#rfc.section.4.1.2">4.1.2.</a>&nbsp;<a href="#sane-set-cookie-semantics">Semantics (Non-Normative)</a></h4><div id="rfc.section.4.1.2.p.1"><p>This section describes simplified semantics of the Set-Cookie header. These semantics are detailed enough to be useful for understanding the most common uses of cookies by servers. The full semantics are described in <a href="#ua-requirements" title="User Agent Requirements">Section&nbsp;5</a>.</p></div><div id="rfc.section.4.1.2.p.2"><p>When the user agent receives a Set-Cookie header, the user agent stores the cookie together with its attributes. Subsequently, when the user agent makes an HTTP request, the user agent includes the applicable, non-expired cookies in the Cookie header.</p></div><div id="rfc.section.4.1.2.p.3"><p>If the user agent receives a new cookie with the same cookie-name, domain-value, and path-value as a cookie that it has already stored, the existing cookie is evicted and replaced with the new cookie. Notice that servers can delete cookies by sending the user agent a new cookie with an Expires attribute with a value in the past.</p></div><div id="rfc.section.4.1.2.p.4"><p>Unless the cookie’s attributes indicate otherwise, the cookie is returned only to the origin server (and not, for example, to any subdomains), and it expires at the end of the current session (as defined by the user agent). User agents ignore unrecognized cookie attributes (but not the entire cookie).</p></div><section id="the-expires-attribute"><h5 id="rfc.section.4.1.2.1"><a href="#rfc.section.4.1.2.1">4.1.2.1.</a>&nbsp;<a href="#the-expires-attribute">The Expires Attribute</a></h5><div id="rfc.section.4.1.2.1.p.1"><p>The Expires attribute indicates the maximum lifetime of the cookie, represented as the date and time at which the cookie expires. The user agent is not required to retain the cookie until the specified date has passed. In fact, user agents often evict cookies due to memory pressure or privacy concerns.</p></div></section><section id="the-max-age-attribute"><h5 id="rfc.section.4.1.2.2"><a href="#rfc.section.4.1.2.2">4.1.2.2.</a>&nbsp;<a href="#the-max-age-attribute">The Max-Age Attribute</a></h5><div id="rfc.section.4.1.2.2.p.1"><p>The Max-Age attribute indicates the maximum lifetime of the cookie, represented as the number of seconds until the cookie expires. The user agent is not required to retain the cookie for the specified duration. In fact, user agents often evict cookies due to memory pressure or privacy concerns.</p></div><div id="rfc.section.4.1.2.2.p.2"><p>NOTE: Some existing user agents do not support the Max-Age attribute. User agents that do not support the Max-Age attribute ignore the attribute.</p></div><div id="rfc.section.4.1.2.2.p.3"><p>If a cookie has both the Max-Age and the Expires attribute, the Max-Age attribute has precedence and controls the expiration date of the cookie. If a cookie has neither the Max-Age nor the Expires attribute, the user agent will retain the cookie until “the current session is over” (as defined by the user agent).</p></div></section><section id="the-domain-attribute"><h5 id="rfc.section.4.1.2.3"><a href="#rfc.section.4.1.2.3">4.1.2.3.</a>&nbsp;<a href="#the-domain-attribute">The Domain Attribute</a></h5><div id="rfc.section.4.1.2.3.p.1"><p>The Domain attribute specifies those hosts to which the cookie will be sent. For example, if the value of the Domain attribute is “example.com”, the user agent will include the cookie in the Cookie header when making HTTP requests to example.com, www.example.com, and www.corp.example.com. (Note that a leading %x2E (“.”), if present, is ignored even though that character is not permitted, but a trailing %x2E (“.”), if present, will cause the user agent to ignore the attribute.) If the server omits the Domain attribute, the user agent will return the cookie only to the origin server.</p></div><div id="rfc.section.4.1.2.3.p.2"><p>WARNING: Some existing user agents treat an absent Domain attribute as if the Domain attribute were present and contained the current host name. For example, if example.com returns a Set-Cookie header without a Domain attribute, these user agents will erroneously send the cookie to www.example.com as well.</p></div><div id="rfc.section.4.1.2.3.p.3"><p>The user agent will reject cookies unless the Domain attribute specifies a scope for the cookie that would include the origin server. For example, the user agent will accept a cookie with a Domain attribute of “example.com” or of “foo.example.com” from foo.example.com, but the user agent will not accept a cookie with a Domain attribute of “bar.example.com” or of “baz.foo.example.com”.</p></div><div id="rfc.section.4.1.2.3.p.4"><p>NOTE: For security reasons, many user agents are configured to reject Domain attributes that correspond to “public suffixes”. For example, some user agents will reject Domain attributes of “com” or “co.uk”. (See <a href="#storage-model" title="Storage Model">Section&nbsp;5.4</a> for more information.)</p></div></section><section id="the-path-attribute"><h5 id="rfc.section.4.1.2.4"><a href="#rfc.section.4.1.2.4">4.1.2.4.</a>&nbsp;<a href="#the-path-attribute">The Path Attribute</a></h5><div id="rfc.section.4.1.2.4.p.1"><p>The scope of each cookie is limited to a set of paths, controlled by the Path attribute. If the server omits the Path attribute, the user agent will use the “directory” of the request-uri’s path component as the default value. (See <a href="#cookie-path" title="Paths and Path-Match">Section&nbsp;5.1.4</a> for more details.)</p></div><div id="rfc.section.4.1.2.4.p.2"><p>The user agent will include the cookie in an HTTP request only if the path portion of the request-uri matches (or is a subdirectory of) the cookie’s Path attribute, where the %x2F (“/”) character is interpreted as a directory separator.</p></div><div id="rfc.section.4.1.2.4.p.3"><p>Although seemingly useful for isolating cookies between different paths within a given host, the Path attribute cannot be relied upon for security (see <a href="#security-considerations" title="Security Considerations">Section&nbsp;8</a>).</p></div></section><section id="sane-secure"><h5 id="rfc.section.4.1.2.5"><a href="#rfc.section.4.1.2.5">4.1.2.5.</a>&nbsp;<a href="#sane-secure">The Secure Attribute</a></h5><div id="rfc.section.4.1.2.5.p.1"><p>The Secure attribute limits the scope of the cookie to “secure” channels (where “secure” is defined by the user agent). When a cookie has the Secure attribute, the user agent will include the cookie in an HTTP request only if the request is transmitted over a secure channel (typically HTTP over Transport Layer Security (TLS) <a href="#RFC2818"><cite title="HTTP Over TLS">[RFC2818]</cite></a>).</p></div><div id="rfc.section.4.1.2.5.p.2"><p>Although seemingly useful for protecting cookies from active network attackers, the Secure attribute protects only the cookie’s confidentiality. An active network attacker can overwrite Secure cookies from an insecure channel, disrupting their integrity (see <a href="#weak-integrity" title="Weak Integrity">Section&nbsp;8.6</a> for more details).</p></div></section><section id="the-httponly-attribute"><h5 id="rfc.section.4.1.2.6"><a href="#rfc.section.4.1.2.6">4.1.2.6.</a>&nbsp;<a href="#the-httponly-attribute">The HttpOnly Attribute</a></h5><div id="rfc.section.4.1.2.6.p.1"><p>The HttpOnly attribute limits the scope of the cookie to HTTP requests. In particular, the attribute instructs the user agent to omit the cookie when providing access to cookies via “non-HTTP” APIs (such as a web browser API that exposes cookies to scripts).</p></div><div id="rfc.section.4.1.2.6.p.2"><p>Note that the HttpOnly attribute is independent of the Secure attribute: a cookie can have both the HttpOnly and the Secure attribute.</p></div></section><section id="the-samesite-attribute"><h5 id="rfc.section.4.1.2.7"><a href="#rfc.section.4.1.2.7">4.1.2.7.</a>&nbsp;<a href="#the-samesite-attribute">The SameSite Attribute</a></h5><div id="rfc.section.4.1.2.7.p.1"><p>The “SameSite” attribute limits the scope of the cookie such that it will only be attached to requests if those requests are same-site, as defined by the algorithm in <a href="#same-site-requests" title="“Same-site” and “cross-site” Requests">Section&nbsp;5.2</a>. For example, requests for <span class="tt">https://example.com/sekrit-image</span> will attach same-site cookies if and only if initiated from a context whose “site for cookies” is “example.com”.</p></div><div id="rfc.section.4.1.2.7.p.2"><p>If the “SameSite” attribute’s value is “Strict”, the cookie will only be sent along with “same-site” requests. If the value is “Lax”, the cookie will be sent with same-site requests, and with “cross-site” top-level navigations, as described in <a href="#strict-lax" title="“Strict” and “Lax” enforcement">Section&nbsp;5.3.7.1</a>. If the “SameSite” attribute’s value is neither of these, the cookie will be ignored.</p></div></section></section><section id="cookie-name-prefixes"><h4 id="rfc.section.4.1.3"><a href="#rfc.section.4.1.3">4.1.3.</a>&nbsp;<a href="#cookie-name-prefixes">Cookie Name Prefixes</a></h4><div id="rfc.section.4.1.3.p.1"><p><a href="#weak-confidentiality" title="Weak Confidentiality">Section&nbsp;8.5</a> and <a href="#weak-integrity" title="Weak Integrity">Section&nbsp;8.6</a> of this document spell out some of the drawbacks of cookies’ historical implementation. In particular, it is impossible for a server to have confidence that a given cookie was set with a particular set of attributes. In order to provide such confidence in a backwards-compatible way, two common sets of requirements can be inferred from the first few characters of the cookie’s name.</p></div><div id="rfc.section.4.1.3.p.2"><p>The normative requirements for the prefixes described below are detailed in the storage model algorithm defined in <a href="#storage-model" title="Storage Model">Section&nbsp;5.4</a>.</p></div><section id="the-secure-prefix"><h5 id="rfc.section.4.1.3.1"><a href="#rfc.section.4.1.3.1">4.1.3.1.</a>&nbsp;<a href="#the-secure-prefix">The “__Secure-“ Prefix</a></h5><div id="rfc.section.4.1.3.1.p.1"><p>If a cookie’s name begins with a case-sensitive match for the string <span class="tt">__Secure-</span>, then the cookie will have been set with a <span class="tt">Secure</span> attribute.</p></div><div id="rfc.section.4.1.3.1.p.2"><p>For example, the following <span class="tt">Set-Cookie</span> header would be rejected by a conformant user agent, as it does not have a <span class="tt">Secure</span> attribute.</p></div><div id="rfc.figure.u.8"><pre>
Set-Cookie: __Secure-SID=12345; Domain=example.com
</pre></div><div id="rfc.section.4.1.3.1.p.3" class="avoidbreakafter"><p>Whereas the following <span class="tt">Set-Cookie</span> header would be accepted:</p></div><div id="rfc.figure.u.9"><pre>
Set-Cookie: __Secure-SID=12345; Domain=example.com; Secure
</pre></div></section><section id="the-host-prefix"><h5 id="rfc.section.4.1.3.2"><a href="#rfc.section.4.1.3.2">4.1.3.2.</a>&nbsp;<a href="#the-host-prefix">The “__Host-“ Prefix</a></h5><div id="rfc.section.4.1.3.2.p.1"><p>If a cookie’s name begins with a case-sensitive match for the string <span class="tt">__Host-</span>, then the cookie will have been set with a <span class="tt">Secure</span> attribute, a <span class="tt">Path</span> attribute with a value of <span class="tt">/</span>, and no <span class="tt">Domain</span> attribute.</p></div><div id="rfc.section.4.1.3.2.p.2"><p>This combination yields a cookie that hews as closely as a cookie can to treating the origin as a security boundary. The lack of a <span class="tt">Domain</span> attribute ensures that the cookie’s <span class="tt">host-only-flag</span> is true, locking the cookie to a particular host, rather than allowing it to span subdomains. Setting the <span class="tt">Path</span> to <span class="tt">/</span> means that the cookie is effective for the entire host, and won’t be overridden for specific paths. The <span class="tt">Secure</span> attribute ensures that the cookie is unaltered by non-secure origins, and won’t span protocols.</p></div><div id="rfc.section.4.1.3.2.p.3"><p>Ports are the only piece of the origin model that <span class="tt">__Host-</span> cookies continue to ignore.</p></div><div id="rfc.section.4.1.3.2.p.4" class="avoidbreakafter"><p>For example, the following cookies would always be rejected:</p></div><div id="rfc.figure.u.10"><pre>
Set-Cookie: __Host-SID=12345
Set-Cookie: __Host-SID=12345; Secure
Set-Cookie: __Host-SID=12345; Domain=example.com
Set-Cookie: __Host-SID=12345; Domain=example.com; Path=/
Set-Cookie: __Host-SID=12345; Secure; Domain=example.com; Path=/
</pre></div><div id="rfc.section.4.1.3.2.p.5" class="avoidbreakafter"><p>While the would be accepted if set from a secure origin (e.g. “https://example.com/”), and rejected otherwise:</p></div><div id="rfc.figure.u.11"><pre>
Set-Cookie: __Host-SID=12345; Secure; Path=/
</pre></div></section></section></section><section id="sane-cookie"><h3 id="rfc.section.4.2"><a href="#rfc.section.4.2">4.2.</a>&nbsp;<a href="#sane-cookie">Cookie</a></h3><section id="syntax-1"><h4 id="rfc.section.4.2.1"><a href="#rfc.section.4.2.1">4.2.1.</a>&nbsp;<a href="#syntax-1">Syntax</a></h4><div id="rfc.section.4.2.1.p.1" class="avoidbreakafter"><p>The user agent sends stored cookies to the origin server in the Cookie header. If the server conforms to the requirements in <a href="#sane-set-cookie" title="Set-Cookie">Section&nbsp;4.1</a> (and the user agent conforms to the requirements in <a href="#ua-requirements" title="User Agent Requirements">Section&nbsp;5</a>), the user agent will send a Cookie header that conforms to the following grammar:</p></div><div id="rfc.figure.u.12"><pre class="inline">
cookie-header = "Cookie:" OWS cookie-string OWS
cookie-string = cookie-pair *( ";" SP cookie-pair )
</pre></div></section><section id="semantics"><h4 id="rfc.section.4.2.2"><a href="#rfc.section.4.2.2">4.2.2.</a>&nbsp;<a href="#semantics">Semantics</a></h4><div id="rfc.section.4.2.2.p.1"><p>Each cookie-pair represents a cookie stored by the user agent. The cookie-pair contains the cookie-name and cookie-value the user agent received in the Set-Cookie header.</p></div><div id="rfc.section.4.2.2.p.2"><p>Notice that the cookie attributes are not returned. In particular, the server cannot determine from the Cookie header alone when a cookie will expire, for which hosts the cookie is valid, for which paths the cookie is valid, or whether the cookie was set with the Secure or HttpOnly attributes.</p></div><div id="rfc.section.4.2.2.p.3"><p>The semantics of individual cookies in the Cookie header are not defined by this document. Servers are expected to imbue these cookies with application-specific semantics.</p></div><div id="rfc.section.4.2.2.p.4"><p>Although cookies are serialized linearly in the Cookie header, servers SHOULD NOT rely upon the serialization order. In particular, if the Cookie header contains two cookies with the same name (e.g., that were set with different Path or Domain attributes), servers SHOULD NOT rely upon the order in which these cookies appear in the header.</p></div></section></section></section><section id="ua-requirements"><h2 id="rfc.section.5"><a href="#rfc.section.5">5.</a>&nbsp;<a href="#ua-requirements">User Agent Requirements</a></h2><div id="rfc.section.5.p.1"><p>This section specifies the Cookie and Set-Cookie headers in sufficient detail that a user agent implementing these requirements precisely can interoperate with existing servers (even those that do not conform to the well-behaved profile described in <a href="#sane-profile" title="Server Requirements">Section&nbsp;4</a>).</p></div><div id="rfc.section.5.p.2"><p>A user agent could enforce more restrictions than those specified herein (e.g., for the sake of improved security); however, experiments have shown that such strictness reduces the likelihood that a user agent will be able to interoperate with existing servers.</p></div><section id="subcomponent-algorithms"><h3 id="rfc.section.5.1"><a href="#rfc.section.5.1">5.1.</a>&nbsp;<a href="#subcomponent-algorithms">Subcomponent Algorithms</a></h3><div id="rfc.section.5.1.p.1"><p>This section defines some algorithms used by user agents to process specific subcomponents of the Cookie and Set-Cookie headers.</p></div><section id="cookie-date"><h4 id="rfc.section.5.1.1"><a href="#rfc.section.5.1.1">5.1.1.</a>&nbsp;<a href="#cookie-date">Dates</a></h4><div id="rfc.section.5.1.1.p.1"><p>The user agent MUST use an algorithm equivalent to the following algorithm to parse a cookie-date. Note that the various boolean flags defined as a part of the algorithm (i.e., found-time, found-day-of-month, found-month, found-year) are initially “not set”.</p></div><div id="rfc.section.5.1.1.p.2"><ol><li>Using the grammar below, divide the cookie-date into date-tokens. <br><br> <span id="rfc.figure.u.13"><pre class="inline">
cookie-date     = *delimiter date-token-list *delimiter
date-token-list = date-token *( 1*delimiter date-token )
date-token      = 1*non-delimiter

delimiter       = %x09 / %x20-2F / %x3B-40 / %x5B-60 / %x7B-7E
non-delimiter   = %x00-08 / %x0A-1F / DIGIT / ":" / ALPHA / %x7F-FF
non-digit       = %x00-2F / %x3A-FF

day-of-month    = 1*2DIGIT [ non-digit *OCTET ]
month           = ( "jan" / "feb" / "mar" / "apr" /
                    "may" / "jun" / "jul" / "aug" /
                    "sep" / "oct" / "nov" / "dec" ) *OCTET
year            = 2*4DIGIT [ non-digit *OCTET ]
time            = hms-time [ non-digit *OCTET ]
hms-time        = time-field ":" time-field ":" time-field
time-field      = 1*2DIGIT
</pre></span> </li><li>Process each date-token sequentially in the order the date-tokens appear in the cookie-date: <ol><li>If the found-time flag is not set and the token matches the time production, set the found-time flag and set the hour-value, minute-value, and second-value to the numbers denoted by the digits in the date-token, respectively. Skip the remaining sub-steps and continue to the next date-token.</li><li>If the found-day-of-month flag is not set and the date-token matches the day-of-month production, set the found-day-of-month flag and set the day-of-month-value to the number denoted by the date-token. Skip the remaining sub-steps and continue to the next date-token.</li><li>If the found-month flag is not set and the date-token matches the month production, set the found-month flag and set the month-value to the month denoted by the date-token. Skip the remaining sub-steps and continue to the next date-token.</li><li>If the found-year flag is not set and the date-token matches the year production, set the found-year flag and set the year-value to the number denoted by the date-token. Skip the remaining sub-steps and continue to the next date-token.</li></ol></li><li>If the year-value is greater than or equal to 70 and less than or equal to 99, increment the year-value by 1900.</li><li>If the year-value is greater than or equal to 0 and less than or equal to 69, increment the year-value by 2000. <ol><li>NOTE: Some existing user agents interpret two-digit years differently.</li></ol></li><li>Abort these steps and fail to parse the cookie-date if: <ul><li>at least one of the found-day-of-month, found-month, found-year, or found-time flags is not set,</li><li>the day-of-month-value is less than 1 or greater than 31,</li><li>the year-value is less than 1601,</li><li>the hour-value is greater than 23,</li><li>the minute-value is greater than 59, or</li><li>the second-value is greater than 59.</li></ul> (Note that leap seconds cannot be represented in this syntax.)</li><li>Let the parsed-cookie-date be the date whose day-of-month, month, year, hour, minute, and second (in UTC) are the day-of-month-value, the month-value, the year-value, the hour-value, the minute-value, and the second-value, respectively. If no such date exists, abort these steps and fail to parse the cookie-date.</li><li>Return the parsed-cookie-date as the result of this algorithm.</li></ol></div></section><section id="canonicalized-host-names"><h4 id="rfc.section.5.1.2"><a href="#rfc.section.5.1.2">5.1.2.</a>&nbsp;<a href="#canonicalized-host-names">Canonicalized Host Names</a></h4><div id="rfc.section.5.1.2.p.1" class="avoidbreakafter"><p>A canonicalized host name is the string generated by the following algorithm:</p></div><div id="rfc.section.5.1.2.p.2"><ol><li>Convert the host name to a sequence of individual domain name labels.</li><li>Convert each label that is not a Non-Reserved LDH (NR-LDH) label, to an A-label (see Section 2.3.2.1 of <a href="#RFC5890"><cite title="Internationalized Domain Names for Applications (IDNA): Definitions and Document Framework">[RFC5890]</cite></a> for the former and latter), or to a “punycode label” (a label resulting from the “ToASCII” conversion in Section 4 of <a href="#RFC3490"><cite title="Internationalizing Domain Names in Applications (IDNA)">[RFC3490]</cite></a>), as appropriate (see <a href="#idna-migration" title="IDNA Dependency and Migration">Section&nbsp;6.3</a> of this specification).</li><li>Concatenate the resulting labels, separated by a %x2E (“.”) character.</li></ol></div></section><section id="domain-matching"><h4 id="rfc.section.5.1.3"><a href="#rfc.section.5.1.3">5.1.3.</a>&nbsp;<a href="#domain-matching">Domain Matching</a></h4><div id="rfc.section.5.1.3.p.1" class="avoidbreakafter"><p>A string domain-matches a given domain string if at least one of the following conditions hold:</p></div><div id="rfc.section.5.1.3.p.2"><ul><li>The domain string and the string are identical. (Note that both the domain string and the string will have been canonicalized to lower case at this point.)</li><li>All of the following conditions hold: <ul><li>The domain string is a suffix of the string.</li><li>The last character of the string that is not included in the domain string is a %x2E (“.”) character.</li><li>The string is a host name (i.e., not an IP address).</li></ul></li></ul></div></section><section id="cookie-path"><h4 id="rfc.section.5.1.4"><a href="#rfc.section.5.1.4">5.1.4.</a>&nbsp;<a href="#cookie-path">Paths and Path-Match</a></h4><div id="rfc.section.5.1.4.p.1" class="avoidbreakafter"><p>The user agent MUST use an algorithm equivalent to the following algorithm to compute the default-path of a cookie:</p></div><div id="rfc.section.5.1.4.p.2"><ol><li>Let uri-path be the path portion of the request-uri if such a portion exists (and empty otherwise). For example, if the request-uri contains just a path (and optional query string), then the uri-path is that path (without the %x3F (“?”) character or query string), and if the request-uri contains a full absoluteURI, the uri-path is the path component of that URI.</li><li>If the uri-path is empty or if the first character of the uri-path is not a %x2F (“/”) character, output %x2F (“/”) and skip the remaining steps.</li><li>If the uri-path contains no more than one %x2F (“/”) character, output %x2F (“/”) and skip the remaining step.</li><li>Output the characters of the uri-path from the first character up to, but not including, the right-most %x2F (“/”).</li></ol></div><div id="rfc.section.5.1.4.p.3" class="avoidbreakafter"><p>A request-path path-matches a given cookie-path if at least one of the following conditions holds:</p></div><div id="rfc.section.5.1.4.p.4"><ul><li>The cookie-path and the request-path are identical. <br><br> Note that this differs from the rules in <a href="#RFC3986"><cite title="Uniform Resource Identifier (URI): Generic Syntax">[RFC3986]</cite></a> for equivalence of the path component, and hence two equivalent paths can have different cookies.</li><li>The cookie-path is a prefix of the request-path, and the last character of the cookie-path is %x2F (“/”).</li><li>The cookie-path is a prefix of the request-path, and the first character of the request-path that is not included in the cookie-path is a %x2F (“/”) character.</li></ul></div></section></section><section id="same-site-requests"><h3 id="rfc.section.5.2"><a href="#rfc.section.5.2">5.2.</a>&nbsp;<a href="#same-site-requests">“Same-site” and “cross-site” Requests</a></h3><div id="rfc.section.5.2.p.1"><p>A request is “same-site” if its target’s URI’s origin’s registered domain is an exact match for the request’s client’s “site for cookies”, or if the request has no client. The request is otherwise “cross-site”.</p></div><div id="rfc.section.5.2.p.2" class="avoidbreakafter"><p>For a given request (“request”), the following algorithm returns <span class="tt">same-site</span> or <span class="tt">cross-site</span>:</p></div><div id="rfc.section.5.2.p.3"><ol><li>If <span class="tt">request</span>’s client is <span class="tt">null</span>, return <span class="tt">same-site</span>. <br><br> Note that this is the case for navigation triggered by the user directly (e.g. by typing directly into a user agent’s address bar).</li><li>Let <span class="tt">site</span> be <span class="tt">request</span>’s client’s “site for cookies” (as defined in the following sections).</li><li>Let <span class="tt">target</span> be the registered domain of <span class="tt">request</span>’s current url.</li><li>If <span class="tt">site</span> is an exact match for <span class="tt">target</span>, return <span class="tt">same-site</span>.</li><li>Return <span class="tt">cross-site</span>.</li></ol></div><div id="rfc.section.5.2.p.4" class="avoidbreakafter"><p>The request’s client’s “site for cookies” is calculated depending upon its client’s type, as described in the following subsections:</p></div><section id="document-requests"><h4 id="rfc.section.5.2.1"><a href="#rfc.section.5.2.1">5.2.1.</a>&nbsp;<a href="#document-requests">Document-based requests</a></h4><div id="rfc.section.5.2.1.p.1"><p>The URI displayed in a user agent’s address bar is the only security context directly exposed to users, and therefore the only signal users can reasonably rely upon to determine whether or not they trust a particular website. The registered domain of that URI’s origin represents the context in which a user most likely believes themselves to be interacting. We’ll label this domain the “top-level site”.</p></div><div id="rfc.section.5.2.1.p.2"><p>For a document displayed in a top-level browsing context, we can stop here: the document’s “site for cookies” is the top-level site.</p></div><div id="rfc.section.5.2.1.p.3"><p>For documents which are displayed in nested browsing contexts, we need to audit the origins of each of a document’s ancestor browsing contexts’ active documents in order to account for the “multiple-nested scenarios” described in Section 4 of <a href="#RFC7034"><cite title="HTTP Header Field X-Frame-Options">[RFC7034]</cite></a>. These document’s “site for cookies” is the top-level site if and only if the document and each of its ancestor documents’ origins have the same registered domain as the top-level site. Otherwise its “site for cookies” is the empty string.</p></div><div id="rfc.section.5.2.1.p.4" class="avoidbreakafter"><p>Given a Document (<span class="tt">document</span>), the following algorithm returns its “site for cookies” (either a registered domain, or the empty string):</p></div><div id="rfc.section.5.2.1.p.5"><ol><li>Let <span class="tt">top-document</span> be the active document in <span class="tt">document</span>’s browsing context’s top-level browsing context.</li><li>Let <span class="tt">top-origin</span> be the origin of <span class="tt">top-document</span>’s URI if <span class="tt">top-document</span>’s sandboxed origin browsing context flag is set, and <span class="tt">top-document</span>’s origin otherwise.</li><li>Let <span class="tt">documents</span> be a list containing <span class="tt">document</span> and each of <span class="tt">document</span>’s ancestor browsing contexts’ active documents.</li><li>For each <span class="tt">item</span> in <span class="tt">documents</span>: <ol><li>Let <span class="tt">origin</span> be the origin of <span class="tt">item</span>’s URI if <span class="tt">item</span>’s sandboxed origin browsing context flag is set, and <span class="tt">item</span>’s origin otherwise.</li><li>If <span class="tt">origin</span>’s host’s registered domain is not an exact match for <span class="tt">top-origin</span>’s host’s registered domain, return the empty string.</li></ol></li><li>Return <span class="tt">top-origin</span>’s host’s registered domain.</li></ol></div></section><section id="worker-requests"><h4 id="rfc.section.5.2.2"><a href="#rfc.section.5.2.2">5.2.2.</a>&nbsp;<a href="#worker-requests">Worker-based requests</a></h4><div id="rfc.section.5.2.2.p.1"><p>Worker-driven requests aren’t as clear-cut as document-driven requests, as there isn’t a clear link between a top-level browsing context and a worker. This is especially true for Service Workers <a href="#SERVICE-WORKERS"><cite title="Service Workers">[SERVICE-WORKERS]</cite></a>, which may execute code in the background, without any document visible at all.</p></div><div id="rfc.section.5.2.2.p.2"><p>Note: The descriptions below assume that workers must be same-origin with the documents that instantiate them. If this invariant changes, we’ll need to take the worker’s script’s URI into account when determining their status.</p></div><section id="dedicated-and-shared-requests"><h5 id="rfc.section.5.2.2.1"><a href="#rfc.section.5.2.2.1">5.2.2.1.</a>&nbsp;<a href="#dedicated-and-shared-requests">Dedicated and Shared Workers</a></h5><div id="rfc.section.5.2.2.1.p.1"><p>Dedicated workers are simple, as each dedicated worker is bound to one and only one document. Requests generated from a dedicated worker (via <span class="tt">importScripts</span>, <span class="tt">XMLHttpRequest</span>, <span class="tt">fetch()</span>, etc) define their “site for cookies” as that document’s “site for cookies”.</p></div><div id="rfc.section.5.2.2.1.p.2"><p>Shared workers may be bound to multiple documents at once. As it is quite possible for those documents to have distinct “site for cookie” values, the worker’s “site for cookies” will be the empty string in cases where the values diverge, and the shared value in cases where the values agree.</p></div><div id="rfc.section.5.2.2.1.p.3" class="avoidbreakafter"><p>Given a WorkerGlobalScope (<span class="tt">worker</span>), the following algorithm returns its “site for cookies” (either a registered domain, or the empty string):</p></div><div id="rfc.section.5.2.2.1.p.4"><ol><li>Let <span class="tt">site</span> be <span class="tt">worker</span>’s origin’s host’s registered domain.</li><li>For each <span class="tt">document</span> in <span class="tt">worker</span>’s Documents: <ol><li>Let <span class="tt">document-site</span> be <span class="tt">document</span>’s “site for cookies” (as defined in <a href="#document-requests" title="Document-based requests">Section&nbsp;5.2.1</a>).</li><li>If <span class="tt">document-site</span> is not an exact match for <span class="tt">site</span>, return the empty string.</li></ol></li><li>Return <span class="tt">site</span>.</li></ol></div></section><section id="service-workers"><h5 id="rfc.section.5.2.2.2"><a href="#rfc.section.5.2.2.2">5.2.2.2.</a>&nbsp;<a href="#service-workers">Service Workers</a></h5><div id="rfc.section.5.2.2.2.p.1"><p>Service Workers are more complicated, as they act as a completely separate execution context with only tangential relationship to the Document which registered them.</p></div><div id="rfc.section.5.2.2.2.p.2"><p>Requests which simply pass through a service worker will be handled as described above: the request’s client will be the Document or Worker which initiated the request, and its “site for cookies” will be those defined in <a href="#document-requests" title="Document-based requests">Section&nbsp;5.2.1</a> and <a href="#dedicated-and-shared-requests" title="Dedicated and Shared Workers">Section&nbsp;5.2.2.1</a></p></div><div id="rfc.section.5.2.2.2.p.3"><p>Requests which are initiated by the Service Worker itself (via a direct call to <span class="tt">fetch()</span>, for instance), on the other hand, will have a client which is a ServiceWorkerGlobalScope. Its “site for cookies” will be the registered domain of the Service Worker’s URI.</p></div><div id="rfc.section.5.2.2.2.p.4" class="avoidbreakafter"><p>Given a ServiceWorkerGlobalScope (<span class="tt">worker</span>), the following algorithm returns its “site for cookies” (either a registered domain, or the empty string):</p></div><div id="rfc.section.5.2.2.2.p.5"><ol><li>Return <span class="tt">worker</span>’s origin’s host’s registered domain.</li></ol></div></section></section></section><section id="set-cookie"><h3 id="rfc.section.5.3"><a href="#rfc.section.5.3">5.3.</a>&nbsp;<a href="#set-cookie">The Set-Cookie Header</a></h3><div id="rfc.section.5.3.p.1"><p>When a user agent receives a Set-Cookie header field in an HTTP response, the user agent MAY ignore the Set-Cookie header field in its entirety. For example, the user agent might wish to block responses to “third-party” requests from setting cookies (see <a href="#third-party-cookies" title="Third-Party Cookies">Section&nbsp;7.1</a>).</p></div><div id="rfc.section.5.3.p.2"><p>If the user agent does not ignore the Set-Cookie header field in its entirety, the user agent MUST parse the field-value of the Set-Cookie header field as a set-cookie-string (defined below).</p></div><div id="rfc.section.5.3.p.3"><p>NOTE: The algorithm below is more permissive than the grammar in <a href="#sane-set-cookie" title="Set-Cookie">Section&nbsp;4.1</a>. For example, the algorithm strips leading and trailing whitespace from the cookie name and value (but maintains internal whitespace), whereas the grammar in <a href="#sane-set-cookie" title="Set-Cookie">Section&nbsp;4.1</a> forbids whitespace in these positions. User agents use this algorithm so as to interoperate with servers that do not follow the recommendations in <a href="#sane-profile" title="Server Requirements">Section&nbsp;4</a>.</p></div><div id="rfc.section.5.3.p.4" class="avoidbreakafter"><p>A user agent MUST use an algorithm equivalent to the following algorithm to parse a set-cookie-string:</p></div><div id="rfc.section.5.3.p.5"><ol><li>If the set-cookie-string contains a %x3B (“;”) character: <ol><li>The name-value-pair string consists of the characters up to, but not including, the first %x3B (“;”), and the unparsed-attributes consist of the remainder of the set-cookie-string (including the %x3B (“;”) in question).</li></ol> Otherwise: <ol><li>The name-value-pair string consists of all the characters contained in the set-cookie-string, and the unparsed-attributes is the empty string.</li></ol></li><li>If the name-value-pair string lacks a %x3D (“=”) character, ignore the set-cookie-string entirely.</li><li>The (possibly empty) name string consists of the characters up to, but not including, the first %x3D (“=”) character, and the (possibly empty) value string consists of the characters after the first %x3D (“=”) character.</li><li>Remove any leading or trailing WSP characters from the name string and the value string.</li><li>If the name string is empty, ignore the set-cookie-string entirely.</li><li>The cookie-name is the name string, and the cookie-value is the value string.</li></ol></div><div id="rfc.section.5.3.p.6" class="avoidbreakafter"><p>The user agent MUST use an algorithm equivalent to the following algorithm to parse the unparsed-attributes:</p></div><div id="rfc.section.5.3.p.7"><ol><li>If the unparsed-attributes string is empty, skip the rest of these steps.</li><li>Discard the first character of the unparsed-attributes (which will be a %x3B (“;”) character).</li><li>If the remaining unparsed-attributes contains a %x3B (“;”) character: <ol><li>Consume the characters of the unparsed-attributes up to, but not including, the first %x3B (“;”) character.</li></ol> Otherwise: <ol><li>Consume the remainder of the unparsed-attributes.</li></ol> Let the cookie-av string be the characters consumed in this step.</li><li>If the cookie-av string contains a %x3D (“=”) character: <ol><li>The (possibly empty) attribute-name string consists of the characters up to, but not including, the first %x3D (“=”) character, and the (possibly empty) attribute-value string consists of the characters after the first %x3D (“=”) character.</li></ol> Otherwise: <ol><li>The attribute-name string consists of the entire cookie-av string, and the attribute-value string is empty.</li></ol></li><li>Remove any leading or trailing WSP characters from the attribute-name string and the attribute-value string.</li><li>Process the attribute-name and attribute-value according to the requirements in the following subsections. (Notice that attributes with unrecognized attribute-names are ignored.)</li><li>Return to Step 1 of this algorithm.</li></ol></div><div id="rfc.section.5.3.p.8"><p>When the user agent finishes parsing the set-cookie-string, the user agent is said to “receive a cookie” from the request-uri with name cookie-name, value cookie-value, and attributes cookie-attribute-list. (See <a href="#storage-model" title="Storage Model">Section&nbsp;5.4</a> for additional requirements triggered by receiving a cookie.)</p></div><section id="the-expires-attribute-1"><h4 id="rfc.section.5.3.1"><a href="#rfc.section.5.3.1">5.3.1.</a>&nbsp;<a href="#the-expires-attribute-1">The Expires Attribute</a></h4><div id="rfc.section.5.3.1.p.1"><p>If the attribute-name case-insensitively matches the string “Expires”, the user agent MUST process the cookie-av as follows.</p></div><div id="rfc.section.5.3.1.p.2"><ol><li>Let the expiry-time be the result of parsing the attribute-value as cookie-date (see <a href="#cookie-date" title="Dates">Section&nbsp;5.1.1</a>).</li><li>If the attribute-value failed to parse as a cookie date, ignore the cookie-av.</li><li>If the expiry-time is later than the last date the user agent can represent, the user agent MAY replace the expiry-time with the last representable date.</li><li>If the expiry-time is earlier than the earliest date the user agent can represent, the user agent MAY replace the expiry-time with the earliest representable date.</li><li>Append an attribute to the cookie-attribute-list with an attribute-name of Expires and an attribute-value of expiry-time.</li></ol></div></section><section id="the-max-age-attribute-1"><h4 id="rfc.section.5.3.2"><a href="#rfc.section.5.3.2">5.3.2.</a>&nbsp;<a href="#the-max-age-attribute-1">The Max-Age Attribute</a></h4><div id="rfc.section.5.3.2.p.1"><p>If the attribute-name case-insensitively matches the string “Max-Age”, the user agent MUST process the cookie-av as follows.</p></div><div id="rfc.section.5.3.2.p.2"><ol><li>If the first character of the attribute-value is not a DIGIT or a “-“ character, ignore the cookie-av.</li><li>If the remainder of attribute-value contains a non-DIGIT character, ignore the cookie-av.</li><li>Let delta-seconds be the attribute-value converted to an integer.</li><li>If delta-seconds is less than or equal to zero (0), let expiry-time be the earliest representable date and time. Otherwise, let the expiry-time be the current date and time plus delta-seconds seconds.</li><li>Append an attribute to the cookie-attribute-list with an attribute-name of Max-Age and an attribute-value of expiry-time.</li></ol></div></section><section id="the-domain-attribute-1"><h4 id="rfc.section.5.3.3"><a href="#rfc.section.5.3.3">5.3.3.</a>&nbsp;<a href="#the-domain-attribute-1">The Domain Attribute</a></h4><div id="rfc.section.5.3.3.p.1"><p>If the attribute-name case-insensitively matches the string “Domain”, the user agent MUST process the cookie-av as follows.</p></div><div id="rfc.section.5.3.3.p.2"><ol><li>If the attribute-value is empty, the behavior is undefined. However, the user agent SHOULD ignore the cookie-av entirely.</li><li>If the first character of the attribute-value string is %x2E (“.”): <ol><li>Let cookie-domain be the attribute-value without the leading %x2E (“.”) character.</li></ol> Otherwise: <ol><li>Let cookie-domain be the entire attribute-value.</li></ol></li><li>Convert the cookie-domain to lower case.</li><li>Append an attribute to the cookie-attribute-list with an attribute-name of Domain and an attribute-value of cookie-domain.</li></ol></div></section><section id="the-path-attribute-1"><h4 id="rfc.section.5.3.4"><a href="#rfc.section.5.3.4">5.3.4.</a>&nbsp;<a href="#the-path-attribute-1">The Path Attribute</a></h4><div id="rfc.section.5.3.4.p.1"><p>If the attribute-name case-insensitively matches the string “Path”, the user agent MUST process the cookie-av as follows.</p></div><div id="rfc.section.5.3.4.p.2"><ol><li>If the attribute-value is empty or if the first character of the attribute-value is not %x2F (“/”): <ol><li>Let cookie-path be the default-path.</li></ol> Otherwise: <ol><li>Let cookie-path be the attribute-value.</li></ol></li><li>Append an attribute to the cookie-attribute-list with an attribute-name of Path and an attribute-value of cookie-path.</li></ol></div></section><section id="the-secure-attribute"><h4 id="rfc.section.5.3.5"><a href="#rfc.section.5.3.5">5.3.5.</a>&nbsp;<a href="#the-secure-attribute">The Secure Attribute</a></h4><div id="rfc.section.5.3.5.p.1"><p>If the attribute-name case-insensitively matches the string “Secure”, the user agent MUST append an attribute to the cookie-attribute-list with an attribute-name of Secure and an empty attribute-value.</p></div></section><section id="the-httponly-attribute-1"><h4 id="rfc.section.5.3.6"><a href="#rfc.section.5.3.6">5.3.6.</a>&nbsp;<a href="#the-httponly-attribute-1">The HttpOnly Attribute</a></h4><div id="rfc.section.5.3.6.p.1"><p>If the attribute-name case-insensitively matches the string “HttpOnly”, the user agent MUST append an attribute to the cookie-attribute-list with an attribute-name of HttpOnly and an empty attribute-value.</p></div></section><section id="the-samesite-attribute-1"><h4 id="rfc.section.5.3.7"><a href="#rfc.section.5.3.7">5.3.7.</a>&nbsp;<a href="#the-samesite-attribute-1">The SameSite Attribute</a></h4><div id="rfc.section.5.3.7.p.1" class="avoidbreakafter"><p>If the attribute-name case-insensitively matches the string “SameSite”, the user agent MUST process the cookie-av as follows:</p></div><div id="rfc.section.5.3.7.p.2"><ol><li>If cookie-av’s attribute-value is not a case-insensitive match for “Strict” or “Lax”, ignore the <span class="tt">cookie-av</span>.</li><li>Let <span class="tt">enforcement</span> be “Lax” if cookie-av’s attribute-value is a case-insensitive match for “Lax”, and “Strict” otherwise.</li><li>Append an attribute to the cookie-attribute-list with an attribute-name of “SameSite” and an attribute-value of <span class="tt">enforcement</span>.</li></ol></div><section id="strict-lax"><h5 id="rfc.section.5.3.7.1"><a href="#rfc.section.5.3.7.1">5.3.7.1.</a>&nbsp;<a href="#strict-lax">“Strict” and “Lax” enforcement</a></h5><div id="rfc.section.5.3.7.1.p.1"><p>Same-site cookies in “Strict” enforcement mode will not be sent along with top-level navigations which are triggered from a cross-site document context. As discussed in <a href="#top-level-navigations" title="Top-level Navigations">Section&nbsp;8.8.2</a>, this might or might not be compatible with existing session management systems. In the interests of providing a drop-in mechanism that mitigates the risk of CSRF attacks, developers may set the <span class="tt">SameSite</span> attribute in a “Lax” enforcement mode that carves out an exception which sends same-site cookies along with cross-site requests if and only if they are top-level navigations which use a “safe” (in the <a href="#RFC7231"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content">[RFC7231]</cite></a> sense) HTTP method.</p></div><div id="rfc.section.5.3.7.1.p.2" class="avoidbreakafter"><p>Lax enforcement provides reasonable defense in depth against CSRF attacks that rely on unsafe HTTP methods (like <span class="tt">POST</span>), but does not offer a robust defense against CSRF as a general category of attack:</p></div><div id="rfc.section.5.3.7.1.p.3"><ol><li>Attackers can still pop up new windows or trigger top-level navigations in order to create a “same-site” request (as described in section 2.1), which is only a speedbump along the road to exploitation.</li><li>Features like <span class="tt">&lt;link rel='prerender'&gt;</span> <a href="#prerendering"><cite title="Chrome Prerendering">[prerendering]</cite></a> can be exploited to create “same-site” requests without the risk of user detection.</li></ol></div><div id="rfc.section.5.3.7.1.p.4"><p>When possible, developers should use a session management mechanism such as that described in <a href="#top-level-navigations" title="Top-level Navigations">Section&nbsp;8.8.2</a> to mitigate the risk of CSRF more completely.</p></div></section></section></section><section id="storage-model"><h3 id="rfc.section.5.4"><a href="#rfc.section.5.4">5.4.</a>&nbsp;<a href="#storage-model">Storage Model</a></h3><div id="rfc.section.5.4.p.1"><p>The user agent stores the following fields about each cookie: name, value, expiry-time, domain, path, creation-time, last-access-time, persistent-flag, host-only-flag, secure-only-flag, http-only-flag, and same-site-flag.</p></div><div id="rfc.section.5.4.p.2" class="avoidbreakafter"><p>When the user agent “receives a cookie” from a request-uri with name cookie-name, value cookie-value, and attributes cookie-attribute-list, the user agent MUST process the cookie as follows:</p></div><div id="rfc.section.5.4.p.3"><ol><li>A user agent MAY ignore a received cookie in its entirety. For example, the user agent might wish to block receiving cookies from “third-party” responses or the user agent might not wish to store cookies that exceed some size.</li><li>Create a new cookie with name cookie-name, value cookie-value. Set the creation-time and the last-access-time to the current date and time.</li><li>If the cookie-attribute-list contains an attribute with an attribute-name of “Max-Age”: <ol><li>Set the cookie’s persistent-flag to true.</li><li>Set the cookie’s expiry-time to attribute-value of the last attribute in the cookie-attribute-list with an attribute-name of “Max-Age”.</li></ol> Otherwise, if the cookie-attribute-list contains an attribute with an attribute-name of “Expires” (and does not contain an attribute with an attribute-name of “Max-Age”): <ol><li>Set the cookie’s persistent-flag to true.</li><li>Set the cookie’s expiry-time to attribute-value of the last attribute in the cookie-attribute-list with an attribute-name of “Expires”.</li></ol> Otherwise: <ol><li>Set the cookie’s persistent-flag to false.</li><li>Set the cookie’s expiry-time to the latest representable date.</li></ol></li><li>If the cookie-attribute-list contains an attribute with an attribute-name of “Domain”: <ol><li>Let the domain-attribute be the attribute-value of the last attribute in the cookie-attribute-list with an attribute-name of “Domain”.</li></ol> Otherwise: <ol><li>Let the domain-attribute be the empty string.</li></ol></li><li>If the user agent is configured to reject “public suffixes” and the domain-attribute is a public suffix: <ol><li>If the domain-attribute is identical to the canonicalized request-host: <ol><li>Let the domain-attribute be the empty string.</li></ol> Otherwise: <ol><li>Ignore the cookie entirely and abort these steps.</li></ol></li></ol> NOTE: A “public suffix” is a domain that is controlled by a public registry, such as “com”, “co.uk”, and “pvt.k12.wy.us”. This step is essential for preventing attacker.com from disrupting the integrity of example.com by setting a cookie with a Domain attribute of “com”. Unfortunately, the set of public suffixes (also known as “registry controlled domains”) changes over time. If feasible, user agents SHOULD use an up-to-date public suffix list, such as the one maintained by the Mozilla project at <a href="http://publicsuffix.org/">http://publicsuffix.org/</a>.</li><li>If the domain-attribute is non-empty: <ol><li>If the canonicalized request-host does not domain-match the domain-attribute: <ol><li>Ignore the cookie entirely and abort these steps.</li></ol> Otherwise: <ol><li>Set the cookie’s host-only-flag to false.</li><li>Set the cookie’s domain to the domain-attribute.</li></ol></li></ol> Otherwise: <ol><li>Set the cookie’s host-only-flag to true.</li><li>Set the cookie’s domain to the canonicalized request-host.</li></ol></li><li>If the cookie-attribute-list contains an attribute with an attribute-name of “Path”, set the cookie’s path to attribute-value of the last attribute in the cookie-attribute-list with an attribute-name of “Path”. Otherwise, set the cookie’s path to the default-path of the request-uri.</li><li>If the cookie-attribute-list contains an attribute with an attribute-name of “Secure”, set the cookie’s secure-only-flag to true. Otherwise, set the cookie’s secure-only-flag to false.</li><li>If the scheme component of the request-uri does not denote a “secure” protocol (as defined by the user agent), and the cookie’s secure-only-flag is true, then abort these steps and ignore the cookie entirely.</li><li>If the cookie-attribute-list contains an attribute with an attribute-name of “HttpOnly”, set the cookie’s http-only-flag to true. Otherwise, set the cookie’s http-only-flag to false.</li><li>If the cookie was received from a “non-HTTP” API and the cookie’s http-only-flag is true, abort these steps and ignore the cookie entirely.</li><li>If the cookie’s secure-only-flag is not set, and the scheme component of request-uri does not denote a “secure” protocol, then abort these steps and ignore the cookie entirely if the cookie store contains one or more cookies that meet all of the following criteria: <ol><li>Their name matches the name of the newly-created cookie.</li><li>Their secure-only-flag is true.</li><li>Their domain domain-matches the domain of the newly-created cookie, or vice-versa.</li><li>The path of the newly-created cookie path-matches the path of the existing cookie.</li></ol> Note: The path comparison is not symmetric, ensuring only that a newly-created, non-secure cookie does not overlay an existing secure cookie, providing some mitigation against cookie-fixing attacks. That is, given an existing secure cookie named ‘a’ with a path of ‘/login’, a non-secure cookie named ‘a’ could be set for a path of ‘/’ or ‘/foo’, but not for a path of ‘/login’ or ‘/login/en’.</li><li>If the cookie-attribute-list contains an attribute with an attribute-name of “SameSite”, set the cookie’s same-site-flag to attribute-value (i.e. either “Strict” or “Lax”). Otherwise, set the cookie’s same-site-flag to “None”.</li><li>If the cookie’s <span class="tt">same-site-flag</span> is not “None”, and the cookie is being set from a context whose “site for cookies” is not an exact match for request-uri’s host’s registered domain, then abort these steps and ignore the newly created cookie entirely.</li><li>If the cookie-name begins with a case-sensitive match for the string “__Secure-“, abort these steps and ignore the cookie entirely unless the cookie’s secure-only-flag is true.</li><li>If the cookie-name begins with a case-sensitive match for the string “__Host-“, abort these steps and ignore the cookie entirely unless the cookie meets all the following criteria: <ol><li>The cookie’s secure-only-flag is true.</li><li>The cookie’s host-only-flag is true.</li><li>The cookie-attribute-list contains an attribute with an attribute-name of “Path”, and the cookie’s path is <span class="tt">/</span>.</li></ol></li><li>If the cookie store contains a cookie with the same name, domain, and path as the newly-created cookie: <ol><li>Let old-cookie be the existing cookie with the same name, domain, and path as the newly-created cookie. (Notice that this algorithm maintains the invariant that there is at most one such cookie.)</li><li>If the newly-created cookie was received from a “non-HTTP” API and the old-cookie’s http-only-flag is true, abort these steps and ignore the newly created cookie entirely.</li><li>Update the creation-time of the newly-created cookie to match the creation-time of the old-cookie.</li><li>Remove the old-cookie from the cookie store.</li></ol></li><li>Insert the newly-created cookie into the cookie store.</li></ol></div><div id="rfc.section.5.4.p.4"><p>A cookie is “expired” if the cookie has an expiry date in the past.</p></div><div id="rfc.section.5.4.p.5"><p>The user agent MUST evict all expired cookies from the cookie store if, at any time, an expired cookie exists in the cookie store.</p></div><div id="rfc.section.5.4.p.6"><p>At any time, the user agent MAY “remove excess cookies” from the cookie store if the number of cookies sharing a domain field exceeds some implementation-defined upper bound (such as 50 cookies).</p></div><div id="rfc.section.5.4.p.7"><p>At any time, the user agent MAY “remove excess cookies” from the cookie store if the cookie store exceeds some predetermined upper bound (such as 3000 cookies).</p></div><div id="rfc.section.5.4.p.8" class="avoidbreakafter"><p>When the user agent removes excess cookies from the cookie store, the user agent MUST evict cookies in the following priority order:</p></div><div id="rfc.section.5.4.p.9"><ol><li>Expired cookies.</li><li>Cookies whose secure-only-flag is not set, and which share a domain field with more than a predetermined number of other cookies.</li><li>Cookies that share a domain field with more than a predetermined number of other cookies.</li><li>All cookies.</li></ol></div><div id="rfc.section.5.4.p.10"><p>If two cookies have the same removal priority, the user agent MUST evict the cookie with the earliest last-access date first.</p></div><div id="rfc.section.5.4.p.11"><p>When “the current session is over” (as defined by the user agent), the user agent MUST remove from the cookie store all cookies with the persistent-flag set to false.</p></div></section><section id="cookie"><h3 id="rfc.section.5.5"><a href="#rfc.section.5.5">5.5.</a>&nbsp;<a href="#cookie">The Cookie Header</a></h3><div id="rfc.section.5.5.p.1"><p>The user agent includes stored cookies in the Cookie HTTP request header.</p></div><div id="rfc.section.5.5.p.2"><p>When the user agent generates an HTTP request, the user agent MUST NOT attach more than one Cookie header field.</p></div><div id="rfc.section.5.5.p.3"><p>A user agent MAY omit the Cookie header in its entirety. For example, the user agent might wish to block sending cookies during “third-party” requests from setting cookies (see <a href="#third-party-cookies" title="Third-Party Cookies">Section&nbsp;7.1</a>).</p></div><div id="rfc.section.5.5.p.4"><p>If the user agent does attach a Cookie header field to an HTTP request, the user agent MUST send the cookie-string (defined below) as the value of the header field.</p></div><div id="rfc.section.5.5.p.5" class="avoidbreakafter"><p>The user agent MUST use an algorithm equivalent to the following algorithm to compute the cookie-string from a cookie store and a request-uri:</p></div><div id="rfc.section.5.5.p.6"><ol><li>Let cookie-list be the set of cookies from the cookie store that meets all of the following requirements: <ul><li>Either: <ul><li>The cookie’s host-only-flag is true and the canonicalized request-host is identical to the cookie’s domain.</li></ul> Or: <ul><li>The cookie’s host-only-flag is false and the canonicalized request-host domain-matches the cookie’s domain.</li></ul></li><li>The request-uri’s path path-matches the cookie’s path.</li><li>If the cookie’s secure-only-flag is true, then the request-uri’s scheme must denote a “secure” protocol (as defined by the user agent). <br><br> NOTE: The notion of a “secure” protocol is not defined by this document. Typically, user agents consider a protocol secure if the protocol makes use of transport-layer security, such as SSL or TLS. For example, most user agents consider “https” to be a scheme that denotes a secure protocol.</li><li>If the cookie’s http-only-flag is true, then exclude the cookie if the cookie-string is being generated for a “non-HTTP” API (as defined by the user agent).</li><li>If the cookie’s same-site-flag is not “None”, and the HTTP request is cross-site (as defined in <a href="#same-site-requests" title="“Same-site” and “cross-site” Requests">Section&nbsp;5.2</a>) then exclude the cookie unless all of the following statements hold: <ol><li>The same-site-flag is “Lax”</li><li>The HTTP request’s method is “safe”.</li><li>The HTTP request’s target browsing context is a top-level browsing context.</li></ol></li></ul></li><li>The user agent SHOULD sort the cookie-list in the following order: <ul><li>Cookies with longer paths are listed before cookies with shorter paths.</li><li>Among cookies that have equal-length path fields, cookies with earlier creation-times are listed before cookies with later creation-times.</li></ul> NOTE: Not all user agents sort the cookie-list in this order, but this order reflects common practice when this document was written, and, historically, there have been servers that (erroneously) depended on this order.</li><li>Update the last-access-time of each cookie in the cookie-list to the current date and time.</li><li>Serialize the cookie-list into a cookie-string by processing each cookie in the cookie-list in order: <ol><li>Output the cookie’s name, the %x3D (“=”) character, and the cookie’s value.</li><li>If there is an unprocessed cookie in the cookie-list, output the characters %x3B and %x20 (“; “).</li></ol></li></ol></div><div id="rfc.section.5.5.p.7"><p>NOTE: Despite its name, the cookie-string is actually a sequence of octets, not a sequence of characters. To convert the cookie-string (or components thereof) into a sequence of characters (e.g., for presentation to the user), the user agent might wish to try using the UTF-8 character encoding <a href="#RFC3629"><cite title="UTF-8, a transformation format of ISO 10646">[RFC3629]</cite></a> to decode the octet sequence. This decoding might fail, however, because not every sequence of octets is valid UTF-8.</p></div></section></section><section id="implementation-considerations"><h2 id="rfc.section.6"><a href="#rfc.section.6">6.</a>&nbsp;<a href="#implementation-considerations">Implementation Considerations</a></h2><section id="limits"><h3 id="rfc.section.6.1"><a href="#rfc.section.6.1">6.1.</a>&nbsp;<a href="#limits">Limits</a></h3><div id="rfc.section.6.1.p.1" class="avoidbreakafter"><p>Practical user agent implementations have limits on the number and size of cookies that they can store. General-use user agents SHOULD provide each of the following minimum capabilities:</p></div><div id="rfc.section.6.1.p.2"><ul><li>At least 4096 bytes per cookie (as measured by the sum of the length of the cookie’s name, value, and attributes).</li><li>At least 50 cookies per domain.</li><li>At least 3000 cookies total.</li></ul></div><div id="rfc.section.6.1.p.3"><p>Servers SHOULD use as few and as small cookies as possible to avoid reaching these implementation limits and to minimize network bandwidth due to the Cookie header being included in every request.</p></div><div id="rfc.section.6.1.p.4"><p>Servers SHOULD gracefully degrade if the user agent fails to return one or more cookies in the Cookie header because the user agent might evict any cookie at any time on orders from the user.</p></div></section><section id="application-programming-interfaces"><h3 id="rfc.section.6.2"><a href="#rfc.section.6.2">6.2.</a>&nbsp;<a href="#application-programming-interfaces">Application Programming Interfaces</a></h3><div id="rfc.section.6.2.p.1"><p>One reason the Cookie and Set-Cookie headers use such esoteric syntax is that many platforms (both in servers and user agents) provide a string-based application programming interface (API) to cookies, requiring application-layer programmers to generate and parse the syntax used by the Cookie and Set-Cookie headers, which many programmers have done incorrectly, resulting in interoperability problems.</p></div><div id="rfc.section.6.2.p.2"><p>Instead of providing string-based APIs to cookies, platforms would be well-served by providing more semantic APIs. It is beyond the scope of this document to recommend specific API designs, but there are clear benefits to accepting an abstract “Date” object instead of a serialized date string.</p></div></section><section id="idna-migration"><h3 id="rfc.section.6.3"><a href="#rfc.section.6.3">6.3.</a>&nbsp;<a href="#idna-migration">IDNA Dependency and Migration</a></h3><div id="rfc.section.6.3.p.1"><p>IDNA2008 <a href="#RFC5890"><cite title="Internationalized Domain Names for Applications (IDNA): Definitions and Document Framework">[RFC5890]</cite></a> supersedes IDNA2003 <a href="#RFC3490"><cite title="Internationalizing Domain Names in Applications (IDNA)">[RFC3490]</cite></a>. However, there are differences between the two specifications, and thus there can be differences in processing (e.g., converting) domain name labels that have been registered under one from those registered under the other. There will be a transition period of some time during which IDNA2003-based domain name labels will exist in the wild. User agents SHOULD implement IDNA2008 <a href="#RFC5890"><cite title="Internationalized Domain Names for Applications (IDNA): Definitions and Document Framework">[RFC5890]</cite></a> and MAY implement <a href="#UTS46"><cite title="Unicode IDNA Compatibility Processing">[UTS46]</cite></a> or <a href="#RFC5895"><cite title="Mapping Characters for Internationalized Domain Names in Applications (IDNA) 2008">[RFC5895]</cite></a> in order to facilitate their IDNA transition. If a user agent does not implement IDNA2008, the user agent MUST implement IDNA2003 <a href="#RFC3490"><cite title="Internationalizing Domain Names in Applications (IDNA)">[RFC3490]</cite></a>.</p></div></section></section><section id="privacy-considerations"><h2 id="rfc.section.7"><a href="#rfc.section.7">7.</a>&nbsp;<a href="#privacy-considerations">Privacy Considerations</a></h2><div id="rfc.section.7.p.1"><p>Cookies are often criticized for letting servers track users. For example, a number of “web analytics” companies use cookies to recognize when a user returns to a web site or visits another web site. Although cookies are not the only mechanism servers can use to track users across HTTP requests, cookies facilitate tracking because they are persistent across user agent sessions and can be shared between hosts.</p></div><section id="third-party-cookies"><h3 id="rfc.section.7.1"><a href="#rfc.section.7.1">7.1.</a>&nbsp;<a href="#third-party-cookies">Third-Party Cookies</a></h3><div id="rfc.section.7.1.p.1"><p>Particularly worrisome are so-called “third-party” cookies. In rendering an HTML document, a user agent often requests resources from other servers (such as advertising networks). These third-party servers can use cookies to track the user even if the user never visits the server directly. For example, if a user visits a site that contains content from a third party and then later visits another site that contains content from the same third party, the third party can track the user between the two sites.</p></div><div id="rfc.section.7.1.p.2"><p>Given this risk to user privacy, some user agents restrict how third-party cookies behave, and those restrictions vary widly. For instance, user agents might block third-party cookies entirely by refusing to send Cookie headers or process Set-Cookie headers during third-party requests. They might take a less draconian approach by partitioning cookies based on the first-party context, sending one set of cookies to a given third party in one first-party context, and another to the same third party in another.</p></div><div id="rfc.section.7.1.p.3"><p>This document grants user agents wide latitude to experiment with third-party cookie policies that balance the privacy and compatibility needs of their users. However, this document does not endorse any particular third-party cookie policy.</p></div><div id="rfc.section.7.1.p.4"><p>Third-party cookie blocking policies are often ineffective at achieving their privacy goals if servers attempt to work around their restrictions to track users. In particular, two collaborating servers can often track users without using cookies at all by injecting identifying information into dynamic URLs.</p></div></section><section id="user-controls"><h3 id="rfc.section.7.2"><a href="#rfc.section.7.2">7.2.</a>&nbsp;<a href="#user-controls">User Controls</a></h3><div id="rfc.section.7.2.p.1"><p>User agents SHOULD provide users with a mechanism for managing the cookies stored in the cookie store. For example, a user agent might let users delete all cookies received during a specified time period or all the cookies related to a particular domain. In addition, many user agents include a user interface element that lets users examine the cookies stored in their cookie store.</p></div><div id="rfc.section.7.2.p.2"><p>User agents SHOULD provide users with a mechanism for disabling cookies. When cookies are disabled, the user agent MUST NOT include a Cookie header in outbound HTTP requests and the user agent MUST NOT process Set-Cookie headers in inbound HTTP responses.</p></div><div id="rfc.section.7.2.p.3"><p>Some user agents provide users the option of preventing persistent storage of cookies across sessions. When configured thusly, user agents MUST treat all received cookies as if the persistent-flag were set to false. Some popular user agents expose this functionality via “private browsing” mode <a href="#Aggarwal2010"><cite title="An Analysis of Private Browsing Modes in Modern Browsers">[Aggarwal2010]</cite></a>.</p></div><div id="rfc.section.7.2.p.4"><p>Some user agents provide users with the ability to approve individual writes to the cookie store. In many common usage scenarios, these controls generate a large number of prompts. However, some privacy-conscious users find these controls useful nonetheless.</p></div></section><section id="expiration-dates"><h3 id="rfc.section.7.3"><a href="#rfc.section.7.3">7.3.</a>&nbsp;<a href="#expiration-dates">Expiration Dates</a></h3><div id="rfc.section.7.3.p.1"><p>Although servers can set the expiration date for cookies to the distant future, most user agents do not actually retain cookies for multiple decades. Rather than choosing gratuitously long expiration periods, servers SHOULD promote user privacy by selecting reasonable cookie expiration periods based on the purpose of the cookie. For example, a typical session identifier might reasonably be set to expire in two weeks.</p></div></section></section><section id="security-considerations"><h2 id="rfc.section.8"><a href="#rfc.section.8">8.</a>&nbsp;<a href="#security-considerations">Security Considerations</a></h2><section id="overview-1"><h3 id="rfc.section.8.1"><a href="#rfc.section.8.1">8.1.</a>&nbsp;<a href="#overview-1">Overview</a></h3><div id="rfc.section.8.1.p.1"><p>Cookies have a number of security pitfalls. This section overviews a few of the more salient issues.</p></div><div id="rfc.section.8.1.p.2"><p>In particular, cookies encourage developers to rely on ambient authority for authentication, often becoming vulnerable to attacks such as cross-site request forgery <a href="#CSRF"><cite title="Robust Defenses for Cross-Site Request Forgery">[CSRF]</cite></a>. Also, when storing session identifiers in cookies, developers often create session fixation vulnerabilities.</p></div><div id="rfc.section.8.1.p.3"><p>Transport-layer encryption, such as that employed in HTTPS, is insufficient to prevent a network attacker from obtaining or altering a victim’s cookies because the cookie protocol itself has various vulnerabilities (see “Weak Confidentiality” and “Weak Integrity”, below). In addition, by default, cookies do not provide confidentiality or integrity from network attackers, even when used in conjunction with HTTPS.</p></div></section><section id="ambient-authority"><h3 id="rfc.section.8.2"><a href="#rfc.section.8.2">8.2.</a>&nbsp;<a href="#ambient-authority">Ambient Authority</a></h3><div id="rfc.section.8.2.p.1"><p>A server that uses cookies to authenticate users can suffer security vulnerabilities because some user agents let remote parties issue HTTP requests from the user agent (e.g., via HTTP redirects or HTML forms). When issuing those requests, user agents attach cookies even if the remote party does not know the contents of the cookies, potentially letting the remote party exercise authority at an unwary server.</p></div><div id="rfc.section.8.2.p.2"><p>Although this security concern goes by a number of names (e.g., cross-site request forgery, confused deputy), the issue stems from cookies being a form of ambient authority. Cookies encourage server operators to separate designation (in the form of URLs) from authorization (in the form of cookies). Consequently, the user agent might supply the authorization for a resource designated by the attacker, possibly causing the server or its clients to undertake actions designated by the attacker as though they were authorized by the user.</p></div><div id="rfc.section.8.2.p.3"><p>Instead of using cookies for authorization, server operators might wish to consider entangling designation and authorization by treating URLs as capabilities. Instead of storing secrets in cookies, this approach stores secrets in URLs, requiring the remote entity to supply the secret itself. Although this approach is not a panacea, judicious application of these principles can lead to more robust security.</p></div></section><section id="clear-text"><h3 id="rfc.section.8.3"><a href="#rfc.section.8.3">8.3.</a>&nbsp;<a href="#clear-text">Clear Text</a></h3><div id="rfc.section.8.3.p.1"><p>Unless sent over a secure channel (such as TLS), the information in the Cookie and Set-Cookie headers is transmitted in the clear.</p></div><div id="rfc.section.8.3.p.2"><ol><li>All sensitive information conveyed in these headers is exposed to an eavesdropper.</li><li>A malicious intermediary could alter the headers as they travel in either direction, with unpredictable results.</li><li>A malicious client could alter the Cookie header before transmission, with unpredictable results.</li></ol></div><div id="rfc.section.8.3.p.3"><p>Servers SHOULD encrypt and sign the contents of cookies (using whatever format the server desires) when transmitting them to the user agent (even when sending the cookies over a secure channel). However, encrypting and signing cookie contents does not prevent an attacker from transplanting a cookie from one user agent to another or from replaying the cookie at a later time.</p></div><div id="rfc.section.8.3.p.4"><p>In addition to encrypting and signing the contents of every cookie, servers that require a higher level of security SHOULD use the Cookie and Set-Cookie headers only over a secure channel. When using cookies over a secure channel, servers SHOULD set the Secure attribute (see <a href="#sane-secure" title="The Secure Attribute">Section&nbsp;4.1.2.5</a>) for every cookie. If a server does not set the Secure attribute, the protection provided by the secure channel will be largely moot.</p></div><div id="rfc.section.8.3.p.5"><p>For example, consider a webmail server that stores a session identifier in a cookie and is typically accessed over HTTPS. If the server does not set the Secure attribute on its cookies, an active network attacker can intercept any outbound HTTP request from the user agent and redirect that request to the webmail server over HTTP. Even if the webmail server is not listening for HTTP connections, the user agent will still include cookies in the request. The active network attacker can intercept these cookies, replay them against the server, and learn the contents of the user’s email. If, instead, the server had set the Secure attribute on its cookies, the user agent would not have included the cookies in the clear-text request.</p></div></section><section id="session-identifiers"><h3 id="rfc.section.8.4"><a href="#rfc.section.8.4">8.4.</a>&nbsp;<a href="#session-identifiers">Session Identifiers</a></h3><div id="rfc.section.8.4.p.1"><p>Instead of storing session information directly in a cookie (where it might be exposed to or replayed by an attacker), servers commonly store a nonce (or “session identifier”) in a cookie. When the server receives an HTTP request with a nonce, the server can look up state information associated with the cookie using the nonce as a key.</p></div><div id="rfc.section.8.4.p.2"><p>Using session identifier cookies limits the damage an attacker can cause if the attacker learns the contents of a cookie because the nonce is useful only for interacting with the server (unlike non-nonce cookie content, which might itself be sensitive). Furthermore, using a single nonce prevents an attacker from “splicing” together cookie content from two interactions with the server, which could cause the server to behave unexpectedly.</p></div><div id="rfc.section.8.4.p.3"><p>Using session identifiers is not without risk. For example, the server SHOULD take care to avoid “session fixation” vulnerabilities. A session fixation attack proceeds in three steps. First, the attacker transplants a session identifier from his or her user agent to the victim’s user agent. Second, the victim uses that session identifier to interact with the server, possibly imbuing the session identifier with the user’s credentials or confidential information. Third, the attacker uses the session identifier to interact with server directly, possibly obtaining the user’s authority or confidential information.</p></div></section><section id="weak-confidentiality"><h3 id="rfc.section.8.5"><a href="#rfc.section.8.5">8.5.</a>&nbsp;<a href="#weak-confidentiality">Weak Confidentiality</a></h3><div id="rfc.section.8.5.p.1"><p>Cookies do not provide isolation by port. If a cookie is readable by a service running on one port, the cookie is also readable by a service running on another port of the same server. If a cookie is writable by a service on one port, the cookie is also writable by a service running on another port of the same server. For this reason, servers SHOULD NOT both run mutually distrusting services on different ports of the same host and use cookies to store security-sensitive information.</p></div><div id="rfc.section.8.5.p.2"><p>Cookies do not provide isolation by scheme. Although most commonly used with the http and https schemes, the cookies for a given host might also be available to other schemes, such as ftp and gopher. Although this lack of isolation by scheme is most apparent in non-HTTP APIs that permit access to cookies (e.g., HTML’s document.cookie API), the lack of isolation by scheme is actually present in requirements for processing cookies themselves (e.g., consider retrieving a URI with the gopher scheme via HTTP).</p></div><div id="rfc.section.8.5.p.3"><p>Cookies do not always provide isolation by path. Although the network-level protocol does not send cookies stored for one path to another, some user agents expose cookies via non-HTTP APIs, such as HTML’s document.cookie API. Because some of these user agents (e.g., web browsers) do not isolate resources received from different paths, a resource retrieved from one path might be able to access cookies stored for another path.</p></div></section><section id="weak-integrity"><h3 id="rfc.section.8.6"><a href="#rfc.section.8.6">8.6.</a>&nbsp;<a href="#weak-integrity">Weak Integrity</a></h3><div id="rfc.section.8.6.p.1"><p>Cookies do not provide integrity guarantees for sibling domains (and their subdomains). For example, consider foo.example.com and bar.example.com. The foo.example.com server can set a cookie with a Domain attribute of “example.com” (possibly overwriting an existing “example.com” cookie set by bar.example.com), and the user agent will include that cookie in HTTP requests to bar.example.com. In the worst case, bar.example.com will be unable to distinguish this cookie from a cookie it set itself. The foo.example.com server might be able to leverage this ability to mount an attack against bar.example.com.</p></div><div id="rfc.section.8.6.p.2"><p>Even though the Set-Cookie header supports the Path attribute, the Path attribute does not provide any integrity protection because the user agent will accept an arbitrary Path attribute in a Set-Cookie header. For example, an HTTP response to a request for http://example.com/foo/bar can set a cookie with a Path attribute of “/qux”. Consequently, servers SHOULD NOT both run mutually distrusting services on different paths of the same host and use cookies to store security-sensitive information.</p></div><div id="rfc.section.8.6.p.3"><p>An active network attacker can also inject cookies into the Cookie header sent to https://example.com/ by impersonating a response from http://example.com/ and injecting a Set-Cookie header. The HTTPS server at example.com will be unable to distinguish these cookies from cookies that it set itself in an HTTPS response. An active network attacker might be able to leverage this ability to mount an attack against example.com even if example.com uses HTTPS exclusively.</p></div><div id="rfc.section.8.6.p.4"><p>Servers can partially mitigate these attacks by encrypting and signing the contents of their cookies. However, using cryptography does not mitigate the issue completely because an attacker can replay a cookie he or she received from the authentic example.com server in the user’s session, with unpredictable results.</p></div><div id="rfc.section.8.6.p.5"><p>Finally, an attacker might be able to force the user agent to delete cookies by storing a large number of cookies. Once the user agent reaches its storage limit, the user agent will be forced to evict some cookies. Servers SHOULD NOT rely upon user agents retaining cookies.</p></div></section><section id="reliance-on-dns"><h3 id="rfc.section.8.7"><a href="#rfc.section.8.7">8.7.</a>&nbsp;<a href="#reliance-on-dns">Reliance on DNS</a></h3><div id="rfc.section.8.7.p.1"><p>Cookies rely upon the Domain Name System (DNS) for security. If the DNS is partially or fully compromised, the cookie protocol might fail to provide the security properties required by applications.</p></div></section><section id="samesite-cookies"><h3 id="rfc.section.8.8"><a href="#rfc.section.8.8">8.8.</a>&nbsp;<a href="#samesite-cookies">SameSite Cookies</a></h3><section id="defense-in-depth"><h4 id="rfc.section.8.8.1"><a href="#rfc.section.8.8.1">8.8.1.</a>&nbsp;<a href="#defense-in-depth">Defense in depth</a></h4><div id="rfc.section.8.8.1.p.1"><p>“SameSite” cookies offer a robust defense against CSRF attack when deployed in strict mode, and when supported by the client. It is, however, prudent to ensure that this designation is not the extent of a site’s defense against CSRF, as same-site navigations and submissions can certainly be executed in conjunction with other attack vectors such as cross-site scripting.</p></div><div id="rfc.section.8.8.1.p.2"><p>Developers are strongly encouraged to deploy the usual server-side defenses (CSRF tokens, ensuring that “safe” HTTP methods are idempotent, etc) to mitigate the risk more fully.</p></div><div id="rfc.section.8.8.1.p.3"><p>Additionally, client-side techniques such as those described in <a href="#app-isolation"><cite title="App Isolation - Get the Security of Multiple Browsers with Just One">[app-isolation]</cite></a> may also prove effective against CSRF, and are certainly worth exploring in combination with “SameSite” cookies.</p></div></section><section id="top-level-navigations"><h4 id="rfc.section.8.8.2"><a href="#rfc.section.8.8.2">8.8.2.</a>&nbsp;<a href="#top-level-navigations">Top-level Navigations</a></h4><div id="rfc.section.8.8.2.p.1"><p>Setting the <span class="tt">SameSite</span> attribute in “strict” mode provides robust defense in depth against CSRF attacks, but has the potential to confuse users unless sites’ developers carefully ensure that their cookie-based session management systems deal reasonably well with top-level navigations.</p></div><div id="rfc.section.8.8.2.p.2"><p>Consider the scenario in which a user reads their email at MegaCorp Inc’s webmail provider <span class="tt">https://example.com/</span>. They might expect that clicking on an emailed link to <span class="tt">https://projects.com/secret/project</span> would show them the secret project that they’re authorized to see, but if <span class="tt">projects.com</span> has marked their session cookies as <span class="tt">SameSite</span>, then this cross-site navigation won’t send them along with the request. <span class="tt">projects.com</span> will render a 404 error to avoid leaking secret information, and the user will be quite confused.</p></div><div id="rfc.section.8.8.2.p.3"><p>Developers can avoid this confusion by adopting a session management system that relies on not one, but two cookies: one conceptually granting “read” access, another granting “write” access. The latter could be marked as <span class="tt">SameSite</span>, and its absence would prompt a reauthentication step before executing any non-idempotent action. The former could drop the <span class="tt">SameSite</span> attribute entirely, or choose the “Lax” version of enforcement, in order to allow users access to data via top-level navigation.</p></div></section><section id="mashups-and-widgets"><h4 id="rfc.section.8.8.3"><a href="#rfc.section.8.8.3">8.8.3.</a>&nbsp;<a href="#mashups-and-widgets">Mashups and Widgets</a></h4><div id="rfc.section.8.8.3.p.1"><p>The <span class="tt">SameSite</span> attribute is inappropriate for some important use-cases. In particular, note that content intended for embedding in a cross-site contexts (social networking widgets or commenting services, for instance) will not have access to same-site cookies. Cookies may be required for requests triggered in these cross-site contexts in order to provide seamless functionality that relies on a user’s state.</p></div><div id="rfc.section.8.8.3.p.2"><p>Likewise, some forms of Single-Sign-On might require cookie-based authentication in a cross-site context; these mechanisms will not function as intended with same-site cookies.</p></div></section><section id="server-controlled"><h4 id="rfc.section.8.8.4"><a href="#rfc.section.8.8.4">8.8.4.</a>&nbsp;<a href="#server-controlled">Server-controlled</a></h4><div id="rfc.section.8.8.4.p.1"><p>SameSite cookies in and of themselves don’t do anything to address the general privacy concerns outlined in Section 7.1 of <a href="#RFC6265"><cite title="HTTP State Management Mechanism">[RFC6265]</cite></a>. The “SameSite” attribute is set by the server, and serves to mitigate the risk of certain kinds of attacks that the server is worried about. The user is not involved in this decision. Moreover, a number of side-channels exist which could allow a server to link distinct requests even in the absence of cookies. Connection and/or socket pooling, Token Binding, and Channel ID all offer explicit methods of identification that servers could take advantage of.</p></div></section></section></section><section id="iana-considerations"><h2 id="rfc.section.9"><a href="#rfc.section.9">9.</a>&nbsp;<a href="#iana-considerations">IANA Considerations</a></h2><div id="rfc.section.9.p.1"><p>The permanent message header field registry (see <a href="#RFC3864"><cite title="Registration Procedures for Message Header Fields">[RFC3864]</cite></a>) needs to be updated with the following registrations.</p></div><section id="iana-cookie"><h3 id="rfc.section.9.1"><a href="#rfc.section.9.1">9.1.</a>&nbsp;<a href="#iana-cookie">Cookie</a></h3><div id="rfc.section.9.1.p.1"><dl class="compact"><dt>Header field name:</dt><dd>Cookie</dd><dt>Applicable protocol:</dt><dd>http</dd><dt>Status:</dt><dd>standard</dd><dt>Author/Change controller:</dt><dd>IETF</dd><dt>Specification document:</dt><dd>this specification (<a href="#cookie" title="The Cookie Header">Section&nbsp;5.5</a>)</dd></dl></div></section><section id="iana-set-cookie"><h3 id="rfc.section.9.2"><a href="#rfc.section.9.2">9.2.</a>&nbsp;<a href="#iana-set-cookie">Set-Cookie</a></h3><div id="rfc.section.9.2.p.1"><dl class="compact"><dt>Header field name:</dt><dd>Set-Cookie</dd><dt>Applicable protocol:</dt><dd>http</dd><dt>Status:</dt><dd>standard</dd><dt>Author/Change controller:</dt><dd>IETF</dd><dt>Specification document:</dt><dd>this specification (<a href="#set-cookie" title="The Set-Cookie Header">Section&nbsp;5.3</a>)</dd></dl></div></section></section><section id="rfc.references"><h2 id="rfc.section.10"><a href="#rfc.section.10">10.</a> References</h2><section id="rfc.references.1"><h3 id="rfc.section.10.1"><a href="#rfc.section.10.1">10.1.</a> Normative References</h3><dl class="dl-horizontal"><dt id="FETCH">[FETCH]</dt><dd>van Kesteren, A., “<a href="https://fetch.spec.whatwg.org/">Fetch</a>”, n.d., &lt;<a href="https://fetch.spec.whatwg.org/">https://fetch.spec.whatwg.org/</a>&gt;.</dd><dt id="HTML">[HTML]</dt><dd>Hickson, I., Pieters, S., van Kesteren, A., Jägenstedt, P., and D. Denicola, “<a href="https://html.spec.whatwg.org/">HTML</a>”, n.d., &lt;<a href="https://html.spec.whatwg.org/">https://html.spec.whatwg.org/</a>&gt;.</dd><dt id="PSL">[PSL]</dt><dd>“<a href="https://publicsuffix.org/list/">Public Suffix List</a>”, n.d., &lt;<a href="https://publicsuffix.org/list/">https://publicsuffix.org/list/</a>&gt;.</dd><dt id="RFC1034">[RFC1034]</dt><dd>Mockapetris, P., “<a href="https://tools.ietf.org/html/rfc1034">Domain names - concepts and facilities</a>”, STD&nbsp;13, RFC&nbsp;1034, <a href="http://dx.doi.org/10.17487/RFC1034">DOI&nbsp;10.17487/RFC1034</a>, November&nbsp;1987, &lt;<a href="https://www.rfc-editor.org/info/rfc1034">https://www.rfc-editor.org/info/rfc1034</a>&gt;.</dd><dt id="RFC1123">[RFC1123]</dt><dd>Braden, R., Ed., “<a href="https://tools.ietf.org/html/rfc1123">Requirements for Internet Hosts - Application and Support</a>”, STD&nbsp;3, RFC&nbsp;1123, <a href="http://dx.doi.org/10.17487/RFC1123">DOI&nbsp;10.17487/RFC1123</a>, October&nbsp;1989, &lt;<a href="https://www.rfc-editor.org/info/rfc1123">https://www.rfc-editor.org/info/rfc1123</a>&gt;.</dd><dt id="RFC2119">[RFC2119]</dt><dd>Bradner, S., “<a href="https://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>”, BCP&nbsp;14, RFC&nbsp;2119, <a href="http://dx.doi.org/10.17487/RFC2119">DOI&nbsp;10.17487/RFC2119</a>, March&nbsp;1997, &lt;<a href="https://www.rfc-editor.org/info/rfc2119">https://www.rfc-editor.org/info/rfc2119</a>&gt;.</dd><dt id="RFC2616">[RFC2616]</dt><dd>Fielding, R., Gettys, J., Mogul, J., Frystyk, H., Masinter, L., Leach, P., and T. Berners-Lee, “<a href="https://tools.ietf.org/html/rfc2616">Hypertext Transfer Protocol -- HTTP/1.1</a>”, RFC&nbsp;2616, <a href="http://dx.doi.org/10.17487/RFC2616">DOI&nbsp;10.17487/RFC2616</a>, June&nbsp;1999, &lt;<a href="https://www.rfc-editor.org/info/rfc2616">https://www.rfc-editor.org/info/rfc2616</a>&gt;.</dd><dt id="RFC3490">[RFC3490]</dt><dd>Costello, A., “<a href="https://tools.ietf.org/html/rfc3490">Internationalizing Domain Names in Applications (IDNA)</a>”, RFC&nbsp;3490, <a href="http://dx.doi.org/10.17487/RFC3490">DOI&nbsp;10.17487/RFC3490</a>, March&nbsp;2003, &lt;<a href="https://www.rfc-editor.org/info/rfc3490">https://www.rfc-editor.org/info/rfc3490</a>&gt;.<br>See <a href="#idna-migration" title="IDNA Dependency and Migration">Section&nbsp;6.3</a> for an explanation why the normative reference to an obsoleted specification is needed.</dd><dt id="RFC4790">[RFC4790]</dt><dd>Newman, C., Duerst, M., and A. Gulbrandsen, “<a href="https://tools.ietf.org/html/rfc4790">Internet Application Protocol Collation Registry</a>”, RFC&nbsp;4790, <a href="http://dx.doi.org/10.17487/RFC4790">DOI&nbsp;10.17487/RFC4790</a>, March&nbsp;2007, &lt;<a href="https://www.rfc-editor.org/info/rfc4790">https://www.rfc-editor.org/info/rfc4790</a>&gt;.</dd><dt id="RFC5234">[RFC5234]</dt><dd>Crocker, D., Ed. and P. Overell, “<a href="https://tools.ietf.org/html/rfc5234">Augmented BNF for Syntax Specifications: ABNF</a>”, STD&nbsp;68, RFC&nbsp;5234, <a href="http://dx.doi.org/10.17487/RFC5234">DOI&nbsp;10.17487/RFC5234</a>, January&nbsp;2008, &lt;<a href="https://www.rfc-editor.org/info/rfc5234">https://www.rfc-editor.org/info/rfc5234</a>&gt;.</dd><dt id="RFC5890">[RFC5890]</dt><dd>Klensin, J., “<a href="https://tools.ietf.org/html/rfc5890">Internationalized Domain Names for Applications (IDNA): Definitions and Document Framework</a>”, RFC&nbsp;5890, <a href="http://dx.doi.org/10.17487/RFC5890">DOI&nbsp;10.17487/RFC5890</a>, August&nbsp;2010, &lt;<a href="https://www.rfc-editor.org/info/rfc5890">https://www.rfc-editor.org/info/rfc5890</a>&gt;.</dd><dt id="RFC6454">[RFC6454]</dt><dd>Barth, A., “<a href="https://tools.ietf.org/html/rfc6454">The Web Origin Concept</a>”, RFC&nbsp;6454, <a href="http://dx.doi.org/10.17487/RFC6454">DOI&nbsp;10.17487/RFC6454</a>, December&nbsp;2011, &lt;<a href="https://www.rfc-editor.org/info/rfc6454">https://www.rfc-editor.org/info/rfc6454</a>&gt;.</dd><dt id="RFC7231">[RFC7231]</dt><dd>Fielding, R., Ed. and J. Reschke, Ed., “<a href="https://tools.ietf.org/html/rfc7231">Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content</a>”, RFC&nbsp;7231, <a href="http://dx.doi.org/10.17487/RFC7231">DOI&nbsp;10.17487/RFC7231</a>, June&nbsp;2014, &lt;<a href="https://www.rfc-editor.org/info/rfc7231">https://www.rfc-editor.org/info/rfc7231</a>&gt;.</dd><dt id="SERVICE-WORKERS">[SERVICE-WORKERS]</dt><dd>Russell, A., Song, J., and J. Archibald, “<a href="http://www.w3.org/TR/service-workers/">Service Workers</a>”, n.d., &lt;<a href="http://www.w3.org/TR/service-workers/">http://www.w3.org/TR/service-workers/</a>&gt;.</dd><dt id="USASCII">[USASCII]</dt><dd>American National Standards Institute, “Coded Character Set -- 7-bit American Standard Code for Information Interchange”, ANSI&nbsp;X3.4, 1986.</dd></dl></section><section id="rfc.references.2"><h3 id="rfc.section.10.2"><a href="#rfc.section.10.2">10.2.</a> Informative References</h3><dl class="dl-horizontal"><dt id="Aggarwal2010">[Aggarwal2010]</dt><dd>Aggarwal, G., Burzstein, E., Jackson, C., and D. Boneh, “<a href="http://www.usenix.org/events/sec10/tech/full_papers/Aggarwal.pdf">An Analysis of Private Browsing Modes in Modern Browsers</a>”, 2010, &lt;<a href="http://www.usenix.org/events/sec10/tech/full_papers/Aggarwal.pdf">http://www.usenix.org/events/sec10/tech/full_papers/Aggarwal.pdf</a>&gt;.</dd><dt id="CSRF">[CSRF]</dt><dd>Barth, A., Jackson, C., and J. Mitchell, “<a href="http://portal.acm.org/citation.cfm?id=1455770.1455782">Robust Defenses for Cross-Site Request Forgery</a>”, <a href="http://dx.doi.org/10.1145/1455770.1455782">DOI&nbsp;10.1145/1455770.1455782</a>, <a href="https://www.worldcat.org/search?q=isbn:9781595938107">ISBN&nbsp;978-1-59593-810-7</a>, ACM&nbsp;CCS '08: Proceedings of the 15th ACM conference on Computer and communications security (pages 75-88), October&nbsp;2008, &lt;<a href="http://portal.acm.org/citation.cfm?id=1455770.1455782">http://portal.acm.org/citation.cfm?id=1455770.1455782</a>&gt;.</dd><dt id="I-D.ietf-httpbis-cookie-alone">[I-D.ietf-httpbis-cookie-alone]</dt><dd>West, M., “<a href="https://tools.ietf.org/html/draft-ietf-httpbis-cookie-alone-01">Deprecate modification of 'secure' cookies from non-secure origins</a>”, Internet-Draft&nbsp;draft-ietf-httpbis-cookie-alone-01 (work in progress), September&nbsp;2016.</dd><dt id="I-D.ietf-httpbis-cookie-prefixes">[I-D.ietf-httpbis-cookie-prefixes]</dt><dd>West, M., “<a href="https://tools.ietf.org/html/draft-ietf-httpbis-cookie-prefixes-00">Cookie Prefixes</a>”, Internet-Draft&nbsp;draft-ietf-httpbis-cookie-prefixes-00 (work in progress), February&nbsp;2016.</dd><dt id="I-D.ietf-httpbis-cookie-same-site">[I-D.ietf-httpbis-cookie-same-site]</dt><dd>West, M. and M. Goodwin, “<a href="https://tools.ietf.org/html/draft-ietf-httpbis-cookie-same-site-00">Same-Site Cookies</a>”, Internet-Draft&nbsp;draft-ietf-httpbis-cookie-same-site-00 (work in progress), June&nbsp;2016.</dd><dt id="RFC2818">[RFC2818]</dt><dd>Rescorla, E., “<a href="https://tools.ietf.org/html/rfc2818">HTTP Over TLS</a>”, RFC&nbsp;2818, <a href="http://dx.doi.org/10.17487/RFC2818">DOI&nbsp;10.17487/RFC2818</a>, May&nbsp;2000, &lt;<a href="https://www.rfc-editor.org/info/rfc2818">https://www.rfc-editor.org/info/rfc2818</a>&gt;.</dd><dt id="RFC3629">[RFC3629]</dt><dd>Yergeau, F., “<a href="https://tools.ietf.org/html/rfc3629">UTF-8, a transformation format of ISO 10646</a>”, STD&nbsp;63, RFC&nbsp;3629, <a href="http://dx.doi.org/10.17487/RFC3629">DOI&nbsp;10.17487/RFC3629</a>, November&nbsp;2003, &lt;<a href="https://www.rfc-editor.org/info/rfc3629">https://www.rfc-editor.org/info/rfc3629</a>&gt;.</dd><dt id="RFC3864">[RFC3864]</dt><dd>Klyne, G., Nottingham, M., and J. Mogul, “<a href="https://tools.ietf.org/html/rfc3864">Registration Procedures for Message Header Fields</a>”, BCP&nbsp;90, RFC&nbsp;3864, <a href="http://dx.doi.org/10.17487/RFC3864">DOI&nbsp;10.17487/RFC3864</a>, September&nbsp;2004, &lt;<a href="https://www.rfc-editor.org/info/rfc3864">https://www.rfc-editor.org/info/rfc3864</a>&gt;.</dd><dt id="RFC3986">[RFC3986]</dt><dd>Berners-Lee, T., Fielding, R., and L. Masinter, “<a href="https://tools.ietf.org/html/rfc3986">Uniform Resource Identifier (URI): Generic Syntax</a>”, STD&nbsp;66, RFC&nbsp;3986, <a href="http://dx.doi.org/10.17487/RFC3986">DOI&nbsp;10.17487/RFC3986</a>, January&nbsp;2005, &lt;<a href="https://www.rfc-editor.org/info/rfc3986">https://www.rfc-editor.org/info/rfc3986</a>&gt;.</dd><dt id="RFC4648">[RFC4648]</dt><dd>Josefsson, S., “<a href="https://tools.ietf.org/html/rfc4648">The Base16, Base32, and Base64 Data Encodings</a>”, RFC&nbsp;4648, <a href="http://dx.doi.org/10.17487/RFC4648">DOI&nbsp;10.17487/RFC4648</a>, October&nbsp;2006, &lt;<a href="https://www.rfc-editor.org/info/rfc4648">https://www.rfc-editor.org/info/rfc4648</a>&gt;.</dd><dt id="RFC5895">[RFC5895]</dt><dd>Resnick, P. and P. Hoffman, “<a href="https://tools.ietf.org/html/rfc5895">Mapping Characters for Internationalized Domain Names in Applications (IDNA) 2008</a>”, RFC&nbsp;5895, <a href="http://dx.doi.org/10.17487/RFC5895">DOI&nbsp;10.17487/RFC5895</a>, September&nbsp;2010, &lt;<a href="https://www.rfc-editor.org/info/rfc5895">https://www.rfc-editor.org/info/rfc5895</a>&gt;.</dd><dt id="RFC6265">[RFC6265]</dt><dd>Barth, A., “<a href="https://tools.ietf.org/html/rfc6265">HTTP State Management Mechanism</a>”, RFC&nbsp;6265, <a href="http://dx.doi.org/10.17487/RFC6265">DOI&nbsp;10.17487/RFC6265</a>, April&nbsp;2011, &lt;<a href="https://www.rfc-editor.org/info/rfc6265">https://www.rfc-editor.org/info/rfc6265</a>&gt;.</dd><dt id="RFC7034">[RFC7034]</dt><dd>Ross, D. and T. Gondrom, “<a href="https://tools.ietf.org/html/rfc7034">HTTP Header Field X-Frame-Options</a>”, RFC&nbsp;7034, <a href="http://dx.doi.org/10.17487/RFC7034">DOI&nbsp;10.17487/RFC7034</a>, October&nbsp;2013, &lt;<a href="https://www.rfc-editor.org/info/rfc7034">https://www.rfc-editor.org/info/rfc7034</a>&gt;.</dd><dt id="UTS46">[UTS46]</dt><dd>Davis, M. and M. Suignard, “<a href="http://unicode.org/reports/tr46/">Unicode IDNA Compatibility Processing</a>”, UNICODE&nbsp;Unicode Technical Standards # 46, June&nbsp;2016, &lt;<a href="http://unicode.org/reports/tr46/">http://unicode.org/reports/tr46/</a>&gt;.</dd><dt id="app-isolation">[app-isolation]</dt><dd>Chen, E., Bau, J., Reis, C., Barth, A., and C. Jackson, “<a href="http://www.collinjackson.com/research/papers/appisolation.pdf">App Isolation - Get the Security of Multiple Browsers with Just One</a>”, 2011, &lt;<a href="http://www.collinjackson.com/research/papers/appisolation.pdf">http://www.collinjackson.com/research/papers/appisolation.pdf</a>&gt;.</dd><dt id="prerendering">[prerendering]</dt><dd>Bentzel, C., “<a href="https://www.chromium.org/developers/design-documents/prerender">Chrome Prerendering</a>”, n.d., &lt;<a href="https://www.chromium.org/developers/design-documents/prerender">https://www.chromium.org/developers/design-documents/prerender</a>&gt;.</dd></dl></section></section><section id="changes"><h2 id="rfc.section.A" class="np"><a href="#rfc.section.A">A.</a>&nbsp;<a href="#changes">Changes</a></h2><section id="draft-ietf-httpbis-rfc6265bis-00"><h3 id="rfc.section.A.1"><a href="#rfc.section.A.1">A.1.</a>&nbsp;<a href="#draft-ietf-httpbis-rfc6265bis-00">draft-ietf-httpbis-rfc6265bis-00</a></h3><div id="rfc.section.A.1.p.1"><ul><li>Port <a href="#RFC6265"><cite title="HTTP State Management Mechanism">[RFC6265]</cite></a> to Markdown. No (intentional) normative changes.</li></ul></div></section><section id="draft-ietf-httpbis-rfc6265bis-01"><h3 id="rfc.section.A.2"><a href="#rfc.section.A.2">A.2.</a>&nbsp;<a href="#draft-ietf-httpbis-rfc6265bis-01">draft-ietf-httpbis-rfc6265bis-01</a></h3><div id="rfc.section.A.2.p.1"><ul><li>Fixes to formatting caused by mistakes in the initial port to Markdown: <ul><li><a href="https://github.com/httpwg/http-extensions/issues/243">https://github.com/httpwg/http-extensions/issues/243</a></li><li><a href="https://github.com/httpwg/http-extensions/issues/246">https://github.com/httpwg/http-extensions/issues/246</a></li></ul></li><li>Addresses errata 3444 by updating the <span class="tt">path-value</span> and <span class="tt">extension-av</span> grammar, errata 4148 by updating the <span class="tt">day-of-month</span>, <span class="tt">year</span>, and <span class="tt">time</span> grammar, and errata 3663 by adding the requested note. <a href="https://www.rfc-editor.org/errata_search.php?rfc=6265">https://www.rfc-editor.org/errata_search.php?rfc=6265</a></li><li>Dropped <span class="tt">Cookie2</span> and <span class="tt">Set-Cookie2</span> from the IANA Considerations section: <a href="https://github.com/httpwg/http-extensions/issues/247">https://github.com/httpwg/http-extensions/issues/247</a></li><li>Merged the recommendations from <a href="#I-D.ietf-httpbis-cookie-alone"><cite title="Deprecate modification of 'secure' cookies from non-secure origins">[I-D.ietf-httpbis-cookie-alone]</cite></a>, removing the ability for a non-secure origin to set cookies with a ‘secure’ flag, and to overwrite cookies whose ‘secure’ flag is true.</li><li>Merged the recommendations from <a href="#I-D.ietf-httpbis-cookie-prefixes"><cite title="Cookie Prefixes">[I-D.ietf-httpbis-cookie-prefixes]</cite></a>, adding <span class="tt">__Secure-</span> and <span class="tt">__Host-</span> cookie name prefix processing instructions.</li></ul></div></section><section id="draft-ietf-httpbis-rfc6265bis-02"><h3 id="rfc.section.A.3"><a href="#rfc.section.A.3">A.3.</a>&nbsp;<a href="#draft-ietf-httpbis-rfc6265bis-02">draft-ietf-httpbis-rfc6265bis-02</a></h3><div id="rfc.section.A.3.p.1"><ul><li>Merged the recommendations from <a href="#I-D.ietf-httpbis-cookie-same-site"><cite title="Same-Site Cookies">[I-D.ietf-httpbis-cookie-same-site]</cite></a>, adding support for the <span class="tt">SameSite</span> attribute.</li><li>Closed a number of editorial bugs: <ul><li>Clarified address bar behavior for SameSite cookies: <a href="https://github.com/httpwg/http-extensions/issues/201">https://github.com/httpwg/http-extensions/issues/201</a></li><li>Added the word “Cookies” to the document’s name: <a href="https://github.com/httpwg/http-extensions/issues/204">https://github.com/httpwg/http-extensions/issues/204</a></li><li>Clarified that the <span class="tt">__Host-</span> prefix requires an explicit <span class="tt">Path</span> attribute: <a href="https://github.com/httpwg/http-extensions/issues/222">https://github.com/httpwg/http-extensions/issues/222</a></li><li>Expanded the options for dealing with third-party cookies to include a brief mention of partitioning based on first-party: <a href="https://github.com/httpwg/http-extensions/issues/248">https://github.com/httpwg/http-extensions/issues/248</a></li><li>Noted that double-quotes in cookie values are part of the value, and are not stripped: <a href="https://github.com/httpwg/http-extensions/issues/295">https://github.com/httpwg/http-extensions/issues/295</a></li><li>Fixed the “site for cookies” algorithm to return something that makes sense: <a href="https://github.com/httpwg/http-extensions/issues/302">https://github.com/httpwg/http-extensions/issues/302</a></li></ul></li></ul></div></section></section><section id="acknowledgements"><h2 id="rfc.section.B"><a href="#rfc.section.B">B.</a>&nbsp;<a href="#acknowledgements">Acknowledgements</a></h2><div id="rfc.section.B.p.1"><p>This document is a minor update of RFC 6265, adding small features, and aligning the specification with the reality of today’s deployments. Here, we’re standing upon the shoulders of giants.</p></div></section><section id="rfc.authors" class="avoidbreakinside"><h2><a href="#rfc.authors">Authors' Addresses</a></h2><address><b>Adam Barth</b><br>Google, Inc<br>URI: <a href="https://www.adambarth.com/">https://www.adambarth.com/</a></address><address><b>Mike West</b><br>Google, Inc<br>EMail: <a href="mailto:mkwst@google.com">mkwst@google.com</a><br>URI: <a href="https://mikewest.org/">https://mikewest.org/</a></address></section></div></div></div><script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script><script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.2.0/js/bootstrap.min.js"></script></body></html>