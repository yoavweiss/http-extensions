<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Encrypted Content-Encoding for HTTP</title><script type="application/javascript">
function anchorRewrite() {
  map = { };
  if (window.location.hash.length >= 1) {
    var fragid = window.location.hash.substr(1);
    if (fragid) {
      if (! document.getElementById(fragid)) {
        var prefix = "rfc.";
        var mapped = map[fragid];
        if (mapped) {
          window.location.hash = mapped;
        } else if (fragid.indexOf("section-") == 0) {
          window.location.hash = prefix + "section." + fragid.substring(8);
        } else if (fragid.indexOf("appendix-") == 0) {
          window.location.hash = prefix + "section." + fragid.substring(9);
        } else if (fragid.indexOf("s-") == 0) {
          window.location.hash = prefix + "section." + fragid.substring(2);
        } else if (fragid.indexOf("p-") == 0) {
          var r = fragid.substring(2);
          var p = r.indexOf("-");
          if (p >= 0) {
            window.location.hash = prefix + "section." + r.substring(0, p) + ".p." + r.substring(p + 1);
          }
        }
      }
    }  
  }
}
window.addEventListener('hashchange', anchorRewrite);
window.addEventListener('DOMContentLoaded', anchorRewrite);
</script><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="stylesheet" type="text/css" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap.min.css"><style type="text/css">
      body {
        padding-top: 80px;
        padding-bottom: 80px;
        position: relative;
      }
      .table.header th, .table.header td {
        border-top: none;
        padding: 0;
      }
      #rfc\.meta {
        width: 40%;
        float: right
      }
      #rfc\.toc > ul li {
        list-style: none;
      }
      .container .nav-sublist {
        padding-left: 20px;
        padding-right: 10px;
        font-size: 90%;
      }
      .container .navbar-brand {
        padding-top: 0;
      }
      .container .nav > li > a {
        padding: 10px 7px 5px 15px;
        display: inline-block;
      }
      .container .nav > li > a + a {
        padding: 10px 15px 5px 7px;
        display: inline-block;
      }
      .container .nav > li > a {
        padding: 5px 10px;
      }
      .filename {
        color: rgb(119, 119, 119);
        font-size: 23px;
        font-weight: normal;
        height: auto;
        line-height: 23px;
      }
      dl {
        margin-left: 1em;
      }
      dl.dl-horizontal: {
        margin-left: 0;
      }
      dl > dt {
        float: left;
        margin-right: 1em;
      }
      dl.nohang > dt {
        float: none;
      }
      dl > dd {
        margin-bottom: .5em;
      }
      dl.compact > dd {
        margin-bottom: 0em;
      }
      dl > dd > dl {
        margin-top: 0.5em;
        margin-bottom: 0em;
      }
      ul.empty {
        list-style-type: none;
      }
      ul.empty li {
        margin-top: .5em;
      }
      td.reference {
        padding-right: 1em;
        vertical-align: top;
      }
      .feedback {
        position: fixed;
        bottom: 5px;
        right: 5px;
      }
      .fbbutton {
        margin-left: 5px;
      }
      h1 a, h2 a, h3 a, h4 a, h5 a, h6 a {
        color: rgb(51, 51, 51);
      }
      span.tt {
        font: 11pt consolas, monospace;
        font-size-adjust: none;
      }
    </style><link rel="Author" href="#rfc.authors"><link rel="Copyright" href="#rfc.copyrightnotice"><link rel="Chapter" title="1 Introduction" href="#rfc.section.1"><link rel="Chapter" title="2 The “aes128gcm” HTTP Content Coding" href="#rfc.section.2"><link rel="Chapter" title="3 Crypto-Key Header Field" href="#rfc.section.3"><link rel="Chapter" title="4 Examples" href="#rfc.section.4"><link rel="Chapter" title="5 Security Considerations" href="#rfc.section.5"><link rel="Chapter" title="6 IANA Considerations" href="#rfc.section.6"><link rel="Chapter" href="#rfc.section.7" title="7 References"><link rel="Appendix" title="A JWE Mapping" href="#rfc.section.A"><link rel="Appendix" title="B Acknowledgements" href="#rfc.section.B"><meta name="generator" content="https://github.com/mnot/RFCBootstrap XSLT vendor: SAXON 9.1.0.8 from Saxonica http://www.saxonica.com/"><meta name="keywords" content="Internet-Draft"><link rel="schema.dcterms" href="http://purl.org/dc/terms/"><meta name="dcterms.creator" content="Thomson, M."><meta name="dcterms.identifier" content="urn:ietf:id:draft-ietf-httpbis-encryption-encoding-latest"><meta name="dcterms.issued" content="2016-10-29"><meta name="dcterms.abstract" content="This memo introduces a content coding for HTTP that allows message payloads to be encrypted."><meta name="description" content="This memo introduces a content coding for HTTP that allows message payloads to be encrypted."></head><body><div class="container" id="top"><div class="row"><div class="col-md-4 col-md-push-8 hidden-sm hidden-xs" role="navigation"><div class="navbar"><div class="navbar-brand"><a href="#top">Internet-Draft</a></div><br clear="all"><div class=""><div id="rfc..toc"><ul class="nav"><li><a href="#rfc.section.1">1.</a>&nbsp;&nbsp;&nbsp;<a href="#introduction">Introduction</a><ul><li><a href="#rfc.section.1.1">1.1</a>&nbsp;&nbsp;&nbsp;<a href="#notational-conventions">Notational Conventions</a></li></ul></li><li><a href="#rfc.section.2">2.</a>&nbsp;&nbsp;&nbsp;<a href="#aes128gcm">The “aes128gcm” HTTP Content Coding</a><ul><li><a href="#rfc.section.2.1">2.1</a>&nbsp;&nbsp;&nbsp;<a href="#header">Encryption Content Coding Header</a></li><li><a href="#rfc.section.2.2">2.2</a>&nbsp;&nbsp;&nbsp;<a href="#derivation">Content Encryption Key Derivation</a></li><li><a href="#rfc.section.2.3">2.3</a>&nbsp;&nbsp;&nbsp;<a href="#nonce">Nonce Derivation</a></li></ul></li><li><a href="#rfc.section.3">3.</a>&nbsp;&nbsp;&nbsp;<a href="#crypto-key">Crypto-Key Header Field</a></li><li><a href="#rfc.section.4">4.</a>&nbsp;&nbsp;&nbsp;<a href="#examples">Examples</a><ul><li><a href="#rfc.section.4.1">4.1</a>&nbsp;&nbsp;&nbsp;<a href="#explicit">Encryption of a Response</a></li><li><a href="#rfc.section.4.2">4.2</a>&nbsp;&nbsp;&nbsp;<a href="#encryption-with-multiple-records">Encryption with Multiple Records</a></li></ul></li><li><a href="#rfc.section.5">5.</a>&nbsp;&nbsp;&nbsp;<a href="#security-considerations">Security Considerations</a><ul><li><a href="#rfc.section.5.1">5.1</a>&nbsp;&nbsp;&nbsp;<a href="#key-and-nonce-reuse">Key and Nonce Reuse</a></li><li><a href="#rfc.section.5.2">5.2</a>&nbsp;&nbsp;&nbsp;<a href="#limits">Data Encryption Limits</a></li><li><a href="#rfc.section.5.3">5.3</a>&nbsp;&nbsp;&nbsp;<a href="#content-integrity">Content Integrity</a></li><li><a href="#rfc.section.5.4">5.4</a>&nbsp;&nbsp;&nbsp;<a href="#leaking-information-in-headers">Leaking Information in Headers</a></li><li><a href="#rfc.section.5.5">5.5</a>&nbsp;&nbsp;&nbsp;<a href="#poisoning-storage">Poisoning Storage</a></li><li><a href="#rfc.section.5.6">5.6</a>&nbsp;&nbsp;&nbsp;<a href="#sizing-and-timing-attacks">Sizing and Timing Attacks</a></li></ul></li><li><a href="#rfc.section.6">6.</a>&nbsp;&nbsp;&nbsp;<a href="#iana">IANA Considerations</a><ul><li><a href="#rfc.section.6.1">6.1</a>&nbsp;&nbsp;&nbsp;<a href="#the-aes128gcm-http-content-coding">The “aes128gcm” HTTP Content Coding</a></li><li><a href="#rfc.section.6.2">6.2</a>&nbsp;&nbsp;&nbsp;<a href="#encryption-header-fields">Encryption Header Fields</a></li><li><a href="#rfc.section.6.3">6.3</a>&nbsp;&nbsp;&nbsp;<a href="#crypto-key-registry">The HTTP Crypto-Key Parameter Registry</a><ul><li><a href="#rfc.section.6.3.1">6.3.1</a>&nbsp;&nbsp;&nbsp;<a href="#keyid">keyid</a></li><li><a href="#rfc.section.6.3.2">6.3.2</a>&nbsp;&nbsp;&nbsp;<a href="#iana-ekey-aes128gcm">aes128gcm</a></li></ul></li></ul></li><li><a href="#rfc.section.7">7.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.references">References</a><ul><li><a href="#rfc.section.7.1">7.1</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.references.1">Normative References</a></li><li><a href="#rfc.section.7.2">7.2</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.references.2">Informative References</a></li></ul></li><li><a href="#rfc.section.A">A.</a>&nbsp;&nbsp;&nbsp;<a href="#jwe">JWE Mapping</a></li><li><a href="#rfc.section.B">B.</a>&nbsp;&nbsp;&nbsp;<a href="#acknowledgements">Acknowledgements</a></li><li><a href="#rfc.authors">Author's Address</a></li></ul></div></div></div></div><div class="col-md-8 col-md-pull-4 main" role="main"><header><table class="table table-condensed header" id="rfc.headerblock"><tbody><tr><td class="text-left">HTTP Working Group</td><td class="text-right">M. Thomson</td></tr><tr><td class="text-left">Internet-Draft</td><td class="text-right">Mozilla</td></tr><tr><td class="text-left">Intended status: Standards Track</td><td class="text-right">October 29, 2016</td></tr><tr><td class="text-left">Expires: May 2, 2017</td><td class="text-right"></td></tr></tbody></table><div id="rfc.title"><h1>Encrypted Content-Encoding for HTTP</h1><div class="filename">draft-ietf-httpbis-encryption-encoding-latest</div></div></header><hr><h2 id="rfc..abstract"><a href="#rfc..abstract">Abstract</a></h2><div class="lead"><p>This memo introduces a content coding for HTTP that allows message payloads to be encrypted.</p></div><section id="rfc.note.1"><h2><a href="#rfc.note.1">Note to Readers</a></h2><p>Discussion of this draft takes place on the HTTP working group mailing list (ietf-http-wg@w3.org), which is archived at <a href="https://lists.w3.org/Archives/Public/ietf-http-wg/">https://lists.w3.org/Archives/Public/ietf-http-wg/</a>.</p><p>Working Group information can be found at <a href="http://httpwg.github.io/">http://httpwg.github.io/</a>; source code and issues list for this draft can be found at <a href="https://github.com/httpwg/http-extensions/labels/encryption">https://github.com/httpwg/http-extensions/labels/encryption</a>.</p></section><section id="rfc.status"><h2><a href="#rfc.status">Status of this Memo</a></h2><p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p><p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF). Note that other groups may also distribute working documents as Internet-Drafts. The list of current Internet-Drafts is at <a href="http://datatracker.ietf.org/drafts/current/">http://datatracker.ietf.org/drafts/current/</a>.</p><p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time. It is inappropriate to use Internet-Drafts as reference material or to cite them other than as “work in progress”.</p><p>This Internet-Draft will expire on May 2, 2017.</p></section><section id="rfc.copyrightnotice"><h2><a href="#rfc.copyrightnotice">Copyright Notice</a></h2><p>Copyright © 2016 IETF Trust and the persons identified as the document authors. All rights reserved.</p><p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (<a href="http://trustee.ietf.org/license-info">http://trustee.ietf.org/license-info</a>) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p></section><section id="introduction"><h2 id="rfc.section.1" class="np"><a href="#rfc.section.1">1.</a>&nbsp;<a href="#introduction">Introduction</a></h2><div id="rfc.section.1.p.1"><p>It is sometimes desirable to encrypt the contents of a HTTP message (request or response) so that when the payload is stored (e.g., with a HTTP PUT), only someone with the appropriate key can read it.</p></div><div id="rfc.section.1.p.2"><p>For example, it might be necessary to store a file on a server without exposing its contents to that server. Furthermore, that same file could be replicated to other servers (to make it more resistant to server or network failure), downloaded by clients (to make it available offline), etc. without exposing its contents.</p></div><div id="rfc.section.1.p.3"><p>These uses are not met by the use of TLS <a href="#RFC5246"><cite title="The Transport Layer Security (TLS) Protocol Version 1.2">[RFC5246]</cite></a>, since it only encrypts the channel between the client and server.</p></div><div id="rfc.section.1.p.4"><p>This document specifies a content coding (Section 3.1.2 of <a href="#RFC7231"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content">[RFC7231]</cite></a>) for HTTP to serve these and other use cases.</p></div><div id="rfc.section.1.p.5"><p>This content coding is not a direct adaptation of message-based encryption formats - such as those that are described by <a href="#RFC4880"><cite title="OpenPGP Message Format">[RFC4880]</cite></a>, <a href="#RFC5652"><cite title="Cryptographic Message Syntax (CMS)">[RFC5652]</cite></a>, <a href="#RFC7516"><cite title="JSON Web Encryption (JWE)">[RFC7516]</cite></a>, and <a href="#XMLENC"><cite title="XML Encryption Syntax and Processing">[XMLENC]</cite></a> - which are not suited to stream processing, which is necessary for HTTP. The format described here cleaves more closely to the lower level constructs described in <a href="#RFC5116"><cite title="An Interface and Algorithms for Authenticated Encryption">[RFC5116]</cite></a>.</p></div><div id="rfc.section.1.p.6"><p>To the extent that message-based encryption formats use the same primitives, the format can be considered as sequence of encrypted messages with a particular profile. For instance, <a href="#jwe" title="JWE Mapping">Appendix&nbsp;A</a> explains how the format is congruent with a sequence of JSON Web Encryption <a href="#RFC7516"><cite title="JSON Web Encryption (JWE)">[RFC7516]</cite></a> values with a fixed header.</p></div><div id="rfc.section.1.p.7"><p>This mechanism is likely only a small part of a larger design that uses content encryption. How clients and servers acquire and identify keys will depend on the use case. Though a complete key management system is not described, this document defines an Crypto-Key header field that can be used to convey keying material.</p></div><section id="notational-conventions"><h3 id="rfc.section.1.1"><a href="#rfc.section.1.1">1.1</a>&nbsp;<a href="#notational-conventions">Notational Conventions</a></h3><div id="rfc.section.1.1.p.1"><p>The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in <a href="#RFC2119"><cite title="Key words for use in RFCs to Indicate Requirement Levels">[RFC2119]</cite></a>.</p></div><div id="rfc.section.1.1.p.2"><p>Base64url encoding is defined in Section 2 of <a href="#RFC7515"><cite title="JSON Web Signature (JWS)">[RFC7515]</cite></a>.</p></div></section></section><section id="aes128gcm"><h2 id="rfc.section.2"><a href="#rfc.section.2">2.</a>&nbsp;<a href="#aes128gcm">The “aes128gcm” HTTP Content Coding</a></h2><div id="rfc.section.2.p.1"><p>The “aes128gcm” HTTP content coding indicates that a payload has been encrypted using Advanced Encryption Standard (AES) in Galois/Counter Mode (GCM) as identified as AEAD_AES_128_GCM in <a href="#RFC5116"><cite title="An Interface and Algorithms for Authenticated Encryption">[RFC5116]</cite></a>, Section 5.1. The AEAD_AES_128_GCM algorithm uses a 128 bit content encryption key.</p></div><div id="rfc.section.2.p.2"><p>Using this content coding requires knowledge of a key. The Crypto-Key header field (<a href="#crypto-key" title="Crypto-Key Header Field">Section&nbsp;3</a>) can be included to describe how the content encryption key is derived or retrieved. Keys might be provided in messages that are separate from those with encrypted content using Crypto-Key, or provided through external mechanisms.</p></div><div id="rfc.section.2.p.3"><p>The “aes128gcm” content coding uses a single fixed set of encryption primitives. Cipher suite agility is achieved by defining a new content coding scheme. This ensures that only the HTTP Accept-Encoding header field is necessary to negotiate the use of encryption.</p></div><div id="rfc.section.2.p.4"><p>The “aes128gcm” content coding uses a fixed record size. The final encoding consists of a header (see <a href="#header" title="Encryption Content Coding Header">Section&nbsp;2.1</a>), plus one or more encrypted records. All records other than the last are the same size; the final record MUST be shorter than the fixed record size.</p></div><div id="rfc.figure.u.1"><pre class="drawing">
      +-----------+       content is rs octets minus padding
      |   data    |       of between 2 and 65537 octets;
      +-----------+       the last record is smaller
           |
           v
+-----+-----------+       add padding to get rs octets;
| pad |   data    |       the last record contains
+-----+-----------+       up to rs minus 1 octets
         |
         v
+--------------------+    encrypt with AEAD_AES_128_GCM;
|    ciphertext      |    final size is rs plus 16 octets
+--------------------+    the last record is smaller
</pre></div><div id="rfc.section.2.p.5"><p>The record size determines the length of each portion of plaintext that is enciphered, with the exception of the final record, which is necessarily smaller. The record size (“rs”) is included in the content coding header (see <a href="#header" title="Encryption Content Coding Header">Section&nbsp;2.1</a>).</p></div><div id="rfc.section.2.p.6"><p>AEAD_AES_128_GCM produces ciphertext 16 octets longer than its input plaintext. Therefore, the length of each enciphered record other than the last is equal to the value of the “rs” parameter plus 16 octets. To prevent an attacker from truncating a stream, an encoder MUST append a record that contains only padding and is smaller than the full record size if the final record ends on a record boundary. A receiver MUST fail to decrypt if the final record ciphertext is less than 18 octets in size or equal to the record size plus 16 (that is, the size of a full encrypted record). Valid records always contain at least two octets of padding and a 16 octet authentication tag.</p></div><div id="rfc.section.2.p.7"><p>Each record contains between 2 and 65537 octets of padding, inserted into a record before the enciphered content. Padding consists of a two octet unsigned integer in network byte order, followed that number of zero-valued octets. A receiver MUST fail to decrypt if any padding octet other than the first two are non-zero, or a record has more padding than the record size can accommodate.</p></div><div id="rfc.section.2.p.8"><p>The nonce for each record is a 96-bit value constructed from the record sequence number and the input keying material. Nonce derivation is covered in <a href="#nonce" title="Nonce Derivation">Section&nbsp;2.3</a>.</p></div><div id="rfc.section.2.p.9"><p>The additional data passed to each invocation of AEAD_AES_128_GCM is a zero-length octet sequence.</p></div><div id="rfc.section.2.p.10"><p>A consequence of this record structure is that range requests <a href="#RFC7233"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Range Requests">[RFC7233]</cite></a> and random access to encrypted payload bodies are possible at the granularity of the record size. Partial records at the ends of a range cannot be decrypted. Thus, it is best if range requests start and end on record boundaries.</p></div><div id="rfc.section.2.p.11"><p>Selecting the record size most appropriate for a given situation requires a trade-off. A smaller record size allows decrypted octets to be released more rapidly, which can be appropriate for applications that depend on responsiveness. Smaller records also reduce the additional data required if random access into the ciphertext is needed. Applications that depend on being able to pad by arbitrary amounts cannot increase the record size beyond 65537 octets.</p></div><div id="rfc.section.2.p.12"><p>Applications that don’t depending on streaming, random access, or arbitrary padding can use larger records, or even a single record. A larger record size reduces the processing and data overheads.</p></div><section id="header"><h3 id="rfc.section.2.1"><a href="#rfc.section.2.1">2.1</a>&nbsp;<a href="#header">Encryption Content Coding Header</a></h3><div id="rfc.section.2.1.p.1"><p>The content coding uses a fixed size header block that includes the salt, a record size and an optional key identifier. The header block is placed in the body of a message ahead of the sequence of records.</p></div><div id="rfc.figure.u.2"><pre class="drawing">
+-----------+--------+-----------+------------+
| salt (16) | rs (4) | idlen (1) | id (idlen) |
+-----------+--------+-----------+------------+
</pre></div><div id="rfc.section.2.1.p.2"><dl class="compact"><dt>salt:</dt><dd>The “salt” parameter comprises the first 16 octets of the “aes128gcm” content coding header. The same “salt” parameter value MUST NOT be reused for two different payload bodies that have the same input keying material; generating a random salt for every application of the content coding ensures that content encryption key reuse is highly unlikely.</dd><dt>rs:</dt><dd>The “rs” or record size parameter contains an unsigned 32-bit integer in network byte order that describes the record size in octets. Note that it is therefore impossible to exceed the 2^36-1 limit on plaintext input to AEAD_AES_128_GCM. Values smaller than 3 are invalid.</dd><dt>keyid:</dt><dd>The “keyid” parameter can be used to identify the keying material that is used. When the Crypto-Key header field is used, the “keyid” identifies a matching value in that field. The “keyid” parameter MUST be used if keying material included in an Crypto-Key header field is needed to derive the content encryption key. The “keyid” parameter can also be used to identify keys in an application-specific fashion.</dd></dl></div></section><section id="derivation"><h3 id="rfc.section.2.2"><a href="#rfc.section.2.2">2.2</a>&nbsp;<a href="#derivation">Content Encryption Key Derivation</a></h3><div id="rfc.section.2.2.p.1"><p>In order to allow the reuse of keying material for multiple different HTTP messages, a content encryption key is derived for each message. The content encryption key is derived from the decoded value of the “salt” parameter using the HMAC-based key derivation function (HKDF) described in <a href="#RFC5869"><cite title="HMAC-based Extract-and-Expand Key Derivation Function (HKDF)">[RFC5869]</cite></a> using the SHA-256 hash algorithm <a href="#FIPS180-4"><cite title="NIST FIPS 180-4, Secure Hash Standard">[FIPS180-4]</cite></a>.</p></div><div id="rfc.section.2.2.p.2" class="avoidbreakafter"><p>The value of the “salt” parameter is the salt input to HKDF function. The keying material identified by the “keyid” parameter is the input keying material (IKM) to HKDF. Input keying material can either be prearranged, or can be described using the Crypto-Key header field (<a href="#crypto-key" title="Crypto-Key Header Field">Section&nbsp;3</a>). The extract phase of HKDF therefore produces a pseudorandom key (PRK) as follows:</p></div><div id="rfc.figure.u.3"><pre class="inline">
   PRK = HMAC-SHA-256(salt, IKM)
</pre></div><div id="rfc.section.2.2.p.3" class="avoidbreakafter"><p>The info parameter to HKDF is set to the ASCII-encoded string “Content-Encoding: aes128gcm” and a single zero octet:</p></div><div id="rfc.figure.u.4"><pre class="inline">
   cek_info = "Content-Encoding: aes128gcm" || 0x00
</pre></div><div id="rfc.section.2.2.p.4" class="avoidbreakafter"><p>AEAD_AES_128_GCM requires a 16 octet (128 bit) content encryption key (CEK), so the length (L) parameter to HKDF is 16. The second step of HKDF can therefore be simplified to the first 16 octets of a single HMAC:</p></div><div id="rfc.figure.u.5"><pre class="inline">
   CEK = HMAC-SHA-256(PRK, cek_info || 0x01)
</pre></div></section><section id="nonce"><h3 id="rfc.section.2.3"><a href="#rfc.section.2.3">2.3</a>&nbsp;<a href="#nonce">Nonce Derivation</a></h3><div id="rfc.section.2.3.p.1"><p>The nonce input to AEAD_AES_128_GCM is constructed for each record. The nonce for each record is a 12 octet (96 bit) value is produced from the record sequence number and a value derived from the input keying material.</p></div><div id="rfc.section.2.3.p.2"><p>The input keying material and salt values are input to HKDF with different info and length parameters.</p></div><div id="rfc.section.2.3.p.3" class="avoidbreakafter"><p>The length (L) parameter is 12 octets. The info parameter for the nonce is the ASCII-encoded string “Content-Encoding: nonce”, terminated by a a single zero octet:</p></div><div id="rfc.figure.u.6"><pre class="inline">
   nonce_info = "Content-Encoding: nonce" || 0x00
</pre></div><div id="rfc.section.2.3.p.4"><p>The result is combined with the record sequence number - using exclusive or - to produce the nonce. The record sequence number (SEQ) is a 96-bit unsigned integer in network byte order that starts at zero.</p></div><div id="rfc.section.2.3.p.5" class="avoidbreakafter"><p>Thus, the final nonce for each record is a 12 octet value:</p></div><div id="rfc.figure.u.7"><pre class="inline">
   NONCE = HMAC-SHA-256(PRK, nonce_info || 0x01) XOR SEQ
</pre></div><div id="rfc.section.2.3.p.6"><p>This nonce construction prevents removal or reordering of records. However, it permits truncation of the tail of the sequence (see <a href="#aes128gcm" title="The “aes128gcm” HTTP Content Coding">Section&nbsp;2</a> for how this is avoided).</p></div></section></section><section id="crypto-key"><h2 id="rfc.section.3"><a href="#rfc.section.3">3.</a>&nbsp;<a href="#crypto-key">Crypto-Key Header Field</a></h2><div id="rfc.section.3.p.1"><p>A Crypto-Key header field can be used to describe the input keying material used in the Encryption header field.</p></div><div id="rfc.section.3.p.2"><p>Ordinarily, this header field will not appear in the same message as the encrypted content. Including the encryption key with the encrypted payload reduces the value of using encryption to a somewhat complicated checksum. However, the Crypto-Key header field could be used in one message to provision keys for other messages.</p></div><div id="rfc.section.3.p.3"><p>The Crypto-Key header field uses the extended ABNF syntax defined in Section 1.2 of <a href="#RFC7230"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing">[RFC7230]</cite></a> and the <span class="tt">parameter</span> and <span class="tt">OWS</span> rules from <a href="#RFC7231"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content">[RFC7231]</cite></a>.</p></div><div id="rfc.figure.u.8"><pre class="inline">
  Crypto-Key = #crypto_key_params
  crypto_key_params = [ parameter *( OWS ";" OWS parameter ) ]
</pre></div><div id="rfc.section.3.p.4"><dl class="compact"><dt>keyid:</dt><dd>The “keyid” parameter corresponds to the “keyid” parameter in the content coding.</dd><dt>aes128gcm:</dt><dd>The “aes128gcm” parameter contains the base64url-encoded octets <a href="#RFC7515"><cite title="JSON Web Signature (JWS)">[RFC7515]</cite></a> of the input keying material for the “aes128gcm” content coding.</dd></dl></div><div id="rfc.section.3.p.5"><p>Crypto-Key header field values with multiple instances of the same parameter name are invalid.</p></div><div id="rfc.section.3.p.6"><p>The input keying material used by the key derivation (see <a href="#derivation" title="Content Encryption Key Derivation">Section&nbsp;2.2</a>) can be determined based on the information in the Crypto-Key header field.</p></div><div id="rfc.section.3.p.7"><p>The value or values provided in the Crypto-Key header field is valid only for the current HTTP message unless additional information indicates a greater scope.</p></div><div id="rfc.section.3.p.8"><p>Alternative methods for determining input keying material MAY be defined by specifications that use this content coding. This document only defines the use of the “aes128gcm” parameter which describes an explicit key.</p></div><div id="rfc.section.3.p.9"><p>The “aes128gcm” parameter MUST decode to at least 16 octets in order to be used as input keying material for “aes128gcm” content coding.</p></div></section><section id="examples"><h2 id="rfc.section.4"><a href="#rfc.section.4">4.</a>&nbsp;<a href="#examples">Examples</a></h2><div id="rfc.section.4.p.1"><p>This section shows a few examples of the encrypted content coding.</p></div><div id="rfc.section.4.p.2"><p>Note: All binary values in the examples in this section use base64url encoding <a href="#RFC7515"><cite title="JSON Web Signature (JWS)">[RFC7515]</cite></a>. This includes the bodies of requests. Whitespace and line wrapping is added to fit formatting constraints.</p></div><section id="explicit"><h3 id="rfc.section.4.1"><a href="#rfc.section.4.1">4.1</a>&nbsp;<a href="#explicit">Encryption of a Response</a></h3><div id="rfc.section.4.1.p.1"><p>Here, a successful HTTP GET response has been encrypted using input keying material that is identified by a URI.</p></div><div id="rfc.section.4.1.p.2"><p>The encrypted data in this example is the UTF-8 encoded string “I am the walrus”. The input keying material is included in the Crypto-Key header field. The content body contains a single record only and is shown here using base64url encoding for presentation reasons.</p></div><div id="rfc.figure.u.9"><pre class="text">
HTTP/1.1 200 OK
Content-Type: application/octet-stream
Content-Length: 33
Content-Encoding: aes128gcm
Crypto-Key: aes128gcm=6Aqf1aDH8lSxLyCpoCnAqg

lVIUs_H0A2a8-6dhmzY57H4K4uRFCF6tIIPRO9vrOL6B
</pre></div><div id="rfc.section.4.1.p.3"><p>Note that the media type has been changed to “application/octet-stream” to avoid exposing information about the content.</p></div></section><section id="encryption-with-multiple-records"><h3 id="rfc.section.4.2"><a href="#rfc.section.4.2">4.2</a>&nbsp;<a href="#encryption-with-multiple-records">Encryption with Multiple Records</a></h3><div id="rfc.section.4.2.p.1"><p>This example shows the same encrypted message, but split into records of 10 octets each. The first record includes a single additional octet of padding, which causes the end of the content to align with a record boundary, forcing the creation of a third record that contains only padding.</p></div><div id="rfc.figure.u.10"><pre class="text">
HTTP/1.1 200 OK
Content-Length: 70
Content-Encoding: aes128gcm
Crypto-Key: keyid="a1"; aes128gcm="BO3ZVPxUlnLORbVGMpbT1Q"

iBmR5fjBCUvicKLSt1L1GQAAAAoCYTGZvfb0yACNxTo090xk6m_6GwMiLv4AxGSS
_BFGyZS_2z_cOxSHLfuPsAQiId243MTE8B_5Vg-R5OPTNbiV3PlHJcjGONoI
</pre></div></section></section><section id="security-considerations"><h2 id="rfc.section.5"><a href="#rfc.section.5">5.</a>&nbsp;<a href="#security-considerations">Security Considerations</a></h2><div id="rfc.section.5.p.1"><p>This mechanism assumes the presence of a key management framework that is used to manage the distribution of keys between valid senders and receivers. Defining key management is part of composing this mechanism into a larger application, protocol, or framework.</p></div><div id="rfc.section.5.p.2"><p>Implementation of cryptography - and key management in particular - can be difficult. For instance, implementations need to account for the potential for exposing keying material on side channels, such as might be exposed by the time it takes to perform a given operation. The requirements for a good implementation of cryptographic algorithms can change over time.</p></div><section id="key-and-nonce-reuse"><h3 id="rfc.section.5.1"><a href="#rfc.section.5.1">5.1</a>&nbsp;<a href="#key-and-nonce-reuse">Key and Nonce Reuse</a></h3><div id="rfc.section.5.1.p.1"><p>Encrypting different plaintext with the same content encryption key and nonce in AES-GCM is not safe <a href="#RFC5116"><cite title="An Interface and Algorithms for Authenticated Encryption">[RFC5116]</cite></a>. The scheme defined here uses a fixed progression of nonce values. Thus, a new content encryption key is needed for every application of the content coding. Since input keying material can be reused, a unique “salt” parameter is needed to ensure a content encryption key is not reused.</p></div><div id="rfc.section.5.1.p.2"><p>If a content encryption key is reused - that is, if input keying material and salt are reused - this could expose the plaintext and the authentication key, nullifying the protection offered by encryption. Thus, if the same input keying material is reused, then the salt parameter MUST be unique each time. This ensures that the content encryption key is not reused. An implementation SHOULD generate a random salt parameter for every message; a counter could achieve the same result.</p></div></section><section id="limits"><h3 id="rfc.section.5.2"><a href="#rfc.section.5.2">5.2</a>&nbsp;<a href="#limits">Data Encryption Limits</a></h3><div id="rfc.section.5.2.p.1"><p>There are limits to the data that AEAD_AES_128_GCM can encipher. The maximum record size is 2^36-31 <a href="#RFC5116"><cite title="An Interface and Algorithms for Authenticated Encryption">[RFC5116]</cite></a>. In order to preserve a 2^-40 probability of indistinguishability under chosen plaintext attack (IND-CPA), the total amount of plaintext that can be enciphered MUST be less than 2^44.5 blocks <a href="#AEBounds"><cite title="Limits on Authenticated Encryption Use in TLS">[AEBounds]</cite></a>.</p></div><div id="rfc.section.5.2.p.2"><p>If rs is a multiple of 16 octets, this means 398 terabytes can be encrypted safely, including padding. However, if the record size is a multiple of 16 octets, the total amount of data that can be safely encrypted is reduced. The worst case is a record size of 3 octets, for which at most 74 terabytes of plaintext can be encrypted, of which at least two-thirds is padding.</p></div></section><section id="content-integrity"><h3 id="rfc.section.5.3"><a href="#rfc.section.5.3">5.3</a>&nbsp;<a href="#content-integrity">Content Integrity</a></h3><div id="rfc.section.5.3.p.1"><p>This mechanism only provides content origin authentication. The authentication tag only ensures that an entity with access to the content encryption key produced the encrypted data.</p></div><div id="rfc.section.5.3.p.2"><p>Any entity with the content encryption key can therefore produce content that will be accepted as valid. This includes all recipients of the same HTTP message.</p></div><div id="rfc.section.5.3.p.3"><p>Furthermore, any entity that is able to modify both the Encryption header field and the HTTP message body can replace the contents. Without the content encryption key or the input keying material, modifications to or replacement of parts of a payload body are not possible.</p></div></section><section id="leaking-information-in-headers"><h3 id="rfc.section.5.4"><a href="#rfc.section.5.4">5.4</a>&nbsp;<a href="#leaking-information-in-headers">Leaking Information in Headers</a></h3><div id="rfc.section.5.4.p.1"><p>Because only the payload body is encrypted, information exposed in header fields is visible to anyone who can read the HTTP message. This could expose side-channel information.</p></div><div id="rfc.section.5.4.p.2"><p>For example, the Content-Type header field can leak information about the payload body.</p></div><div id="rfc.section.5.4.p.3" class="avoidbreakafter"><p>There are a number of strategies available to mitigate this threat, depending upon the application’s threat model and the users’ tolerance for leaked information:</p></div><div id="rfc.section.5.4.p.4"><ol><li>Determine that it is not an issue. For example, if it is expected that all content stored will be “application/json”, or another very common media type, exposing the Content-Type header field could be an acceptable risk.</li><li>If it is considered sensitive information and it is possible to determine it through other means (e.g., out of band, using hints in other representations, etc.), omit the relevant headers, and/or normalize them. In the case of Content-Type, this could be accomplished by always sending Content-Type: application/octet-stream (the most generic media type), or no Content-Type at all.</li><li>If it is considered sensitive information and it is not possible to convey it elsewhere, encapsulate the HTTP message using the application/http media type (Section 8.3.2 of <a href="#RFC7230"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing">[RFC7230]</cite></a>), encrypting that as the payload of the “outer” message.</li></ol></div></section><section id="poisoning-storage"><h3 id="rfc.section.5.5"><a href="#rfc.section.5.5">5.5</a>&nbsp;<a href="#poisoning-storage">Poisoning Storage</a></h3><div id="rfc.section.5.5.p.1"><p>This mechanism only offers encryption of content; it does not perform authentication or authorization, which still needs to be performed (e.g., by HTTP authentication <a href="#RFC7235"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Authentication">[RFC7235]</cite></a>).</p></div><div id="rfc.section.5.5.p.2"><p>This is especially relevant when a HTTP PUT request is accepted by a server; if the request is unauthenticated, it becomes possible for a third party to deny service and/or poison the store.</p></div></section><section id="sizing-and-timing-attacks"><h3 id="rfc.section.5.6"><a href="#rfc.section.5.6">5.6</a>&nbsp;<a href="#sizing-and-timing-attacks">Sizing and Timing Attacks</a></h3><div id="rfc.section.5.6.p.1"><p>Applications using this mechanism need to be aware that the size of encrypted messages, as well as their timing, HTTP methods, URIs and so on, may leak sensitive information.</p></div><div id="rfc.section.5.6.p.2"><p>This risk can be mitigated through the use of the padding that this mechanism provides. Alternatively, splitting up content into segments and storing the separately might reduce exposure. HTTP/2 <a href="#RFC7540"><cite title="Hypertext Transfer Protocol Version 2 (HTTP/2)">[RFC7540]</cite></a> combined with TLS <a href="#RFC5246"><cite title="The Transport Layer Security (TLS) Protocol Version 1.2">[RFC5246]</cite></a> might be used to hide the size of individual messages.</p></div></section></section><section id="iana"><h2 id="rfc.section.6"><a href="#rfc.section.6">6.</a>&nbsp;<a href="#iana">IANA Considerations</a></h2><section id="the-aes128gcm-http-content-coding"><h3 id="rfc.section.6.1"><a href="#rfc.section.6.1">6.1</a>&nbsp;<a href="#the-aes128gcm-http-content-coding">The “aes128gcm” HTTP Content Coding</a></h3><div id="rfc.section.6.1.p.1"><p>This memo registers the “aes128gcm” HTTP content coding in the HTTP Content Codings Registry, as detailed in <a href="#aes128gcm" title="The “aes128gcm” HTTP Content Coding">Section&nbsp;2</a>.</p></div><div id="rfc.section.6.1.p.2"><ul><li>Name: aes128gcm</li><li>Description: AES-GCM encryption with a 128-bit content encryption key</li><li>Reference: this specification</li></ul></div></section><section id="encryption-header-fields"><h3 id="rfc.section.6.2"><a href="#rfc.section.6.2">6.2</a>&nbsp;<a href="#encryption-header-fields">Encryption Header Fields</a></h3><div id="rfc.section.6.2.p.1"><p>This memo registers the “Crypto-Key” HTTP header field in the Permanent Message Header Registry, as detailed in <a href="#crypto-key" title="Crypto-Key Header Field">Section&nbsp;3</a>.</p></div><div id="rfc.section.6.2.p.2" class="avoidbreakafter"><ul><li>Field name: Crypto-Key</li><li>Protocol: HTTP</li><li>Status: Standard</li><li>Reference: this specification</li><li>Notes:</li></ul></div></section><section id="crypto-key-registry"><h3 id="rfc.section.6.3"><a href="#rfc.section.6.3">6.3</a>&nbsp;<a href="#crypto-key-registry">The HTTP Crypto-Key Parameter Registry</a></h3><div id="rfc.section.6.3.p.1"><p>This memo establishes a registry for parameters used by the “Crypto-Key” header field under the “Hypertext Transfer Protocol (HTTP) Parameters” grouping. The “Hypertext Transfer Protocol (HTTP) Crypto-Key Parameters” operates under an “Specification Required” policy <a href="#RFC5226"><cite title="Guidelines for Writing an IANA Considerations Section in RFCs">[RFC5226]</cite></a>.</p></div><div id="rfc.section.6.3.p.2" class="avoidbreakafter"><p>Entries in this registry are expected to include the following information:</p></div><div id="rfc.section.6.3.p.3"><ul><li>Parameter Name: The name of the parameter.</li><li>Purpose: A brief description of the purpose of the parameter.</li><li>Reference: A reference to a specification that defines the semantics of the parameter.</li></ul></div><div id="rfc.section.6.3.p.4" class="avoidbreakafter"><p>The initial contents of this registry are:</p></div><section id="keyid"><h4 id="rfc.section.6.3.1"><a href="#rfc.section.6.3.1">6.3.1</a>&nbsp;<a href="#keyid">keyid</a></h4><div id="rfc.section.6.3.1.p.1"><ul><li>Parameter Name: keyid</li><li>Purpose: Identify the key that is in use.</li><li>Reference: this document</li></ul></div></section><section id="iana-ekey-aes128gcm"><h4 id="rfc.section.6.3.2"><a href="#rfc.section.6.3.2">6.3.2</a>&nbsp;<a href="#iana-ekey-aes128gcm">aes128gcm</a></h4><div id="rfc.section.6.3.2.p.1"><ul><li>Parameter Name: aes128gcm</li><li>Purpose: Provide an explicit input keying material value for the aes128gcm content coding.</li><li>Reference: this document</li></ul></div></section></section></section><section id="rfc.references"><h2 id="rfc.section.7"><a href="#rfc.section.7">7.</a> References</h2><section id="rfc.references.1"><h3 id="rfc.section.7.1"><a href="#rfc.section.7.1">7.1</a> Normative References</h3><dl class="dl-horizontal"><dt id="FIPS180-4">[FIPS180-4]</dt><dd>Department of Commerce, National Institute of Standards and Technology, U., “<a href="http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf">NIST FIPS 180-4, Secure Hash Standard</a>”, March&nbsp;2012, &lt;<a href="http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf">http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf</a>&gt;.</dd><dt id="RFC2119">[RFC2119]</dt><dd>Bradner, S., “<a href="https://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>”, BCP&nbsp;14, RFC&nbsp;2119, <a href="http://dx.doi.org/10.17487/RFC2119">DOI&nbsp;10.17487/RFC2119</a>, March&nbsp;1997, &lt;<a href="http://www.rfc-editor.org/info/rfc2119">http://www.rfc-editor.org/info/rfc2119</a>&gt;.</dd><dt id="RFC5116">[RFC5116]</dt><dd>McGrew, D., “<a href="https://tools.ietf.org/html/rfc5116">An Interface and Algorithms for Authenticated Encryption</a>”, RFC&nbsp;5116, <a href="http://dx.doi.org/10.17487/RFC5116">DOI&nbsp;10.17487/RFC5116</a>, January&nbsp;2008, &lt;<a href="http://www.rfc-editor.org/info/rfc5116">http://www.rfc-editor.org/info/rfc5116</a>&gt;.</dd><dt id="RFC5226">[RFC5226]</dt><dd>Narten, T. and H. Alvestrand, “<a href="https://tools.ietf.org/html/rfc5226">Guidelines for Writing an IANA Considerations Section in RFCs</a>”, BCP&nbsp;26, RFC&nbsp;5226, <a href="http://dx.doi.org/10.17487/RFC5226">DOI&nbsp;10.17487/RFC5226</a>, May&nbsp;2008, &lt;<a href="http://www.rfc-editor.org/info/rfc5226">http://www.rfc-editor.org/info/rfc5226</a>&gt;.</dd><dt id="RFC5869">[RFC5869]</dt><dd>Krawczyk, H. and P. Eronen, “<a href="https://tools.ietf.org/html/rfc5869">HMAC-based Extract-and-Expand Key Derivation Function (HKDF)</a>”, RFC&nbsp;5869, <a href="http://dx.doi.org/10.17487/RFC5869">DOI&nbsp;10.17487/RFC5869</a>, May&nbsp;2010, &lt;<a href="http://www.rfc-editor.org/info/rfc5869">http://www.rfc-editor.org/info/rfc5869</a>&gt;.</dd><dt id="RFC7230">[RFC7230]</dt><dd>Fielding, R., Ed. and J. Reschke, Ed., “<a href="https://tools.ietf.org/html/rfc7230">Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</a>”, RFC&nbsp;7230, <a href="http://dx.doi.org/10.17487/RFC7230">DOI&nbsp;10.17487/RFC7230</a>, June&nbsp;2014, &lt;<a href="http://www.rfc-editor.org/info/rfc7230">http://www.rfc-editor.org/info/rfc7230</a>&gt;.</dd><dt id="RFC7231">[RFC7231]</dt><dd>Fielding, R., Ed. and J. Reschke, Ed., “<a href="https://tools.ietf.org/html/rfc7231">Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content</a>”, RFC&nbsp;7231, <a href="http://dx.doi.org/10.17487/RFC7231">DOI&nbsp;10.17487/RFC7231</a>, June&nbsp;2014, &lt;<a href="http://www.rfc-editor.org/info/rfc7231">http://www.rfc-editor.org/info/rfc7231</a>&gt;.</dd><dt id="RFC7515">[RFC7515]</dt><dd>Jones, M., Bradley, J., and N. Sakimura, “<a href="https://tools.ietf.org/html/rfc7515">JSON Web Signature (JWS)</a>”, RFC&nbsp;7515, <a href="http://dx.doi.org/10.17487/RFC7515">DOI&nbsp;10.17487/RFC7515</a>, May&nbsp;2015, &lt;<a href="http://www.rfc-editor.org/info/rfc7515">http://www.rfc-editor.org/info/rfc7515</a>&gt;.</dd></dl></section><section id="rfc.references.2"><h3 id="rfc.section.7.2"><a href="#rfc.section.7.2">7.2</a> Informative References</h3><dl class="dl-horizontal"><dt id="AEBounds">[AEBounds]</dt><dd>Luykx, A. and K. Paterson, “<a href="http://www.isg.rhul.ac.uk/~kp/TLS-AEbounds.pdf">Limits on Authenticated Encryption Use in TLS</a>”, March&nbsp;2016, &lt;<a href="http://www.isg.rhul.ac.uk/~kp/TLS-AEbounds.pdf">http://www.isg.rhul.ac.uk/~kp/TLS-AEbounds.pdf</a>&gt;.</dd><dt id="RFC4880">[RFC4880]</dt><dd>Callas, J., Donnerhacke, L., Finney, H., Shaw, D., and R. Thayer, “<a href="https://tools.ietf.org/html/rfc4880">OpenPGP Message Format</a>”, RFC&nbsp;4880, <a href="http://dx.doi.org/10.17487/RFC4880">DOI&nbsp;10.17487/RFC4880</a>, November&nbsp;2007, &lt;<a href="http://www.rfc-editor.org/info/rfc4880">http://www.rfc-editor.org/info/rfc4880</a>&gt;.</dd><dt id="RFC5246">[RFC5246]</dt><dd>Dierks, T. and E. Rescorla, “<a href="https://tools.ietf.org/html/rfc5246">The Transport Layer Security (TLS) Protocol Version 1.2</a>”, RFC&nbsp;5246, <a href="http://dx.doi.org/10.17487/RFC5246">DOI&nbsp;10.17487/RFC5246</a>, August&nbsp;2008, &lt;<a href="http://www.rfc-editor.org/info/rfc5246">http://www.rfc-editor.org/info/rfc5246</a>&gt;.</dd><dt id="RFC5652">[RFC5652]</dt><dd>Housley, R., “<a href="https://tools.ietf.org/html/rfc5652">Cryptographic Message Syntax (CMS)</a>”, STD&nbsp;70, RFC&nbsp;5652, <a href="http://dx.doi.org/10.17487/RFC5652">DOI&nbsp;10.17487/RFC5652</a>, September&nbsp;2009, &lt;<a href="http://www.rfc-editor.org/info/rfc5652">http://www.rfc-editor.org/info/rfc5652</a>&gt;.</dd><dt id="RFC7233">[RFC7233]</dt><dd>Fielding, R., Ed., Lafon, Y., Ed., and J. Reschke, Ed., “<a href="https://tools.ietf.org/html/rfc7233">Hypertext Transfer Protocol (HTTP/1.1): Range Requests</a>”, RFC&nbsp;7233, <a href="http://dx.doi.org/10.17487/RFC7233">DOI&nbsp;10.17487/RFC7233</a>, June&nbsp;2014, &lt;<a href="http://www.rfc-editor.org/info/rfc7233">http://www.rfc-editor.org/info/rfc7233</a>&gt;.</dd><dt id="RFC7235">[RFC7235]</dt><dd>Fielding, R., Ed. and J. Reschke, Ed., “<a href="https://tools.ietf.org/html/rfc7235">Hypertext Transfer Protocol (HTTP/1.1): Authentication</a>”, RFC&nbsp;7235, <a href="http://dx.doi.org/10.17487/RFC7235">DOI&nbsp;10.17487/RFC7235</a>, June&nbsp;2014, &lt;<a href="http://www.rfc-editor.org/info/rfc7235">http://www.rfc-editor.org/info/rfc7235</a>&gt;.</dd><dt id="RFC7516">[RFC7516]</dt><dd>Jones, M. and J. Hildebrand, “<a href="https://tools.ietf.org/html/rfc7516">JSON Web Encryption (JWE)</a>”, RFC&nbsp;7516, <a href="http://dx.doi.org/10.17487/RFC7516">DOI&nbsp;10.17487/RFC7516</a>, May&nbsp;2015, &lt;<a href="http://www.rfc-editor.org/info/rfc7516">http://www.rfc-editor.org/info/rfc7516</a>&gt;.</dd><dt id="RFC7540">[RFC7540]</dt><dd>Belshe, M., Peon, R., and M. Thomson, Ed., “<a href="https://tools.ietf.org/html/rfc7540">Hypertext Transfer Protocol Version 2 (HTTP/2)</a>”, RFC&nbsp;7540, <a href="http://dx.doi.org/10.17487/RFC7540">DOI&nbsp;10.17487/RFC7540</a>, May&nbsp;2015, &lt;<a href="http://www.rfc-editor.org/info/rfc7540">http://www.rfc-editor.org/info/rfc7540</a>&gt;.</dd><dt id="XMLENC">[XMLENC]</dt><dd>Eastlake, D., Reagle, J., Imamura, T., Dillaway, B., and E. Simon, “<a href="http://www.w3.org/TR/xmlenc-core/">XML Encryption Syntax and Processing</a>”, W3C REC, December&nbsp;2002, &lt;<a href="http://www.w3.org/TR/xmlenc-core/">http://www.w3.org/TR/xmlenc-core/</a>&gt;.</dd></dl></section></section><section id="jwe"><h2 id="rfc.section.A" class="np"><a href="#rfc.section.A">A.</a>&nbsp;<a href="#jwe">JWE Mapping</a></h2><div id="rfc.section.A.p.1" class="avoidbreakafter"><p>The “aes128gcm” content coding can be considered as a sequence of JSON Web Encryption (JWE) objects <a href="#RFC7516"><cite title="JSON Web Encryption (JWE)">[RFC7516]</cite></a>, each corresponding to a single fixed size record that includes leading padding. The following transformations are applied to a JWE object that might be expressed using the JWE Compact Serialization:</p></div><div id="rfc.section.A.p.2"><ul><li>The JWE Protected Header is fixed to the value { “alg”: “dir”, “enc”: “A128GCM” }, describing direct encryption using AES-GCM with a 128-bit content encryption key. This header is not transmitted, it is instead implied by the value of the Content-Encoding header field.</li><li>The JWE Encrypted Key is empty, as stipulated by the direct encryption algorithm.</li><li>The JWE Initialization Vector (“iv”) for each record is set to the exclusive or of the 96-bit record sequence number, starting at zero, and a value derived from the input keying material (see <a href="#nonce" title="Nonce Derivation">Section&nbsp;2.3</a>). This value is also not transmitted.</li><li>The final value is the concatenated JWE Ciphertext and the JWE Authentication Tag, both expressed without base64url encoding. The “.” separator is omitted, since the length of these fields is known.</li></ul></div><div id="rfc.section.A.p.3" class="avoidbreakafter"><p>Thus, the example in <a href="#explicit" title="Encryption of a Response">Section&nbsp;4.1</a> can be rendered using the JWE Compact Serialization as:</p></div><div id="rfc.figure.u.11"><pre class="text">
eyAiYWxnIjogImRpciIsICJlbmMiOiAiQTEyOEdDTSIgfQ..31iQYc1v4a36EgyJ.
VDeU0XxaJkOJDAxPl7h9JD4.VfDeN0aKz-z36T3WWULsBQ
</pre></div><div id="rfc.section.A.p.4"><p>Where the first line represents the fixed JWE Protected Header, an empty JWE Encrypted Key, and the algorithmically-determined JWE Initialization Vector. The second line contains the encoded body, split into JWE Ciphertext and JWE Authentication Tag.</p></div></section><section id="acknowledgements"><h2 id="rfc.section.B"><a href="#rfc.section.B">B.</a>&nbsp;<a href="#acknowledgements">Acknowledgements</a></h2><div id="rfc.section.B.p.1"><p>Mark Nottingham was an original author of this document.</p></div><div id="rfc.section.B.p.2"><p>The following people provided valuable input: Richard Barnes, David Benjamin, Peter Beverloo, Mike Jones, Stephen Farrell, Adam Langley, John Mattsson, Eric Rescorla, and Jim Schaad.</p></div></section><section id="rfc.authors" class="avoidbreakinside"><h2><a href="#rfc.authors">Author's Address</a></h2><p><b>Martin Thomson</b><br>Mozilla<br>EMail: <a href="mailto:martin.thomson@gmail.com">martin.thomson@gmail.com</a></p></section></div></div></div><script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script><script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.2.0/js/bootstrap.min.js"></script></body></html>