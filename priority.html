<!DOCTYPE html>
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Extensible Prioritization Scheme for HTTP</title><script>
function anchorRewrite() {
  map = { };
  if (window.location.hash.length >= 1) {
    var fragid = window.location.hash.substr(1);
    if (fragid) {
      if (! document.getElementById(fragid)) {
        var prefix = "rfc.";
        var mapped = map[fragid];
        if (mapped) {
          window.location.hash = mapped;
        } else if (fragid.indexOf("section-") == 0) {
          window.location.hash = prefix + "section." + fragid.substring(8);
        } else if (fragid.indexOf("appendix-") == 0) {
          window.location.hash = prefix + "section." + fragid.substring(9);
        } else if (fragid.indexOf("s-") == 0) {
          var postfix = fragid.substring(2);
          if (postfix.startsWith("abstract")) {
            window.location.hash = prefix + postfix;
          } else if (postfix.startsWith("note-")) {
            window.location.hash = prefix + "note." + postfix.substring(5);
          } else {
            window.location.hash = prefix + "section." + postfix;
          }
        } else if (fragid.indexOf("p-") == 0) {
          var r = fragid.substring(2);
          var p = r.indexOf("-");
          if (p >= 0) {
            window.location.hash = prefix + "section." + r.substring(0, p) + ".p." + r.substring(p + 1);
          }
        }
      }
    }  
  }
}
window.addEventListener('hashchange', anchorRewrite);
window.addEventListener('DOMContentLoaded', anchorRewrite);
</script><!--Specified as xml2rfc-ext-css-contents--><style>
body {
  font: 16px "Helvetica Neue","Open Sans",Helvetica,Calibri,sans-serif;
  color: #333;
  font-size-adjust: 0.5;
  line-height: 24px;
  margin: 75px auto;
  max-width: 624px;
  padding: 0 5px;
}

.title, .filename, h1, h2, h3, h4, h5 {
  font: 16px "Roboto Condensed","Helvetica Neue","Open Sans",Helvetica,Calibri,sans-serif;
  font-size-adjust: 0.5;
  font-weight: bold;
  color: #333;
  line-height: 100%;
  margin: 1.2em 0 0.3em;
}
.title, #rfc\.title h1 { font-size: 32px; }
h1, section h1, h2, section h2, section h3, nav h2 { font-size: 20px; }
h3, section h4, h4, section h5 { font-size: 16px; }
h1 a[href], h2 a[href], h3 a[href], h4 a[href] {
  color: #333;
}

table {
  margin-left: 0em;
  border-collapse: collapse;
}
th {
  text-align: left;
  border-bottom: 2px solid #ddd;
}
td {
  border-top: 1px solid #ddd;
  vertical-align: top;
}
tr:nth-child(2n+1) > td,
tr:nth-child(2n+1) > th {
  background-color: #f9f9f9;
}
td.reference {
  max-width: 200px;
  border-top: none;
  padding-right: 1em;
}
.right {
  text-align: right;
}


table.header, table#rfc\.headerblock {
  width: 100%;
}
table.header td, table#rfc\.headerblock td {
  border: none;
  background-color: transparent;
  color: black;
  padding: 0;
}
.filename {
  display: block;
  color: rgb(119, 119, 119);
  font-size: 20px;
  font-weight: normal;
  line-height: 100%;
  margin: 10px 0 32px;
}
#rfc\.abstract+p, #rfc\.abstract+p code, #rfc\.abstract+p samp, #rfc\.abstract+p tt {
  font-size: 20px;
  line-height: 28px;
}

samp, tt, code, pre, span.tt {
  font-size: 13.5px;
  font-family: Consolas, monospace;
  font-size-adjust: none;
}
pre {
  background-color: #eee;
  border: 1px solid #ddd;
  overflow-x: auto;
  padding: 5px;
  margin: 5px;
}
.figure, caption {
  font-style: italic;
  margin: 0 1.5em;
  text-align: left;
}

address {
  margin: 16px 2px;
  line-height: 20px;
}
.vcard {
  font-style: normal;
}
.vcardline {
  display: block;
}
.vcardline .fn, address b {
  font-weight: normal;
}
.vcardline .hidden {
  display: none;
}

dl {
  margin-left: 1em;
}
dl.dl-horizontal: {
  margin-left: 0;
}
dl > dt {
  float: left;
  margin-right: 1em;
}
dl.nohang > dt {
  float: none;
}
dl > dd {
  margin-bottom: .5em;
}
dl.compact > dd {
  margin-bottom: 0em;
}
dl > dd > dl {
  margin-top: 0.5em;
  margin-bottom: 0em;
}
ul.empty {
  list-style-type: none;
}
ul.empty li {
  margin-top: .5em;
}

hr {
  border: 0;
  border-top: 1px solid #eee;
}
hr.noprint {
  display: none;
}

a {
  text-decoration: none;
}
a[href] {
  color: #2a6496;
}
a[href]:hover {
  background-color: #eee;
}

p, ol, ul, li {
  padding: 0;
}
p {
  margin: 0.5em 0;
}
ol, ul {
  margin: 0.2em 0 0.2em 2em;
}
li {
  margin: 0.2em 0;
}
address {
  font-style: normal;
}

ul.toc ul {
  margin: 0 0 0 2em;
}
ul.toc li {
  list-style: none;
  margin: 0;
}

@media screen and (min-width: 924px) {
  body {
    padding-right: 350px;
  }
  body>ul.toc, body>#rfc\.toc {
    position: fixed;
    bottom: 0;
    right: 0;
    right: calc(50vw - 500px);
    width: 300px;
    z-index: 1;
    overflow: auto;
    overscroll-behavior: contain;
  }
  body>#rfc\.toc {
    top: 55px;
  }
  body>ul.toc {
    top: 100px;
  }

  ul.toc {
    margin: 0 0 0 4px;
    font-size: 12px;
    line-height: 20px;
  }
  ul.toc ul {
    margin-left: 1.2em;
  }
}</style><link rel="Contents" href="#rfc.toc"><link rel="Author" href="#rfc.authors"><link rel="License" href="#rfc.copyrightnotice"><link rel="Chapter" title="1 Introduction" href="#rfc.section.1"><link rel="Chapter" title="2 Motivation for Replacing HTTP/2 Priorities" href="#rfc.section.2"><link rel="Chapter" title="3 Priority Parameters" href="#rfc.section.3"><link rel="Chapter" title="4 The Priority HTTP Header Field" href="#rfc.section.4"><link rel="Chapter" title="5 Reprioritization" href="#rfc.section.5"><link rel="Chapter" title="6 The PRIORITY_UPDATE Frame" href="#rfc.section.6"><link rel="Chapter" title="7 Merging Client- and Server-Driven Parameters" href="#rfc.section.7"><link rel="Chapter" title="8 Client Scheduling" href="#rfc.section.8"><link rel="Chapter" title="9 Server Scheduling" href="#rfc.section.9"><link rel="Chapter" title="10 Fairness" href="#rfc.section.10"><link rel="Chapter" title="11 Why use an End-to-End Header Field?" href="#rfc.section.11"><link rel="Chapter" title="12 Security Considerations" href="#rfc.section.12"><link rel="Chapter" title="13 IANA Considerations" href="#rfc.section.13"><link rel="Chapter" title="14 References" href="#rfc.section.14"><link rel="Appendix" title="A Acknowledgements" href="#rfc.section.A"><link rel="Appendix" title="B Change Log" href="#rfc.section.B"><meta name="viewport" content="initial-scale=1"><meta name="generator" content="http://greenbytes.de/tech/webdav/rfc2629.xslt, Revision 1.1327, 2020/09/24 11:13:36, XSLT vendor: libxslt http://xmlsoft.org/XSLT/, via: https://github.com/cabo/kramdown-rfc2629 version 1.3.10"><meta name="keywords" content="Internet-Draft"><link rel="schema.dcterms" href="http://purl.org/dc/terms/"><meta name="dcterms.creator" content="Oku, K."><meta name="dcterms.creator" content="Pardue, L."><meta name="dcterms.issued" content="2020-10-05"><meta name="dcterms.abstract" content="This document describes a scheme for prioritizing HTTP responses. This scheme expresses the priority of each HTTP response using absolute values, rather than as a relative relationship between a group of HTTP responses.This document defines the Priority header field for communicating the initial priority in an HTTP version-independent manner, as well as HTTP/2 and HTTP/3 frames for reprioritizing the responses. These share a common format structure that is designed to provide future extensibility."><meta name="description" content="This document describes a scheme for prioritizing HTTP responses. This scheme expresses the priority of each HTTP response using absolute values, rather than as a relative relationship between a group of HTTP responses.This document defines the Priority header field for communicating the initial priority in an HTTP version-independent manner, as well as HTTP/2 and HTTP/3 frames for reprioritizing the responses. These share a common format structure that is designed to provide future extensibility."></head><body><header><table class="header" id="rfc.headerblock"><tbody><tr><td class="left">HTTP Working Group</td><td class="right">K. Oku</td></tr><tr><td class="left">Internet-Draft</td><td class="right">Fastly</td></tr><tr><td class="left">Intended status: Standards Track</td><td class="right">L. Pardue</td></tr><tr><td class="left">Expires: April 8, 2021</td><td class="right">Cloudflare</td></tr><tr><td class="left"></td><td class="right">October 5, 2020</td></tr></tbody></table><div id="rfc.title"><h1>Extensible Prioritization Scheme for HTTP</h1><div class="filename"><a href="https://datatracker.ietf.org/doc/draft-ietf-httpbis-priority" class="smpl">draft-ietf-httpbis-priority-latest</a></div></div></header><section><h2 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h2><div id="rfc.abstract.p.1"><p>This document describes a scheme for prioritizing HTTP responses. This scheme expresses the priority of each HTTP response using absolute values, rather than as a relative relationship between a group of HTTP responses.</p></div><div id="rfc.abstract.p.2"><p>This document defines the Priority header field for communicating the initial priority in an HTTP version-independent manner, as well as HTTP/2 and HTTP/3 frames for reprioritizing the responses. These share a common format structure that is designed to provide future extensibility.</p></div></section><section class="note"><h2 id="rfc.note.1"><a href="#rfc.note.1">Note to Readers</a></h2><div id="rfc.note.1.p.1"><p><em>RFC EDITOR: please remove this section before publication</em></p></div><div id="rfc.note.1.p.2"><p>Discussion of this draft takes place on the HTTP working group mailing list (ietf-http-wg@w3.org), which is archived at <a href="https://lists.w3.org/Archives/Public/ietf-http-wg/">https://lists.w3.org/Archives/Public/ietf-http-wg/</a>.</p></div><div id="rfc.note.1.p.3"><p>Working Group information can be found at <a href="https://httpwg.org/">https://httpwg.org/</a>; source code and issues list for this draft can be found at <a href="https://github.com/httpwg/http-extensions/labels/priorities">https://github.com/httpwg/http-extensions/labels/priorities</a>.</p></div></section><section id="rfc.status"><h2><a href="#rfc.status">Status of this Memo</a></h2><div id="rfc.boilerplate.1.p.1"><p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p></div><div id="rfc.boilerplate.1.p.2"><p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF). Note that other groups may also distribute working documents as Internet-Drafts. The list of current Internet-Drafts is at <a href="https://datatracker.ietf.org/drafts/current/">https://datatracker.ietf.org/drafts/current/</a>.</p></div><div id="rfc.boilerplate.1.p.3"><p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time. It is inappropriate to use Internet-Drafts as reference material or to cite them other than as “work in progress”.</p></div><div id="rfc.boilerplate.1.p.4"><p>This Internet-Draft will expire on April 8, 2021.</p></div></section><section id="rfc.copyrightnotice"><h2><a href="#rfc.copyrightnotice">Copyright Notice</a></h2><div id="rfc.boilerplate.2.p.1"><p>Copyright (c) 2020 IETF Trust and the persons identified as the document authors. All rights reserved.</p></div><div id="rfc.boilerplate.2.p.2"><p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (<a href="https://trustee.ietf.org/license-info">https://trustee.ietf.org/license-info</a>) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p></div></section><hr class="noprint"><nav id="rfc.toc"><h2 class="np"><a href="#rfc.toc">Table of Contents</a></h2><ul class="toc"><li><a href="#rfc.section.1">1.</a>   <a href="#introduction">Introduction</a><ul><li><a href="#rfc.section.1.1">1.1.</a>   <a href="#notational-conventions">Notational Conventions</a></li></ul></li><li><a href="#rfc.section.2">2.</a>   <a href="#motivation">Motivation for Replacing HTTP/2 Priorities</a><ul><li><a href="#rfc.section.2.1">2.1.</a>   <a href="#disabling">Disabling HTTP/2 Priorities</a></li></ul></li><li><a href="#rfc.section.3">3.</a>   <a href="#parameters">Priority Parameters</a><ul><li><a href="#rfc.section.3.1">3.1.</a>   <a href="#urgency">Urgency</a></li><li><a href="#rfc.section.3.2">3.2.</a>   <a href="#incremental">Incremental</a></li><li><a href="#rfc.section.3.3">3.3.</a>   <a href="#defining-new-parameters">Defining New Parameters</a></li></ul></li><li><a href="#rfc.section.4">4.</a>   <a href="#header-field">The Priority HTTP Header Field</a></li><li><a href="#rfc.section.5">5.</a>   <a href="#reprioritization">Reprioritization</a></li><li><a href="#rfc.section.6">6.</a>   <a href="#frame">The PRIORITY_UPDATE Frame</a><ul><li><a href="#rfc.section.6.1">6.1.</a>   <a href="#h2-update-frame">HTTP/2 PRIORITY_UPDATE Frame</a></li><li><a href="#rfc.section.6.2">6.2.</a>   <a href="#h3-update-frame">HTTP/3 PRIORITY_UPDATE Frame</a></li></ul></li><li><a href="#rfc.section.7">7.</a>   <a href="#merging">Merging Client- and Server-Driven Parameters</a></li><li><a href="#rfc.section.8">8.</a>   <a href="#client-scheduling">Client Scheduling</a></li><li><a href="#rfc.section.9">9.</a>   <a href="#server-scheduling">Server Scheduling</a></li><li><a href="#rfc.section.10">10.</a>   <a href="#fairness">Fairness</a><ul><li><a href="#rfc.section.10.1">10.1.</a>   <a href="#coalescing-intermediaries">Coalescing Intermediaries</a></li><li><a href="#rfc.section.10.2">10.2.</a>   <a href="#http1x-back-ends">HTTP/1.x Back Ends</a></li><li><a href="#rfc.section.10.3">10.3.</a>   <a href="#intentional-introduction-of-unfairness">Intentional Introduction of Unfairness</a></li></ul></li><li><a href="#rfc.section.11">11.</a>   <a href="#why-use-an-end-to-end-header-field">Why use an End-to-End Header Field?</a></li><li><a href="#rfc.section.12">12.</a>   <a href="#security-considerations">Security Considerations</a></li><li><a href="#rfc.section.13">13.</a>   <a href="#iana-considerations">IANA Considerations</a></li><li><a href="#rfc.section.14">14.</a>   <a href="#rfc.references">References</a><ul><li><a href="#rfc.section.14.1">14.1.</a>   <a href="#rfc.references.1">Normative References</a></li><li><a href="#rfc.section.14.2">14.2.</a>   <a href="#rfc.references.2">Informative References</a></li></ul></li><li><a href="#rfc.section.A">Appendix A.</a>   <a href="#acknowledgements">Acknowledgements</a></li><li><a href="#rfc.section.B">Appendix B.</a>   <a href="#change-log">Change Log</a><ul><li><a href="#rfc.section.B.1">B.1.</a>   <a href="#since-draft-ietf-httpbis-priority-01">Since draft-ietf-httpbis-priority-01</a></li><li><a href="#rfc.section.B.2">B.2.</a>   <a href="#since-draft-ietf-httpbis-priority-00">Since draft-ietf-httpbis-priority-00</a></li><li><a href="#rfc.section.B.3">B.3.</a>   <a href="#since-draft-kazuho-httpbis-priority-04">Since draft-kazuho-httpbis-priority-04</a></li><li><a href="#rfc.section.B.4">B.4.</a>   <a href="#since-draft-kazuho-httpbis-priority-03">Since draft-kazuho-httpbis-priority-03</a></li><li><a href="#rfc.section.B.5">B.5.</a>   <a href="#since-draft-kazuho-httpbis-priority-02">Since draft-kazuho-httpbis-priority-02</a></li><li><a href="#rfc.section.B.6">B.6.</a>   <a href="#since-draft-kazuho-httpbis-priority-01">Since draft-kazuho-httpbis-priority-01</a></li><li><a href="#rfc.section.B.7">B.7.</a>   <a href="#since-draft-kazuho-httpbis-priority-00">Since draft-kazuho-httpbis-priority-00</a></li></ul></li><li><a href="#rfc.authors">Authors' Addresses</a></li></ul><ul class="toc"><li>Figures<ul><li><a href="#rfc.figure.1">Figure 1: HTTP/2 PRIORITY_UPDATE Frame Payload</a></li><li><a href="#rfc.figure.2">Figure 2: HTTP/3 PRIORITY_UPDATE Frame</a></li></ul></li></ul></nav><section id="introduction"><h2 id="rfc.section.1" class="np"><a href="#rfc.section.1">1.</a> <a href="#introduction">Introduction</a></h2><div id="rfc.section.1.p.1"><p>It is common for an HTTP (<a href="#RFC7230"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing">[RFC7230]</cite></a>) resource representation to have relationships to one or more other resources. Clients will often discover these relationships while processing a retrieved representation, leading to further retrieval requests. Meanwhile, the nature of the relationship determines whether the client is blocked from continuing to process locally available resources. For example, visual rendering of an HTML document could be blocked by the retrieval of a CSS file that the document refers to. In contrast, inline images do not block rendering and get drawn incrementally as the chunks of the images arrive.</p></div><div id="rfc.section.1.p.2"><p>To provide meaningful presentation of a document at the earliest moment, it is important for an HTTP server to prioritize the HTTP responses, or the chunks of those HTTP responses, that it sends.</p></div><div id="rfc.section.1.p.3"><p>HTTP/2 (<a href="#RFC7540"><cite title="Hypertext Transfer Protocol Version 2 (HTTP/2)">[RFC7540]</cite></a>) provides such a prioritization scheme. A client sends a series of PRIORITY frames to communicate to the server a “priority tree”; this represents the client’s preferred ordering and weighted distribution of the bandwidth among the HTTP responses. However, the design and implementation of this scheme has been observed to have shortcomings, explained in <a href="#motivation" title="Motivation for Replacing HTTP/2 Priorities">Section 2</a>.</p></div><div id="rfc.section.1.p.4"><p>This document defines the Priority HTTP header field that can be used by both client and server to specify the precedence of HTTP responses in a standardized, extensible, protocol-version-independent, end-to-end format. Along with the protocol-version-specific frame for reprioritization, this prioritization scheme acts as a substitute for the original prioritization scheme of HTTP/2.</p></div><section id="notational-conventions"><h3 id="rfc.section.1.1"><a href="#rfc.section.1.1">1.1.</a> <a href="#notational-conventions">Notational Conventions</a></h3><div id="rfc.section.1.1.p.1"><p>The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in <a href="#RFC2119"><cite title="Key words for use in RFCs to Indicate Requirement Levels">[RFC2119]</cite></a>.</p></div><div id="rfc.section.1.1.p.2"><p>The terms sf-token and sf-boolean are imported from <a href="#STRUCTURED-FIELDS"><cite title="Structured Field Values for HTTP">[STRUCTURED-FIELDS]</cite></a>.</p></div><div id="rfc.section.1.1.p.3"><p>Example HTTP requests and responses use the HTTP/2-style formatting from <a href="#RFC7540"><cite title="Hypertext Transfer Protocol Version 2 (HTTP/2)">[RFC7540]</cite></a>.</p></div><div id="rfc.section.1.1.p.4"><p>This document uses the variable-length integer encoding from <a href="#I-D.ietf-quic-transport"><cite title="QUIC: A UDP-Based Multiplexed and Secure Transport">[I-D.ietf-quic-transport]</cite></a>.</p></div><div id="rfc.section.1.1.p.5"><p>The term control stream is used to describe the HTTP/2 stream with identifier 0x0, and HTTP/3 control stream; see <a href="#I-D.ietf-quic-http"><cite title="Hypertext Transfer Protocol Version 3 (HTTP/3)">[I-D.ietf-quic-http]</cite></a>, Section 6.2.1.</p></div></section></section><section id="motivation"><h2 id="rfc.section.2"><a href="#rfc.section.2">2.</a> <a href="#motivation">Motivation for Replacing HTTP/2 Priorities</a></h2><div id="rfc.section.2.p.1"><p>An important feature of any implementation of a protocol that provides multiplexing is the ability to prioritize the sending of information. This was an important realization in the design of HTTP/2. Prioritization is a difficult problem, so it will always be suboptimal, particularly if one endpoint operates in ignorance of the needs of its peer.</p></div><div id="rfc.section.2.p.2"><p>HTTP/2 introduced a complex prioritization signaling scheme that used a combination of dependencies and weights, formed into an unbalanced tree. This scheme has suffered from poor deployment and interoperability.</p></div><div id="rfc.section.2.p.3"><p>The rich flexibility of client-driven HTTP/2 prioritization tree building is rarely exercised. Experience has shown that clients tend to choose a single model optimized for a web use case and experiment within the model constraints, or do nothing at all. Furthermore, many clients build their prioritization tree in a unique way, which makes it difficult for servers to understand their intent and act or intervene accordingly.</p></div><div id="rfc.section.2.p.4"><p>Many HTTP/2 server implementations do not include support for the priority scheme. Some instead favor custom server-driven schemes based on heuristics or other hints, such as resource content type or request generation order. For example, a server, with knowledge of the document structure, might want to prioritize the delivery of images that are critical to user experience above other images, but below the CSS files. Since client trees vary, it is impossible for the server to determine how such images should be prioritized against other responses.</p></div><div id="rfc.section.2.p.5"><p>The HTTP/2 scheme allows intermediaries to coalesce multiple client trees into a single tree that is used for a single upstream HTTP/2 connection. However, most intermediaries do not support this. The scheme does not define a method that can be used by a server to express the priority of a response. Without such a method, intermediaries cannot coordinate client-driven and server-driven priorities.</p></div><div id="rfc.section.2.p.6"><p>HTTP/2 describes denial-of-service considerations for implementations. On 2019-08-13 Netflix issued an advisory notice about the discovery of several resource exhaustion vectors affecting multiple HTTP/2 implementations. One attack, <a href="#CVE-2019-9513"><cite title="CVE-2019-9513">[CVE-2019-9513]</cite></a> aka “Resource Loop”, is based on manipulation of the priority tree.</p></div><div id="rfc.section.2.p.7"><p>The HTTP/2 scheme depends on in-order delivery of signals, leading to challenges in porting the scheme to protocols that do not provide global ordering. For example, the scheme cannot be used in HTTP/3 <a href="#I-D.ietf-quic-http"><cite title="Hypertext Transfer Protocol Version 3 (HTTP/3)">[I-D.ietf-quic-http]</cite></a> without changing the signal and its processing.</p></div><div id="rfc.section.2.p.8"><p>Considering the problems with deployment and adaptability to HTTP/3, retaining the HTTP/2 priority scheme increases the complexity of the entire system without any evidence that the value it provides offsets that complexity. In fact, multiple experiments from independent research have shown that simpler schemes can reach at least equivalent performance characteristics compared to the more complex HTTP/2 setups seen in practice, at least for the web use case.</p></div><section id="disabling"><h3 id="rfc.section.2.1"><a href="#rfc.section.2.1">2.1.</a> <a href="#disabling">Disabling HTTP/2 Priorities</a></h3><div id="rfc.section.2.1.p.1"><p>The problems and insights set out above are motivation for allowing endpoints to opt out of using the HTTP/2 priority scheme, in favor of using an alternative such as the scheme defined in this specification. The SETTINGS_DEPRECATE_HTTP2_PRIORITIES setting described below enables endpoints to understand their peer’s intention. The value of the parameter MUST be 0 or 1. Any value other than 0 or 1 MUST be treated as a connection error (see <a href="#RFC7540"><cite title="Hypertext Transfer Protocol Version 2 (HTTP/2)">[RFC7540]</cite></a>, Section 5.4.1) of type PROTOCOL_ERROR.</p></div><div id="rfc.section.2.1.p.2"><p>Endpoints MUST send this SETTINGS parameter as part of the first SETTINGS frame. When the peer receives the first SETTINGS frame, it learns the sender has deprecated the HTTP/2 priority scheme if it receives the SETTINGS_DEPRECATE_HTTP2_PRIORITIES parameter with the value of 1.</p></div><div id="rfc.section.2.1.p.3"><p>A sender MUST NOT change the SETTINGS_DEPRECATE_HTTP2_PRIORITIES parameter value after the first SETTINGS frame. Detection of a change by a receiver MUST be treated as a connection error of type PROTOCOL_ERROR.</p></div><div id="rfc.section.2.1.p.4"><p>Until the client receives the SETTINGS frame from the server, the client SHOULD send both the priority signal defined in the HTTP/2 priority scheme and also that of this prioritization scheme. Once the client learns that the HTTP/2 priority scheme is deprecated, it SHOULD stop sending the HTTP/2 priority signals. If the client learns that the HTTP/2 priority scheme is not deprecated, it SHOULD stop sending PRIORITY_UPDATE frames (<a href="#h2-update-frame" title="HTTP/2 PRIORITY_UPDATE Frame">Section 6.1</a>), but MAY continue sending the Priority header field (<a href="#header-field" title="The Priority HTTP Header Field">Section 4</a>), as it is an end-to-end signal that might be useful to nodes behind the server that the client is directly connected to.</p></div><div id="rfc.section.2.1.p.5"><p>The SETTINGS frame precedes any priority signal sent from a client in HTTP/2, so a server can determine if it should respect the HTTP/2 scheme before building state. A server that receives SETTINGS_DEPRECATE_HTTP2_PRIORITIES MUST ignore HTTP/2 priority signals.</p></div><div id="rfc.section.2.1.p.6"><p>Where both endpoints disable HTTP/2 priorities, the client is expected to send this scheme’s priority signal. Handling of omitted signals is described in <a href="#parameters" title="Priority Parameters">Section 3</a>.</p></div></section></section><section id="parameters"><h2 id="rfc.section.3"><a href="#rfc.section.3">3.</a> <a href="#parameters">Priority Parameters</a></h2><div id="rfc.section.3.p.1"><p>The priority information is a sequence of key-value pairs, providing room for future extensions. Each key-value pair represents a priority parameter.</p></div><div id="rfc.section.3.p.2"><p>The Priority HTTP header field (<a href="#header-field" title="The Priority HTTP Header Field">Section 4</a>) is an end-to-end way to transmit this set of parameters when a request or a response is issued. In order to reprioritize a request, HTTP-version-specific frames (<a href="#h2-update-frame" title="HTTP/2 PRIORITY_UPDATE Frame">Section 6.1</a> and <a href="#h3-update-frame" title="HTTP/3 PRIORITY_UPDATE Frame">Section 6.2</a>) are used by clients to transmit the same information on a single hop. If intermediaries want to specify prioritization on a multiplexed HTTP connection, they SHOULD use a PRIORITY_UPDATE frame and SHOULD NOT change the Priority header field.</p></div><div id="rfc.section.3.p.3"><p>In both cases, the set of priority parameters is encoded as a Structured Fields Dictionary (<a href="#STRUCTURED-FIELDS"><cite title="Structured Field Values for HTTP">[STRUCTURED-FIELDS]</cite></a>).</p></div><div id="rfc.section.3.p.4"><p>This document defines the urgency(<span class="tt">u</span>) and incremental(<span class="tt">i</span>) parameters. When receiving an HTTP request that does not carry these priority parameters, a server SHOULD act as if their default values were specified. Note that handling of omitted parameters is different when processing an HTTP response; see <a href="#merging" title="Merging Client- and Server-Driven Parameters">Section 7</a>.</p></div><div id="rfc.section.3.p.5"><p>Unknown parameters, parameters with out-of-range values or values of unexpected types MUST be ignored.</p></div><section id="urgency"><h3 id="rfc.section.3.1"><a href="#rfc.section.3.1">3.1.</a> <a href="#urgency">Urgency</a></h3><div id="rfc.section.3.1.p.1"><p>The urgency parameter (<span class="tt">u</span>) takes an integer between 0 and 7, in descending order of priority. This range provides sufficient granularity for prioritizing responses for ordinary web browsing, at minimal complexity.</p></div><div id="rfc.section.3.1.p.2"><p>The value is encoded as an sf-integer. The default value is 3.</p></div><div id="rfc.section.3.1.p.3"><p>This parameter indicates the sender’s recommendation, based on the expectation that the server would transmit HTTP responses in the order of their urgency values if possible. The smaller the value, the higher the precedence.</p></div><div id="rfc.section.3.1.p.4" class="avoidbreakafter"><p>The following example shows a request for a CSS file with the urgency set to <span class="tt">0</span>:</p></div><div id="rfc.figure.u.1"><div><pre class="text">
:method = GET
:scheme = https
:authority = example.net
:path = /style.css
priority = u=0
</pre></div></div><div id="rfc.section.3.1.p.5"><p>A client that fetches a document that likely consists of multiple HTTP resources (e.g., HTML) SHOULD assign the default urgency level to the main resource. This convention allows servers to refine the urgency using knowledge specific to the web-site (see <a href="#merging" title="Merging Client- and Server-Driven Parameters">Section 7</a>).</p></div><div id="rfc.section.3.1.p.6"><p>The lowest urgency level (7) is reserved for background tasks such as delivery of software updates. This urgency level SHOULD NOT be used for fetching responses that have impact on user interaction.</p></div></section><section id="incremental"><h3 id="rfc.section.3.2"><a href="#rfc.section.3.2">3.2.</a> <a href="#incremental">Incremental</a></h3><div id="rfc.section.3.2.p.1"><p>The incremental parameter (<span class="tt">i</span>) takes an sf-boolean as the value that indicates if an HTTP response can be processed incrementally, i.e. provide some meaningful output as chunks of the response arrive.</p></div><div id="rfc.section.3.2.p.2"><p>The default value of the incremental parameter is false (<span class="tt">0</span>).</p></div><div id="rfc.section.3.2.p.3"><p>A server might distribute the bandwidth of a connection between incremental responses that share the same urgency, hoping that providing those responses in parallel would be more helpful to the client than delivering the responses one by one.</p></div><div id="rfc.section.3.2.p.4"><p>If a client makes concurrent requests with the incremental parameter set to false, there is no benefit serving responses in parallel because the client is not going to process those responses incrementally. Serving non-incremental responses one by one, in the order in which those requests were generated is considered to be the best strategy.</p></div><div id="rfc.section.3.2.p.5"><p>The following example shows a request for a JPEG file with the urgency parameter set to <span class="tt">5</span> and the incremental parameter set to <span class="tt">true</span>.</p></div><div id="rfc.figure.u.2"><div><pre class="text">
:method = GET
:scheme = https
:authority = example.net
:path = /image.jpg
priority = u=5, i
</pre></div></div></section><section id="defining-new-parameters"><h3 id="rfc.section.3.3"><a href="#rfc.section.3.3">3.3.</a> <a href="#defining-new-parameters">Defining New Parameters</a></h3><div id="rfc.section.3.3.p.1"><p>When attempting to extend priorities, care must be taken to ensure any use of existing parameters leaves them either unchanged or modified in a way that is backwards compatible for peers that are unaware of the extended meaning.</p></div><div id="rfc.section.3.3.p.2"><p>For example, if there is a need to provide more granularity than eight urgency levels, it would be possible to subdivide the range using an additional parameter. Implementations that do not recognize the parameter can safely continue to use the less granular eight levels.</p></div><div id="rfc.section.3.3.p.3"><p>Alternatively, the urgency can be augmented. For example, a graphical user agent could send a <span class="tt">visible</span> parameter to indicate if the resource being requested is within the viewport.</p></div></section></section><section id="header-field"><h2 id="rfc.section.4"><a href="#rfc.section.4">4.</a> <a href="#header-field">The Priority HTTP Header Field</a></h2><div id="rfc.section.4.p.1"><p>The Priority HTTP header field can appear in requests and responses. A client uses it to specify the priority of the response. A server uses it to inform the client that the priority was overwritten. An intermediary can use the Priority information from client requests and server responses to correct or amend the precedence to suit it (see <a href="#merging" title="Merging Client- and Server-Driven Parameters">Section 7</a>).</p></div><div id="rfc.section.4.p.2"><p>The Priority header field is an end-to-end signal of the request priority from the client or the response priority from the server.</p></div><div id="rfc.section.4.p.3"><p>As is the ordinary case for HTTP caching (<a href="#RFC7234"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Caching">[RFC7234]</cite></a>), a response with a Priority header field might be cached and re-used for subsequent requests. When an origin server generates the Priority response header field based on properties of an HTTP request it receives, the server is expected to control the cacheability or the applicability of the cached response, by using header fields that control the caching behavior (e.g., Cache-Control, Vary).</p></div><div id="rfc.section.4.p.4"><p>An endpoint that fails to parse the Priority header field SHOULD use default parameter values.</p></div></section><section id="reprioritization"><h2 id="rfc.section.5"><a href="#rfc.section.5">5.</a> <a href="#reprioritization">Reprioritization</a></h2><div id="rfc.section.5.p.1"><p>After a client sends a request, it may be beneficial to change the priority of the response. As an example, a web browser might issue a prefetch request for a JavaScript file with the urgency parameter of the Priority request header field set to <span class="tt">u=7</span> (background). Then, when the user navigates to a page which references the new JavaScript file, while the prefetch is in progress, the browser would send a reprioritization signal with the priority field value set to <span class="tt">u=0</span>. The PRIORITY_UPDATE frame (<a href="#frame" title="The PRIORITY_UPDATE Frame">Section 6</a>) can be used for such reprioritization.</p></div></section><section id="frame"><h2 id="rfc.section.6"><a href="#rfc.section.6">6.</a> <a href="#frame">The PRIORITY_UPDATE Frame</a></h2><div id="rfc.section.6.p.1"><p>This document specifies a new PRIORITY_UPDATE frame for HTTP/2 (<a href="#RFC7540"><cite title="Hypertext Transfer Protocol Version 2 (HTTP/2)">[RFC7540]</cite></a>) and HTTP/3 (<a href="#I-D.ietf-quic-http"><cite title="Hypertext Transfer Protocol Version 3 (HTTP/3)">[I-D.ietf-quic-http]</cite></a>). It carries priority parameters and references the target of the prioritization based on a version-specific identifier. In HTTP/2, this identifier is the Stream ID; in HTTP/3, the identifier is either the Stream ID or Push ID. Unlike the Priority header field, the PRIORITY_UPDATE frame is a hop-by-hop signal.</p></div><div id="rfc.section.6.p.2"><p>PRIORITY_UPDATE frames are sent by clients on the control stream, allowing them to be sent independent from the stream that carries the response. This means they can be used to reprioritize a response or a push stream; or signal the initial priority of a response instead of the Priority header field.</p></div><div id="rfc.section.6.p.3"><p>A PRIORITY_UPDATE frame communicates a complete set of all parameters in the Priority Field Value field. Omitting a parameter is a signal to use the parameter’s default value. Failure to parse the Priority Field Value MUST be treated as a connection error. In HTTP/2 the error is of type PROTOCOL_ERROR; in HTTP/3 the error is of type H3_FRAME_ERROR.</p></div><div id="rfc.section.6.p.4"><p>A client MAY send a PRIORITY_UPDATE frame before the stream that it references is open. Furthermore, HTTP/3 offers no guaranteed ordering across streams, which could cause the frame to be received earlier than intended. Either case leads to a race condition where a server receives a PRIORITY_UPDATE frame that references a request stream that is yet to be opened. To solve this condition, for the purposes of scheduling, the most recently received PRIORITY_UPDATE frame can be considered as the most up-to-date information that overrides any other signal. Servers SHOULD buffer the most recently received PRIORITY_UPDATE frame and apply it once the referenced stream is opened. Holding PRIORITY_UPDATE frames for each stream requires server resources, which can can be bound by local implementation policy. (TODO: consider resolving #1261, and adding more text about bounds). Although there is no limit to the number PRIORITY_UPDATES that can be sent, storing only the most recently received frame limits resource commitment.</p></div><section id="h2-update-frame"><h3 id="rfc.section.6.1"><a href="#rfc.section.6.1">6.1.</a> <a href="#h2-update-frame">HTTP/2 PRIORITY_UPDATE Frame</a></h3><div id="rfc.section.6.1.p.1"><p>The HTTP/2 PRIORITY_UPDATE frame (type=0x10) is used by clients to signal the initial priority of a response, or to reprioritize a response or push stream. It carries the stream ID of the response and the priority in ASCII text, using the same representation as the Priority header field value.</p></div><div id="rfc.section.6.1.p.2"><p>The Stream Identifier field (<a href="#RFC7540"><cite title="Hypertext Transfer Protocol Version 2 (HTTP/2)">[RFC7540]</cite></a>, Section 4.1) in the PRIORITY_UPDATE frame header MUST be zero (0x0). Receiving a PRIORITY_UPDATE frame with a field of any other value MUST be treated as a connection error of type PROTOCOL_ERROR.</p></div><div id="fig-h2-reprioritization-frame"></div><div id="rfc.figure.1"><div><pre class="drawing">
  0                   1                   2                   3
  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +---------------------------------------------------------------+
 |R|                Prioritized Stream ID (31)                   |
 +---------------------------------------------------------------+
 |                   Priority Field Value (*)                  ...
 +---------------------------------------------------------------+
</pre></div></div><p class="figure">Figure 1: HTTP/2 PRIORITY_UPDATE Frame Payload</p><div id="rfc.section.6.1.p.3" class="avoidbreakafter"><p>The PRIORITY_UPDATE frame payload has the following fields:</p></div><div id="rfc.section.6.1.p.4"><dl class="compact"><dt>R:</dt><dd>A reserved 1-bit field. The semantics of this bit are undefined, and the bit MUST remain unset (0x0) when sending and MUST be ignored when receiving.</dd><dt>Prioritized Stream ID:</dt><dd>A 31-bit stream identifier for the stream that is the target of the priority update.</dd><dt>Priority Field Value:</dt><dd>The priority update value in ASCII text, encoded using Structured Fields.</dd></dl></div><div id="rfc.section.6.1.p.5"><p>The Prioritized Stream ID MUST be within the stream limit. If a server receives a PRIORITY_UPDATE with a Prioritized Stream ID that is beyond the stream limits, this SHOULD be treated as a connection error of type PROTOCOL_ERROR.</p></div><div id="rfc.section.6.1.p.6"><p>If a PRIORITY_UPDATE frame is received with a Prioritized Stream ID of 0x0, the recipient MUST respond with a connection error of type PROTOCOL_ERROR.</p></div><div id="rfc.section.6.1.p.7"><p>If a client receives a PRIORITY_UPDATE frame, it MUST respond with a connection error of type PROTOCOL_ERROR.</p></div></section><section id="h3-update-frame"><h3 id="rfc.section.6.2"><a href="#rfc.section.6.2">6.2.</a> <a href="#h3-update-frame">HTTP/3 PRIORITY_UPDATE Frame</a></h3><div id="rfc.section.6.2.p.1"><p>The HTTP/3 PRIORITY_UPDATE frame (type=0xF0700 or 0xF0701) is used by clients to signal the initial priority of a response, or to reprioritize a response or push stream. It carries the identifier of the element that is being prioritized, and the updated priority in ASCII text, using the same representation as that of the Priority header field value. PRIORITY_UPDATE with a frame type of 0xF0700 is used for request streams, while PRIORITY_UPDATE with a frame type of 0xF0701 is used for push streams.</p></div><div id="rfc.section.6.2.p.2"><p>The PRIORITY_UPDATE frame MUST be sent on the client control stream (<a href="#I-D.ietf-quic-http"><cite title="Hypertext Transfer Protocol Version 3 (HTTP/3)">[I-D.ietf-quic-http]</cite></a>, Section 6.2.1). Receiving a PRIORITY_UPDATE frame on a stream other than the client control stream MUST be treated as a connection error of type H3_FRAME_UNEXPECTED.</p></div><div id="fig-h3-reprioritization-frame"></div><div id="rfc.figure.2"><div><pre class="drawing">
HTTP/3 PRIORITY_UPDATE Frame {
  Type (i) = 0xF0700..0xF0701,
  Length (i),
  Prioritized Element ID (i),
  Priority Field Value (..),
}
</pre></div></div><p class="figure">Figure 2: HTTP/3 PRIORITY_UPDATE Frame</p><div id="rfc.section.6.2.p.3" class="avoidbreakafter"><p>The PRIORITY_UPDATE frame payload has the following fields:</p></div><div id="rfc.section.6.2.p.4"><dl class="compact"><dt>Prioritized Element ID:</dt><dd>The stream ID or push ID that is the target of the priority update.</dd><dt>Priority Field Value:</dt><dd>The priority update value in ASCII text, encoded using Structured Fields.</dd></dl></div><div id="rfc.section.6.2.p.5"><p>The request-stream variant of PRIORITY_UPDATE (type=0xF0700) MUST reference a request stream. If a server receives a PRIORITY_UPDATE (type=0xF0700) for a Stream ID that is not a request stream, this MUST be treated as a connection error of type H3_ID_ERROR. The Stream ID MUST be within the client-initiated bidirectional stream limit. If a server receives a PRIORITY_UPDATE (type=0xF0700) with a Stream ID that is beyond the stream limits, this SHOULD be treated as a connection error of type H3_ID_ERROR.</p></div><div id="rfc.section.6.2.p.6"><p>The push-stream variant PRIORITY_UPDATE (type=0xF0701) MUST reference a promised push stream. If a server receives a PRIORITY_UPDATE (type=0xF0701) with a Push ID that is greater than the maximum Push ID or which has not yet been promised, this MUST be treated as a connection error of type H3_ID_ERROR.</p></div><div id="rfc.section.6.2.p.7"><p>PRIORITY_UPDATE frames of either type are only sent by clients. If a client receives a PRIORITY_UPDATE frame, this MUST be treated as a connection error of type H3_FRAME_UNEXPECTED.</p></div></section></section><section id="merging"><h2 id="rfc.section.7"><a href="#rfc.section.7">7.</a> <a href="#merging">Merging Client- and Server-Driven Parameters</a></h2><div id="rfc.section.7.p.1"><p>It is not always the case that the client has the best understanding of how the HTTP responses deserve to be prioritized. The server might have additional information that can be combined with the client’s indicated priority in order to improve the prioritization of the response. For example, use of an HTML document might depend heavily on one of the inline images; existence of such dependencies is typically best known to the server. Or, a server that receives requests for a font <a href="#RFC8081"><cite title='The "font" Top-Level Media Type'>[RFC8081]</cite></a> and images with the same urgency might give higher precedence to the font, so that a visual client can render textual information at an early moment.</p></div><div id="rfc.section.7.p.2"><p>An origin can use the Priority response header field to indicate its view on how an HTTP response should be prioritized. An intermediary that forwards an HTTP response can use the parameters found in the Priority response header field, in combination with the client Priority request header field, as input to its prioritization process. No guidance is provided for merging priorities, this is left as an implementation decision.</p></div><div id="rfc.section.7.p.3"><p>Absence of a priority parameter in an HTTP response indicates the server’s disinterest in changing the client-provided value. This is different from the logic being defined for the request header field, in which omission of a priority parameter implies the use of their default values (see <a href="#parameters" title="Priority Parameters">Section 3</a>).</p></div><div id="rfc.section.7.p.4"><p>As a non-normative example, when the client sends an HTTP request with the urgency parameter set to <span class="tt">5</span> and the incremental parameter set to <span class="tt">true</span></p></div><div id="rfc.figure.u.3"><div><pre class="text">
:method = GET
:scheme = https
:authority = example.net
:path = /menu.png
priority = u=5, i
</pre></div></div><div id="rfc.section.7.p.5"><p>and the origin responds with</p></div><div id="rfc.figure.u.4"><div><pre class="text">
:status = 200
content-type = image/png
priority = u=1
</pre></div></div><div id="rfc.section.7.p.6"><p>the intermediary might alter its understanding of the urgency from <span class="tt">5</span> to <span class="tt">1</span>, because it prefers the server-provided value over the client’s. The incremental value continues to be <span class="tt">true</span>, the value specified by the client, as the server did not specify the incremental(<span class="tt">i</span>) parameter.</p></div></section><section id="client-scheduling"><h2 id="rfc.section.8"><a href="#rfc.section.8">8.</a> <a href="#client-scheduling">Client Scheduling</a></h2><div id="rfc.section.8.p.1"><p>A client MAY use priority values to make local processing or scheduling choices about the requests it initiates.</p></div></section><section id="server-scheduling"><h2 id="rfc.section.9"><a href="#rfc.section.9">9.</a> <a href="#server-scheduling">Server Scheduling</a></h2><div id="rfc.section.9.p.1"><p>Priority signals are input to a prioritization process. They do not guarantee any particular processing or transmission order for one response relative to any other response. An endpoint cannot force a peer to process concurrent request in a particular order using priority. Expressing priority is therefore only a suggestion.</p></div><div id="rfc.section.9.p.2"><p>A server can use priority signals along with other inputs to make scheduling decisions. No guidance is provided about how this can or should be done. Factors such as implementation choices or deployment environment also play a role. Any given connection is likely to have many dynamic permutations. For these reasons, there is no unilateral perfect scheduler and this document only provides some basic recommendations for implementations.</p></div><div id="rfc.section.9.p.3"><p>Clients cannot depend on particular treatment based on priority signals. Servers can use other information to prioritize responses.</p></div><div id="rfc.section.9.p.4"><p>It is RECOMMENDED that, when possible, servers respect the urgency parameter (<a href="#urgency" title="Urgency">Section 3.1</a>), sending higher urgency responses before lower urgency responses.</p></div><div id="rfc.section.9.p.5"><p>It is RECOMMENDED that, when possible, servers respect the incremental parameter (<a href="#incremental" title="Incremental">Section 3.2</a>). Non-incremental responses of the same urgency SHOULD be served one-by-one based on the Stream ID, which corresponds to the order in which clients make requests. Doing so ensures that clients can use request ordering to influence response order. Incremental responses of the same urgency SHOULD be served in round-robin manner.</p></div><div id="rfc.section.9.p.6"><p>The incremental parameter indicates how a client processes response bytes as they arrive. Non-incremental resources are only used when all of the response payload has been received. Incremental resources are used as parts, or chunks, of the response payload are received. Therefore, the timing of response data reception at the client, such as the time to early bytes or the time to receive the entire payload, plays an important role in perceived performance. Timings depend on resource size but this scheme provides no explicit guidance about how a server should use size as an input to prioritization. Instead, the following examples demonstrate how a server that strictly abides the scheduling guidance based on urgency and request generation order could find that early requests prevent serving of later requests.</p></div><div id="rfc.section.9.p.7"><ol><li>At the same urgency level, a non-incremental request for a large resource followed by an incremental request for a small resource.</li><li>At the same urgency level, an incremental request of indeterminate length followed by a non-incremental large resource.</li></ol></div><div id="rfc.section.9.p.8"><p>It is RECOMMENDED that servers avoid such starvation where possible. The method to do so is an implementation decision. For example, a server might pre-emptively send responses of a particular incremental type based on other information such as content size.</p></div></section><section id="fairness"><h2 id="rfc.section.10"><a href="#rfc.section.10">10.</a> <a href="#fairness">Fairness</a></h2><div id="rfc.section.10.p.1"><p>As a general guideline, a server SHOULD NOT use priority information for making schedule decisions across multiple connections, unless it knows that those connections originate from the same client. Due to this, priority information conveyed over a non-coalesced HTTP connection (e.g., HTTP/1.1) might go unused.</p></div><div id="rfc.section.10.p.2"><p>The remainder of this section discusses scenarios where unfairness is problematic and presents possible mitigations, or where unfairness is desirable.</p></div><div id="rfc.section.10.p.3"><p>TODO: Discuss if we should add a signal that mitigates this issue. For example, we might add a SETTINGS parameter that indicates the next hop that the connection is NOT coalesced (see https://github.com/kazuho/draft-kazuho-httpbis-priority/issues/99).</p></div><section id="coalescing-intermediaries"><h3 id="rfc.section.10.1"><a href="#rfc.section.10.1">10.1.</a> <a href="#coalescing-intermediaries">Coalescing Intermediaries</a></h3><div id="rfc.section.10.1.p.1"><p>When an intermediary coalesces HTTP requests coming from multiple clients into one HTTP/2 or HTTP/3 connection going to the backend server, requests that originate from one client might have higher precedence than those coming from others.</p></div><div id="rfc.section.10.1.p.2"><p>It is sometimes beneficial for the server running behind an intermediary to obey to the value of the Priority header field. As an example, a resource-constrained server might defer the transmission of software update files that would have the background urgency being associated. However, in the worst case, the asymmetry between the precedence declared by multiple clients might cause responses going to one user agent to be delayed totally after those going to another.</p></div><div id="rfc.section.10.1.p.3"><p>In order to mitigate this fairness problem, a server could use knowledge about the intermediary as another signal in its prioritization decisions. For instance, if a server knows the intermediary is coalescing requests, then it could serve the responses in round-robin manner. This can work if the constrained resource is network capacity between the intermediary and the user agent, as the intermediary buffers responses and forwards the chunks based on the prioritization scheme it implements.</p></div><div id="rfc.section.10.1.p.4" class="avoidbreakafter"><p>A server can determine if a request came from an intermediary through configuration, or by consulting if that request contains one of the following header fields:</p></div><div id="rfc.section.10.1.p.5"><ul><li>Forwarded, X-Forwarded-For (<a href="#RFC7239"><cite title="Forwarded HTTP Extension">[RFC7239]</cite></a>)</li><li>Via (<a href="#RFC7230"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing">[RFC7230]</cite></a>, Section 5.7.1)</li></ul></div></section><section id="http1x-back-ends"><h3 id="rfc.section.10.2"><a href="#rfc.section.10.2">10.2.</a> <a href="#http1x-back-ends">HTTP/1.x Back Ends</a></h3><div id="rfc.section.10.2.p.1"><p>It is common for CDN infrastructure to support different HTTP versions on the front end and back end. For instance, the client-facing edge might support HTTP/2 and HTTP/3 while communication to back end servers is done using HTTP/1.1. Unlike with connection coalescing, the CDN will “de-mux” requests into discrete connections to the back end. As HTTP/1.1 and older do not provide a way to concurrently transmit multiple responses, there is no immediate fairness issue in protocol. However, back end servers MAY still use client headers for request scheduling. Back end servers SHOULD only schedule based on client priority information where that information can be scoped to individual end clients. Authentication and other session information might provide this linkability.</p></div></section><section id="intentional-introduction-of-unfairness"><h3 id="rfc.section.10.3"><a href="#rfc.section.10.3">10.3.</a> <a href="#intentional-introduction-of-unfairness">Intentional Introduction of Unfairness</a></h3><div id="rfc.section.10.3.p.1"><p>It is sometimes beneficial to deprioritize the transmission of one connection over others, knowing that doing so introduces a certain amount of unfairness between the connections and therefore between the requests served on those connections.</p></div><div id="rfc.section.10.3.p.2"><p>For example, a server might use a scavenging congestion controller on connections that only convey background priority responses such as software update images. Doing so improves responsiveness of other connections at the cost of delaying the delivery of updates.</p></div></section></section><section id="why-use-an-end-to-end-header-field"><h2 id="rfc.section.11"><a href="#rfc.section.11">11.</a> <a href="#why-use-an-end-to-end-header-field">Why use an End-to-End Header Field?</a></h2><div id="rfc.section.11.p.1"><p>Contrary to the prioritization scheme of HTTP/2 that uses a hop-by-hop frame, the Priority header field is defined as end-to-end.</p></div><div id="rfc.section.11.p.2"><p>The rationale is that the Priority header field transmits how each response affects the client’s processing of those responses, rather than how relatively urgent each response is to others. The way a client processes a response is a property associated to that client generating that request. Not that of an intermediary. Therefore, it is an end-to-end property. How these end-to-end properties carried by the Priority header field affect the prioritization between the responses that share a connection is a hop-by-hop issue.</p></div><div id="rfc.section.11.p.3"><p>Having the Priority header field defined as end-to-end is important for caching intermediaries. Such intermediaries can cache the value of the Priority header field along with the response, and utilize the value of the cached header field when serving the cached response, only because the header field is defined as end-to-end rather than hop-by-hop.</p></div><div id="rfc.section.11.p.4"><p>It should also be noted that the use of a header field carrying a textual value makes the prioritization scheme extensible; see the discussion below.</p></div></section><section id="security-considerations"><h2 id="rfc.section.12"><a href="#rfc.section.12">12.</a> <a href="#security-considerations">Security Considerations</a></h2><div id="rfc.section.12.p.1"><p><a href="#CVE-2019-9513"><cite title="CVE-2019-9513">[CVE-2019-9513]</cite></a> aka “Resource Loop”, is a DoS attack based on manipulation of the HTTP/2 priority tree. Extensible priorities does not use stream dependencies, which mitigates this vulnerability.</p></div><div id="rfc.section.12.p.2"><p>TBD: depending on the outcome of reprioritization discussions, following paragraphs may change or be removed.</p></div><div id="rfc.section.12.p.3"><p><a href="#RFC7540"><cite title="Hypertext Transfer Protocol Version 2 (HTTP/2)">[RFC7540]</cite></a>, Section 5.3.4 describes a scenario where closure of streams in the priority tree could cause suboptimal prioritization. To avoid this, <a href="#RFC7540"><cite title="Hypertext Transfer Protocol Version 2 (HTTP/2)">[RFC7540]</cite></a> states that “an endpoint SHOULD retain stream prioritization state for a period after streams become closed”. Retaining state for streams no longer counted towards stream concurrency consumes server resources. Furthermore, <a href="#RFC7540"><cite title="Hypertext Transfer Protocol Version 2 (HTTP/2)">[RFC7540]</cite></a> identifies that reprioritization of a closed stream could affect dependents; it recommends updating the priority tree if sufficient state is stored, which will also consume server resources. To limit this commitment, it is stated that “The amount of prioritization state that is retained MAY be limited” and “If a limit is applied, endpoints SHOULD maintain state for at least as many streams as allowed by their setting for SETTINGS_MAX_CONCURRENT_STREAMS.”. Extensible priorities does not use stream dependencies, which minimizes most of the resource concerns related to this scenario.</p></div><div id="rfc.section.12.p.4"><p><a href="#RFC7540"><cite title="Hypertext Transfer Protocol Version 2 (HTTP/2)">[RFC7540]</cite></a>, Section 5.3.4 also presents considerations about the state required to store priority information about streams in an “idle” state. This state can be limited by adopting the guidance about concurrency limits described above. Extensible priorities is subject to a similar consideration because PRIORITY_UPDATE frames may arrive before the request that they reference. A server is required to store the information in order to apply the most up-to-date signal to the request. However, HTTP/3 implementations might have practical barriers to determining reasonable stream concurrency limits depending on the information that is available to them from the QUIC transport layer. TODO: so what can we suggest?</p></div></section><section id="iana-considerations"><h2 id="rfc.section.13"><a href="#rfc.section.13">13.</a> <a href="#iana-considerations">IANA Considerations</a></h2><div id="rfc.section.13.p.1" class="avoidbreakafter"><p>This specification registers the following entry in the Permanent Message Header Field Names registry established by <a href="#RFC3864"><cite title="Registration Procedures for Message Header Fields">[RFC3864]</cite></a>:</p></div><div id="rfc.section.13.p.2"><dl class="compact"><dt>Header field name:</dt><dd>Priority</dd><dt>Applicable protocol:</dt><dd>http</dd><dt>Status:</dt><dd>standard</dd><dt>Author/change controller:</dt><dd>IETF</dd><dt>Specification document(s):</dt><dd>This document</dd><dt>Related information:</dt><dd>n/a</dd></dl></div><div id="rfc.section.13.p.3" class="avoidbreakafter"><p>This specification registers the following entry in the HTTP/2 Settings registry established by <a href="#RFC7540"><cite title="Hypertext Transfer Protocol Version 2 (HTTP/2)">[RFC7540]</cite></a>:</p></div><div id="rfc.section.13.p.4"><dl class="compact"><dt>Name:</dt><dd>SETTINGS_DEPRECATE_HTTP2_PRIORITIES</dd><dt>Code:</dt><dd>0x9</dd><dt>Initial value:</dt><dd>0</dd><dt>Specification:</dt><dd>This document</dd></dl></div><div id="rfc.section.13.p.5" class="avoidbreakafter"><p>This specification registers the following entry in the HTTP/2 Frame Type registry established by <a href="#RFC7540"><cite title="Hypertext Transfer Protocol Version 2 (HTTP/2)">[RFC7540]</cite></a>:</p></div><div id="rfc.section.13.p.6"><dl class="compact"><dt>Frame Type:</dt><dd>PRIORITY_UPDATE</dd><dt>Code:</dt><dd>0x10</dd><dt>Specification:</dt><dd>This document</dd></dl></div><div id="rfc.section.13.p.7" class="avoidbreakafter"><p>This specification registers the following entries in the HTTP/3 Frame Type registry established by <a href="#I-D.ietf-quic-http"><cite title="Hypertext Transfer Protocol Version 3 (HTTP/3)">[I-D.ietf-quic-http]</cite></a>:</p></div><div id="rfc.section.13.p.8"><dl class="compact"><dt>Frame Type:</dt><dd>PRIORITY_UPDATE</dd><dt>Code:</dt><dd>0xF0700 and 0xF0701</dd><dt>Specification:</dt><dd>This document</dd></dl></div></section><section id="rfc.references"><h2 id="rfc.section.14"><a href="#rfc.section.14">14.</a> References</h2><section><div id="rfc.references.1"><h3 id="rfc.section.14.1"><a href="#rfc.section.14.1">14.1.</a> Normative References</h3><dl class="reference"><dt id="I-D.ietf-quic-http">[I-D.ietf-quic-http]</dt><dd>Bishop, M., “<a href="https://tools.ietf.org/html/draft-ietf-quic-http-31">Hypertext Transfer Protocol Version 3 (HTTP/3)</a>”, Internet-Draft draft-ietf-quic-http-31 (<a href="https://datatracker.ietf.org/doc/draft-ietf-quic-http">work in progress</a>), September 2020.</dd><dt id="I-D.ietf-quic-transport">[I-D.ietf-quic-transport]</dt><dd>Iyengar, J. and M. Thomson, “<a href="https://tools.ietf.org/html/draft-ietf-quic-transport-31">QUIC: A UDP-Based Multiplexed and Secure Transport</a>”, Internet-Draft draft-ietf-quic-transport-31 (<a href="https://datatracker.ietf.org/doc/draft-ietf-quic-transport">work in progress</a>), September 2020.</dd><dt id="RFC2119">[RFC2119]</dt><dd>Bradner, S., “<a href="https://www.rfc-editor.org/rfc/rfc2119.html">Key words for use in RFCs to Indicate Requirement Levels</a>”, BCP 14, RFC 2119, <a href="https://dx.doi.org/10.17487/RFC2119">DOI 10.17487/RFC2119</a>, March 1997, &lt;<a href="https://www.rfc-editor.org/info/rfc2119">https://www.rfc-editor.org/info/rfc2119</a>&gt;.</dd><dt id="RFC7230">[RFC7230]</dt><dd>Fielding, R., Ed. and J. Reschke, Ed., “<a href="https://www.rfc-editor.org/rfc/rfc7230.html">Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</a>”, RFC 7230, <a href="https://dx.doi.org/10.17487/RFC7230">DOI 10.17487/RFC7230</a>, June 2014, &lt;<a href="https://www.rfc-editor.org/info/rfc7230">https://www.rfc-editor.org/info/rfc7230</a>&gt;.</dd><dt id="RFC7540">[RFC7540]</dt><dd>Belshe, M., Peon, R., and M. Thomson, Ed., “<a href="https://www.rfc-editor.org/rfc/rfc7540.html">Hypertext Transfer Protocol Version 2 (HTTP/2)</a>”, RFC 7540, <a href="https://dx.doi.org/10.17487/RFC7540">DOI 10.17487/RFC7540</a>, May 2015, &lt;<a href="https://www.rfc-editor.org/info/rfc7540">https://www.rfc-editor.org/info/rfc7540</a>&gt;.</dd><dt id="STRUCTURED-FIELDS">[STRUCTURED-FIELDS]</dt><dd>Nottingham, M. and P. Kamp, “<a href="https://tools.ietf.org/html/draft-ietf-httpbis-header-structure-19">Structured Field Values for HTTP</a>”, Internet-Draft draft-ietf-httpbis-header-structure-19 (<a href="https://datatracker.ietf.org/doc/draft-ietf-httpbis-header-structure">work in progress</a>), June 2020.</dd></dl></div></section><section><div id="rfc.references.2"><h3 id="rfc.section.14.2"><a href="#rfc.section.14.2">14.2.</a> Informative References</h3><dl class="reference"><dt id="CVE-2019-9513">[CVE-2019-9513]</dt><dd>Common Vulnerabilities and Exposures, “<a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-9513">CVE-2019-9513</a>”, March 2019, &lt;<a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-9513">https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-9513</a>&gt;.</dd><dt id="I-D.lassey-priority-setting">[I-D.lassey-priority-setting]</dt><dd>Lassey, B. and L. Pardue, “<a href="https://tools.ietf.org/html/draft-lassey-priority-setting-00">Declaring Support for HTTP/2 Priorities</a>”, Internet-Draft draft-lassey-priority-setting-00 (<a href="https://datatracker.ietf.org/doc/draft-lassey-priority-setting">work in progress</a>), July 2019.</dd><dt id="RFC3864">[RFC3864]</dt><dd>Klyne, G., Nottingham, M., and J. Mogul, “<a href="https://www.rfc-editor.org/rfc/rfc3864.html">Registration Procedures for Message Header Fields</a>”, BCP 90, RFC 3864, <a href="https://dx.doi.org/10.17487/RFC3864">DOI 10.17487/RFC3864</a>, September 2004, &lt;<a href="https://www.rfc-editor.org/info/rfc3864">https://www.rfc-editor.org/info/rfc3864</a>&gt;.</dd><dt id="RFC7234">[RFC7234]</dt><dd>Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke, Ed., “<a href="https://www.rfc-editor.org/rfc/rfc7234.html">Hypertext Transfer Protocol (HTTP/1.1): Caching</a>”, RFC 7234, <a href="https://dx.doi.org/10.17487/RFC7234">DOI 10.17487/RFC7234</a>, June 2014, &lt;<a href="https://www.rfc-editor.org/info/rfc7234">https://www.rfc-editor.org/info/rfc7234</a>&gt;.</dd><dt id="RFC7239">[RFC7239]</dt><dd>Petersson, A. and M. Nilsson, “<a href="https://www.rfc-editor.org/rfc/rfc7239.html">Forwarded HTTP Extension</a>”, RFC 7239, <a href="https://dx.doi.org/10.17487/RFC7239">DOI 10.17487/RFC7239</a>, June 2014, &lt;<a href="https://www.rfc-editor.org/info/rfc7239">https://www.rfc-editor.org/info/rfc7239</a>&gt;.</dd><dt id="RFC8081">[RFC8081]</dt><dd>Lilley, C., “<a href="https://www.rfc-editor.org/rfc/rfc8081.html">The "font" Top-Level Media Type</a>”, RFC 8081, <a href="https://dx.doi.org/10.17487/RFC8081">DOI 10.17487/RFC8081</a>, February 2017, &lt;<a href="https://www.rfc-editor.org/info/rfc8081">https://www.rfc-editor.org/info/rfc8081</a>&gt;.</dd></dl></div></section></section><section id="acknowledgements"><h2 id="rfc.section.A" class="np"><a href="#rfc.section.A">Appendix A.</a> <a href="#acknowledgements">Acknowledgements</a></h2><div id="rfc.section.A.p.1"><p>Roy Fielding presented the idea of using a header field for representing priorities in <a href="http://tools.ietf.org/agenda/83/slides/slides-83-httpbis-5.pdf">http://tools.ietf.org/agenda/83/slides/slides-83-httpbis-5.pdf</a>. In <a href="https://github.com/pmeenan/http3-prioritization-proposal">https://github.com/pmeenan/http3-prioritization-proposal</a>, Patrick Meenan advocates for representing the priorities using a tuple of urgency and concurrency. The ability to deprecate HTTP/2 prioritization is based on <a href="#I-D.lassey-priority-setting"><cite title="Declaring Support for HTTP/2 Priorities">[I-D.lassey-priority-setting]</cite></a>, authored by Brad Lassey and Lucas Pardue, with modifications based on feedback that was not incorporated into an update to that document.</p></div><div id="rfc.section.A.p.2"><p>The motivation for defining an alternative to HTTP/2 priorities is drawn from discussion within the broad HTTP community. Special thanks to Roberto Peon, Martin Thomson and Netflix for text that was incorporated explicitly in this document.</p></div><div id="rfc.section.A.p.3"><p>In addition to the people above, this document owes a lot to the extensive discussion in the HTTP priority design team, consisting of Alan Frindell, Andrew Galloni, Craig Taylor, Ian Swett, Kazuho Oku, Lucas Pardue, Matthew Cox, Mike Bishop, Roberto Peon, Robin Marx, Roy Fielding.</p></div></section><section id="change-log"><h2 id="rfc.section.B"><a href="#rfc.section.B">Appendix B.</a> <a href="#change-log">Change Log</a></h2><section id="since-draft-ietf-httpbis-priority-01"><h3 id="rfc.section.B.1"><a href="#rfc.section.B.1">B.1.</a> <a href="#since-draft-ietf-httpbis-priority-01">Since draft-ietf-httpbis-priority-01</a></h3><div id="rfc.section.B.1.p.1"><ul><li>PRIORITY_UPDATE frame changes (#1096, #1079, #1167, #1262, #1267, #1271)</li><li>Add section to describe server scheduling considerations (#1215, #1232, #1266)</li><li>Remove specific instructions related to intermediary fairness (#1022, #1264)</li></ul></div></section><section id="since-draft-ietf-httpbis-priority-00"><h3 id="rfc.section.B.2"><a href="#rfc.section.B.2">B.2.</a> <a href="#since-draft-ietf-httpbis-priority-00">Since draft-ietf-httpbis-priority-00</a></h3><div id="rfc.section.B.2.p.1"><ul><li>Move text around (#1217, #1218)</li><li>Editorial change to the default urgency. The value is 3, which was always the intent of previous changes.</li></ul></div></section><section id="since-draft-kazuho-httpbis-priority-04"><h3 id="rfc.section.B.3"><a href="#rfc.section.B.3">B.3.</a> <a href="#since-draft-kazuho-httpbis-priority-04">Since draft-kazuho-httpbis-priority-04</a></h3><div id="rfc.section.B.3.p.1"><ul><li>Minimize semantics of Urgency levels (#1023, #1026)</li><li>Reduce guidance about how intermediary implements merging priority signals (#1026)</li><li>Remove mention of CDN-Loop (#1062)</li><li>Editorial changes</li><li>Make changes due to WG adoption</li><li>Removed outdated Consideration (#118)</li></ul></div></section><section id="since-draft-kazuho-httpbis-priority-03"><h3 id="rfc.section.B.4"><a href="#rfc.section.B.4">B.4.</a> <a href="#since-draft-kazuho-httpbis-priority-03">Since draft-kazuho-httpbis-priority-03</a></h3><div id="rfc.section.B.4.p.1"><ul><li>Changed numbering from <span class="tt">[-1,6]</span> to <span class="tt">[0,7]</span> (#78)</li><li>Replaced priority scheme negotiation with HTTP/2 priority deprecation (#100)</li><li>Shorten parameter names (#108)</li><li>Expand on considerations (#105, #107, #109, #110, #111, #113)</li></ul></div></section><section id="since-draft-kazuho-httpbis-priority-02"><h3 id="rfc.section.B.5"><a href="#rfc.section.B.5">B.5.</a> <a href="#since-draft-kazuho-httpbis-priority-02">Since draft-kazuho-httpbis-priority-02</a></h3><div id="rfc.section.B.5.p.1"><ul><li>Consolidation of the problem statement (#61, #73)</li><li>Define SETTINGS_PRIORITIES for negotiation (#58, #69)</li><li>Define PRIORITY_UPDATE frame for HTTP/2 and HTTP/3 (#51)</li><li>Explain fairness issue and mitigations (#56)</li></ul></div></section><section id="since-draft-kazuho-httpbis-priority-01"><h3 id="rfc.section.B.6"><a href="#rfc.section.B.6">B.6.</a> <a href="#since-draft-kazuho-httpbis-priority-01">Since draft-kazuho-httpbis-priority-01</a></h3><div id="rfc.section.B.6.p.1"><ul><li>Explain how reprioritization might be supported.</li></ul></div></section><section id="since-draft-kazuho-httpbis-priority-00"><h3 id="rfc.section.B.7"><a href="#rfc.section.B.7">B.7.</a> <a href="#since-draft-kazuho-httpbis-priority-00">Since draft-kazuho-httpbis-priority-00</a></h3><div id="rfc.section.B.7.p.1"><ul><li>Expand urgency levels from 3 to 8.</li></ul></div></section></section><section id="rfc.authors" class="avoidbreakinside"><h2><a href="#rfc.authors">Authors' Addresses</a></h2><address><b>Kazuho Oku</b><br>Fastly<br>EMail: <a href="mailto:kazuhooku@gmail.com">kazuhooku@gmail.com</a></address><address><b>Lucas Pardue</b><br>Cloudflare<br>EMail: <a href="mailto:lucaspardue.24.7@gmail.com">lucaspardue.24.7@gmail.com</a></address></section></body></html>
