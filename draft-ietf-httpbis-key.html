<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>The Key HTTP Response Header Field</title><script type="application/javascript">
function anchorRewrite() {
  map = { };
  if (window.location.hash.length >= 1) {
    var fragid = window.location.hash.substr(1);
    if (fragid) {
      if (! document.getElementById(fragid)) {
        var prefix = "rfc.";
        var mapped = map[fragid];
        if (mapped) {
          window.location.hash = mapped;
        } else if (fragid.indexOf("section-") == 0) {
          window.location.hash = prefix + "section." + fragid.substring(8);
        } else if (fragid.indexOf("appendix-") == 0) {
          window.location.hash = prefix + "section." + fragid.substring(9);
        } else if (fragid.indexOf("s-") == 0) {
          var postfix = fragid.substring(2);
          if (postfix.startsWith("abstract")) {
            window.location.hash = prefix + postfix;
          } else if (postfix.startsWith("note-")) {
            window.location.hash = prefix + "note." + postfix.substring(5);
          } else {
            window.location.hash = prefix + "section." + postfix;
          }
        } else if (fragid.indexOf("p-") == 0) {
          var r = fragid.substring(2);
          var p = r.indexOf("-");
          if (p >= 0) {
            window.location.hash = prefix + "section." + r.substring(0, p) + ".p." + r.substring(p + 1);
          }
        }
      }
    }  
  }
}
window.addEventListener('hashchange', anchorRewrite);
window.addEventListener('DOMContentLoaded', anchorRewrite);
</script><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="stylesheet" type="text/css" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap.min.css"><style type="text/css">
      body {
        padding-top: 80px;
        padding-bottom: 80px;
        position: relative;
      }
      .table.header th, .table.header td {
        border-top: none;
        padding: 0;
      }
      #rfc\.meta {
        width: 40%;
        float: right
      }
      #rfc\.toc > ul ul {
        list-style: none;
      }
      #sidebar {
        position: fixed;
        height: 90%;
        overflow-y: auto;
        font-size: 90%;
      }
      .container .nav-sublist {
        padding-left: 20px;
        padding-right: 10px;
        font-size: 90%;
      }
      .container .navbar-brand {
        padding-top: 0;
      }
      .container .nav > li > a {
        padding: 10px 7px 5px 15px;
        display: inline-block;
      }
      .container .nav > li > a + a {
        padding: 10px 15px 5px 7px;
        display: inline-block;
      }
      .container .nav > li > a {
        padding: 5px 10px;
      }
      .filename {
        color: rgb(119, 119, 119);
        font-size: 23px;
        font-weight: normal;
        height: auto;
        line-height: 23px;
      }
      dl {
        margin-left: 1em;
      }
      dl.dl-horizontal: {
        margin-left: 0;
      }
      dl > dt {
        float: left;
        margin-right: 1em;
      }
      dl.nohang > dt {
        float: none;
      }
      dl > dd {
        margin-bottom: .5em;
      }
      dl.compact > dd {
        margin-bottom: 0em;
      }
      dl > dd > dl {
        margin-top: 0.5em;
        margin-bottom: 0em;
      }
      ul.empty {
        list-style-type: none;
      }
      ul.empty li {
        margin-top: .5em;
      }
      td.reference {
        padding-right: 1em;
        vertical-align: top;
      }
      .feedback {
        position: fixed;
        bottom: 5px;
        right: 5px;
      }
      .fbbutton {
        margin-left: 5px;
      }
      h1 a, h2 a, h3 a, h4 a, h5 a, h6 a {
        color: rgb(51, 51, 51);
      }
      span.tt {
        font: 11pt consolas, monospace;
        font-size-adjust: none;
      }
    </style><link rel="Author" href="#rfc.authors"><link rel="Copyright" href="#rfc.copyrightnotice"><link rel="Chapter" title="1 Introduction" href="#rfc.section.1"><link rel="Chapter" title="2 The “Key” Response Header Field" href="#rfc.section.2"><link rel="Chapter" title="3 IANA Considerations" href="#rfc.section.3"><link rel="Chapter" title="4 Security Considerations" href="#rfc.section.4"><link rel="Chapter" href="#rfc.section.5" title="5 References"><link rel="Appendix" title="A Acknowledgements" href="#rfc.section.A"><link rel="Appendix" title="B Changes" href="#rfc.section.B"><meta name="generator" content="https://github.com/mnot/RFCBootstrap XSLT vendor: SAXON 9.1.0.8 from Saxonica http://www.saxonica.com/"><meta name="keywords" content="content negotiation"><link rel="schema.dcterms" href="http://purl.org/dc/terms/"><meta name="dcterms.creator" content="Fielding, R."><meta name="dcterms.creator" content="Nottingham, M."><meta name="dcterms.identifier" content="urn:ietf:id:draft-ietf-httpbis-key-latest"><meta name="dcterms.issued" content="2017-10-23"><meta name="dcterms.abstract" content="The ‘Key’ header field for HTTP responses allows an origin server to describe the secondary cache key (RFC 7234, Section 4.1) for a resource, by conveying what is effectively a short algorithm that can be used upon later requests to determine if a stored response is reusable for a given request.Key has the advantage of avoiding an additional round trip for validation whenever a new request differs slightly, but not significantly, from prior requests.Key also informs user agents of the request characteristics that might result in different content, which can be useful if the user agent is not sending request header fields in order to reduce the risk of fingerprinting."><meta name="description" content="The ‘Key’ header field for HTTP responses allows an origin server to describe the secondary cache key (RFC 7234, Section 4.1) for a resource, by conveying what is effectively a short algorithm that can be used upon later requests to determine if a stored response is reusable for a given request.Key has the advantage of avoiding an additional round trip for validation whenever a new request differs slightly, but not significantly, from prior requests.Key also informs user agents of the request characteristics that might result in different content, which can be useful if the user agent is not sending request header fields in order to reduce the risk of fingerprinting."></head><body><div class="container" id="top"><div class="row"><div class="col-md-4 col-md-push-8 hidden-sm hidden-xs" id="sidebar" role="navigation"><div class="navbar"><div class="navbar-brand"><a href="#top">draft-ietf-httpbis-key-latest</a></div><br clear="all"><div class=""><div id="rfc.toc"><ul class="nav"><li><a href="#rfc.section.1">1.</a>&nbsp;&nbsp;&nbsp;<a href="#introduction">Introduction</a><ul><li><a href="#rfc.section.1.1">1.1.</a>&nbsp;&nbsp;&nbsp;<a href="#examples">Examples</a></li><li><a href="#rfc.section.1.2">1.2.</a>&nbsp;&nbsp;&nbsp;<a href="#notational-conventions">Notational Conventions</a></li></ul></li><li><a href="#rfc.section.2">2.</a>&nbsp;&nbsp;&nbsp;<a href="#the-key-response-header-field">The “Key” Response Header Field</a><ul><li><a href="#rfc.section.2.1">2.1.</a>&nbsp;&nbsp;&nbsp;<a href="#relationship-with-vary">Relationship with Vary</a></li><li><a href="#rfc.section.2.2">2.2.</a>&nbsp;&nbsp;&nbsp;<a href="#calculating-a-secondary-cache-key">Calculating a Secondary Cache Key</a><ul><li><a href="#rfc.section.2.2.1">2.2.1.</a>&nbsp;&nbsp;&nbsp;<a href="#value">Creating a Header Field Value</a></li><li><a href="#rfc.section.2.2.2">2.2.2.</a>&nbsp;&nbsp;&nbsp;<a href="#fail-param">Failing Parameter Processing</a></li></ul></li><li><a href="#rfc.section.2.3">2.3.</a>&nbsp;&nbsp;&nbsp;<a href="#key-parameters">Key Parameters</a><ul><li><a href="#rfc.section.2.3.1">2.3.1.</a>&nbsp;&nbsp;&nbsp;<a href="#div">div</a></li><li><a href="#rfc.section.2.3.2">2.3.2.</a>&nbsp;&nbsp;&nbsp;<a href="#partition">partition</a></li><li><a href="#rfc.section.2.3.3">2.3.3.</a>&nbsp;&nbsp;&nbsp;<a href="#match">match</a></li><li><a href="#rfc.section.2.3.4">2.3.4.</a>&nbsp;&nbsp;&nbsp;<a href="#substr">substr</a></li><li><a href="#rfc.section.2.3.5">2.3.5.</a>&nbsp;&nbsp;&nbsp;<a href="#param">param</a></li></ul></li></ul></li><li><a href="#rfc.section.3">3.</a>&nbsp;&nbsp;&nbsp;<a href="#iana">IANA Considerations</a><ul><li><a href="#rfc.section.3.1">3.1.</a>&nbsp;&nbsp;&nbsp;<a href="#procedure">Procedure</a></li><li><a href="#rfc.section.3.2">3.2.</a>&nbsp;&nbsp;&nbsp;<a href="#registrations">Registrations</a></li></ul></li><li><a href="#rfc.section.4">4.</a>&nbsp;&nbsp;&nbsp;<a href="#security-considerations">Security Considerations</a></li><li><a href="#rfc.section.5">5.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.references">References</a><ul><li><a href="#rfc.section.5.1">5.1.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.references.1">Normative References</a></li><li><a href="#rfc.section.5.2">5.2.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.references.2">Informative References</a></li></ul></li><li><a href="#rfc.section.A">A.</a>&nbsp;&nbsp;&nbsp;<a href="#acknowledgements">Acknowledgements</a></li><li><a href="#rfc.section.B">B.</a>&nbsp;&nbsp;&nbsp;<a href="#changes">Changes</a><ul><li><a href="#rfc.section.B.1">B.1.</a>&nbsp;&nbsp;&nbsp;<a href="#since-00">Since -00</a></li><li><a href="#rfc.section.B.2">B.2.</a>&nbsp;&nbsp;&nbsp;<a href="#since-01">Since -01</a></li></ul></li><li><a href="#rfc.authors">Authors' Addresses</a></li></ul></div></div></div></div><div class="col-md-8 main" role="main"><header><table class="table table-condensed header" id="rfc.headerblock"><tbody><tr><td class="text-left">HTTP Working Group</td><td class="text-right">R. Fielding</td></tr><tr><td class="text-left">Internet-Draft</td><td class="text-right">Adobe Systems Incorporated</td></tr><tr><td class="text-left">Intended status: Standards Track</td><td class="text-right">M. Nottingham</td></tr><tr><td class="text-left">Expires: April 26, 2018</td><td class="text-right">October 23, 2017</td></tr></tbody></table><div id="rfc.title"><h1>The Key HTTP Response Header Field</h1><div class="filename">draft-ietf-httpbis-key-latest</div></div></header><hr><h2 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h2><div class="lead"><div id="rfc.abstract.p.1"><p>The ‘Key’ header field for HTTP responses allows an origin server to describe the secondary cache key (RFC 7234, Section 4.1) for a resource, by conveying what is effectively a short algorithm that can be used upon later requests to determine if a stored response is reusable for a given request.</p></div><div id="rfc.abstract.p.2"><p>Key has the advantage of avoiding an additional round trip for validation whenever a new request differs slightly, but not significantly, from prior requests.</p></div><div id="rfc.abstract.p.3"><p>Key also informs user agents of the request characteristics that might result in different content, which can be useful if the user agent is not sending request header fields in order to reduce the risk of fingerprinting.</p></div></div><section id="rfc.note.1" class="note"><h2><a href="#rfc.note.1">Note to Readers</a></h2><div id="rfc.note.1.p.1"><p>Discussion of this draft takes place on the HTTP working group mailing list (ietf-http-wg@w3.org), which is archived at <a href="https://lists.w3.org/Archives/Public/ietf-http-wg/">https://lists.w3.org/Archives/Public/ietf-http-wg/</a>.</p></div><div id="rfc.note.1.p.2"><p>Working Group information can be found at <a href="http://httpwg.github.io/">http://httpwg.github.io/</a>; source code and issues list for this draft can be found at <a href="https://github.com/httpwg/http-extensions/labels/key">https://github.com/httpwg/http-extensions/labels/key</a>.</p></div></section><section id="rfc.status"><h2><a href="#rfc.status">Status of this Memo</a></h2><div id="rfc.boilerplate.1.p.1"><p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p></div><div id="rfc.boilerplate.1.p.2"><p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF). Note that other groups may also distribute working documents as Internet-Drafts. The list of current Internet-Drafts is at <a href="http://datatracker.ietf.org/drafts/current/">http://datatracker.ietf.org/drafts/current/</a>.</p></div><div id="rfc.boilerplate.1.p.3"><p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time. It is inappropriate to use Internet-Drafts as reference material or to cite them other than as “work in progress”.</p></div><div id="rfc.boilerplate.1.p.4"><p>This Internet-Draft will expire on April 26, 2018.</p></div></section><section id="rfc.copyrightnotice"><h2><a href="#rfc.copyrightnotice">Copyright Notice</a></h2><div id="rfc.boilerplate.2.p.1"><p>Copyright © 2017 IETF Trust and the persons identified as the document authors. All rights reserved.</p></div><div id="rfc.boilerplate.2.p.2"><p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (<a href="http://trustee.ietf.org/license-info">http://trustee.ietf.org/license-info</a>) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p></div></section><section id="introduction"><h2 id="rfc.section.1" class="np"><a href="#rfc.section.1">1.</a>&nbsp;<a href="#introduction">Introduction</a></h2><div id="rfc.section.1.p.1"><p>In HTTP caching <a href="#RFC7234"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Caching">[RFC7234]</cite></a>, the Vary response header field effectively modifies the key used to store and access a response to include information from the request’s headers. This “secondary cache key” allows proactive content negotiation <a href="#RFC7231"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content">[RFC7231]</cite></a> to work with caches.</p></div><div id="rfc.section.1.p.2"><p>Vary’s operation is generic; it works well when caches understand the semantics of the selecting headers. For example, the Accept-Language request header field has a well-defined syntax for expressing the client’s preferences; a cache that understands this header field can select the appropriate response (based upon its Content-Language header field) and serve it to a client, without any knowledge of the underlying resource.</p></div><div id="rfc.section.1.p.3"><p>Vary does not work as well when the criteria for selecting a response are specific to the resource. For example, if the nature of the response depends upon the presence or absence of a particular Cookie (<a href="#RFC6265"><cite title="HTTP State Management Mechanism">[RFC6265]</cite></a>) in a request, Vary doesn’t have a mechanism to offer enough fine-grained, resource-specific information to aid a cache’s selection of the appropriate response.</p></div><div id="rfc.section.1.p.4"><p>Additionally, when new selecting headers are defined, caches need to be updated to understand their semantics before Vary can operate over them efficiently; due to the sometimes slow rate of cache deployment, this can be problematic.</p></div><div id="rfc.section.1.p.5"><p>Finally, Vary has proven to be difficult to implement correctly and efficiently by high-performance intermediary caches, because doing so involves examining all cached responses with the request’s URL.</p></div><div id="rfc.section.1.p.6"><p>This document defines a new response header field, “Key”, that allows resources to describe the secondary cache key in a fine-grained, resource-specific manner, leading to improved cache efficiency when responses depend upon such headers.</p></div><section id="examples"><h3 id="rfc.section.1.1"><a href="#rfc.section.1.1">1.1.</a>&nbsp;<a href="#examples">Examples</a></h3><div id="rfc.section.1.1.p.1" class="avoidbreakafter"><p>For example, this response header field:</p></div><div id="rfc.figure.u.1"><pre class="text">
  Key: cookie;param=_sess;param=ID
</pre></div><div id="rfc.section.1.1.p.2"><p>indicates that the selected response depends upon the “_sess” and “ID” cookie values.</p></div><div id="rfc.section.1.1.p.3" class="avoidbreakafter"><p>This Key:</p></div><div id="rfc.figure.u.2"><pre class="text">
  Key: user-agent;substr=MSIE
</pre></div><div id="rfc.section.1.1.p.4"><p>indicates that there are two possible secondary cache keys for this resource; one for requests whose User-Agent header field contains “MSIE”, and another for those that don’t.</p></div><div id="rfc.section.1.1.p.5" class="avoidbreakafter"><p>A more complex example:</p></div><div id="rfc.figure.u.3"><pre class="text">
  Key: user-agent;substr=MSIE;Substr="mobile", Cookie;param="ID"
</pre></div><div id="rfc.section.1.1.p.6"><p>indicates that the selected response depends on the presence of two strings in the User-Agent request header field, as well as the value of the “ID” cookie request header field.</p></div></section><section id="notational-conventions"><h3 id="rfc.section.1.2"><a href="#rfc.section.1.2">1.2.</a>&nbsp;<a href="#notational-conventions">Notational Conventions</a></h3><div id="rfc.section.1.2.p.1"><p>The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in <a href="#RFC2119"><cite title="Key words for use in RFCs to Indicate Requirement Levels">[RFC2119]</cite></a>.</p></div><div id="rfc.section.1.2.p.2"><p>This document uses the Augmented Backus-Naur Form (ABNF) notation of <a href="#RFC5234"><cite title="Augmented BNF for Syntax Specifications: ABNF">[RFC5234]</cite></a> (including the DQUOTE rule), and the list rule extension defined in <a href="#RFC7230"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing">[RFC7230]</cite></a>, Section 7. It includes by reference the field-name, quoted-string and quoted-pair rules from that document, the OWS rule from <a href="#RFC7230"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing">[RFC7230]</cite></a> and the parameter rule from <a href="#RFC7231"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content">[RFC7231]</cite></a>.</p></div></section></section><section id="the-key-response-header-field"><h2 id="rfc.section.2"><a href="#rfc.section.2">2.</a>&nbsp;<a href="#the-key-response-header-field">The “Key” Response Header Field</a></h2><div id="rfc.section.2.p.1"><p>The “Key” response header field describes the portions of the request that the resource currently uses to select representations.</p></div><div id="rfc.section.2.p.2"><p>As such, its semantics are similar to the “Vary” response header field, but it allows more fine-grained description, using “key parameters”.</p></div><div id="rfc.section.2.p.3"><p>Caches can use this information as part of determining whether a stored response can be used to satisfy a given request. When a cache knows and fully understands the Key header field for a given resource, it MAY ignore the Vary response header field in any stored responses for it.</p></div><div id="rfc.section.2.p.4"><p>Additionally, user agents can use Key to discover if additional request header fields might influence the resource’s selection of responses.</p></div><div id="rfc.section.2.p.5"><p>The Key field-value is a comma-delimited list of selecting header fields (similar to Vary), with zero to many parameters each, delimited by semicolons.</p></div><div id="rfc.figure.u.4"><pre class="inline">
  Key       = 1#key-value
  key-value = field-name *( OWS ";" OWS parameter )
</pre></div><div id="rfc.section.2.p.6"><p>Note that, as per <a href="#RFC7231"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content">[RFC7231]</cite></a>, parameter names are case-insensitive, and parameter values can be double-quoted strings (potentially with “\“-escaped characters inside).</p></div><div id="rfc.section.2.p.7" class="avoidbreakafter"><p>The following header fields have the same effect:</p></div><div id="rfc.figure.u.5"><pre class="text">
  Vary: Accept-Encoding, Cookie
  Key: Accept-Encoding, Cookie
</pre></div><div id="rfc.section.2.p.8" class="avoidbreakafter"><p>However, Key’s use of parameters allows:</p></div><div id="rfc.figure.u.6"><pre class="text">
  Key: Accept-Encoding, Cookie; param=foo
</pre></div><div id="rfc.section.2.p.9"><p>to indicate that the secondary cache key depends upon the Accept-Encoding header field and the “foo” Cookie.</p></div><div id="rfc.section.2.p.10"><p>One important difference between Vary and Key is how they are applied. Vary is specified to be specific to the response it occurs within, whereas Key is specific to the resource (as identified by the request URL) it is associated with. The most recent key you receive for a given resource is applicable to all responses from that resource.</p></div><div id="rfc.section.2.p.11"><p>This difference allows more efficient implementation (and reflects practices that many caches use in implementing Vary already).</p></div><div id="rfc.section.2.p.12"><p>This specification defines a selection of Key parameters to address common use cases such as selection upon individual Cookie header fields, User-Agent substrings and numerical ranges. Future parameters may define further capabilities.</p></div><section id="relationship-with-vary"><h3 id="rfc.section.2.1"><a href="#rfc.section.2.1">2.1.</a>&nbsp;<a href="#relationship-with-vary">Relationship with Vary</a></h3><div id="rfc.section.2.1.p.1"><p>Origin servers SHOULD still send Vary when using Key, to ensure backwards compatibility.</p></div><div id="rfc.section.2.1.p.2"><p>For example,</p></div><div id="rfc.figure.u.7"><pre class="text">
  Vary: User-Agent
  Key: User-Agent;substr="mozilla"
</pre></div><div id="rfc.section.2.1.p.3"><p>Note that, in some cases, it may be better to explicitly use “Vary: *” if clients and caches don’t have any practical way to use the Vary header field’s value. For example,</p></div><div id="rfc.figure.u.8"><pre class="text">
  Vary: *
  Key: Cookie;param="ID"
</pre></div><div id="rfc.section.2.1.p.4"><p>Except when Vary: * is used, the set of headers used in Key SHOULD reflect the same request header fields as Vary does, even if they don’t have parameters. For example,</p></div><div id="rfc.figure.u.9"><pre class="text">
  Vary: Accept-Encoding, User-Agent
  Key: Accept-Encoding, User-Agent;substr="mozilla"
</pre></div><div id="rfc.section.2.1.p.5"><p>Here, Accept-Encoding is included in Key without parameters; caches MAY treat these as they do values in the Vary header, relying upon knowledge of their generic semantics to select an appropriate response.</p></div></section><section id="calculating-a-secondary-cache-key"><h3 id="rfc.section.2.2"><a href="#rfc.section.2.2">2.2.</a>&nbsp;<a href="#calculating-a-secondary-cache-key">Calculating a Secondary Cache Key</a></h3><div id="rfc.section.2.2.p.1"><p>When used by a cache to determine whether a stored response can be used to satisfy a presented request, each field-name in Key identifies a potential request header, just as with the Vary response header field.</p></div><div id="rfc.section.2.2.p.2"><p>However, each of these can have zero to many key parameters that change how the response selection process (as defined in <a href="#RFC7234"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Caching">[RFC7234]</cite></a>, Section 4.3) works.</p></div><div id="rfc.section.2.2.p.3"><p>In particular, when a cache fully implements this specification, it creates a secondary cache key for every request by following the instructions in the Key header field, ignoring the Vary header for this purpose.</p></div><div id="rfc.section.2.2.p.4"><p>Then, when a new request is presented, the secondary cache key generated for that request can be compared to the stored one to find the appropriate response, to determine if it can be selected.</p></div><div id="rfc.section.2.2.p.5" class="avoidbreakafter"><p>To generate a secondary cache key for a given request (including that which is stored with a response) using Key, the following steps are taken:</p></div><div id="rfc.section.2.2.p.6"><dl><dt>1)</dt><dd>If the Key header field is not present on the most recent cacheable (as per <a href="#RFC7234"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Caching">[RFC7234]</cite></a>, Section 3)) response seen for the resource, abort this algorithm (i.e., fall back to using Vary to determine the secondary cache key).</dd><dt>2)</dt><dd>Let <span class="tt">key_value</span> be the result of Creating a Header Field Value (<a href="#value" title="Creating a Header Field Value">Section&nbsp;2.2.1</a>) with <span class="tt">key</span> as the <span class="tt">target_field_name</span> and the most recently seen response header list for the resource as <span class="tt">header_list</span>.</dd><dt>3)</dt><dd>Let <span class="tt">secondary_key</span> be an empty string.</dd><dt>4)</dt><dd>Create <span class="tt">key_list</span> by splitting <span class="tt">key_value</span> on “,” characters, excepting “,” characters within quoted strings, as per <a href="#RFC7230"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing">[RFC7230]</cite></a>, Section 3.2.6.</dd><dt>5)</dt><dd>For <span class="tt">key_item</span> in <span class="tt">key_list</span>: <dl><dt>1)</dt><dd>Remove any leading and trailing WSP from <span class="tt">key_item</span>.</dd><dt>2)</dt><dd>If <span class="tt">key_item</span> does not contain a “;” character, fail parameter processing (<a href="#fail-param" title="Failing Parameter Processing">Section&nbsp;2.2.2</a>) and skip to the next <span class="tt">key_item</span>.</dd><dt>3)</dt><dd>Let <span class="tt">field_name</span> be the string before the first “;” character in <span class="tt">key_item</span>, removing any WSP between them.</dd><dt>4)</dt><dd>Let <span class="tt">field_value</span> be the result of Creating a Header Field Value (<a href="#value" title="Creating a Header Field Value">Section&nbsp;2.2.1</a>) with <span class="tt">field_name</span> as the <span class="tt">target_field_name</span> and the request header list as <span class="tt">header_list</span>.</dd><dt>5)</dt><dd>Let <span class="tt">parameters</span> be the string after the first “;” character in <span class="tt">key_item</span>, removing any WSP between them.</dd><dt>6)</dt><dd>Create <span class="tt">param_list</span> by splitting <span class="tt">parameters</span> on “;” characters, excepting “;” characters within quoted strings, as per <a href="#RFC7230"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing">[RFC7230]</cite></a>, Section 3.2.6.</dd><dt>7)</dt><dd>For <span class="tt">parameter</span> in <span class="tt">param_list</span>: <dl><dt>1)</dt><dd>If <span class="tt">parameter</span> does not contain a “=”, fail parameter processing (<a href="#fail-param" title="Failing Parameter Processing">Section&nbsp;2.2.2</a>) and skip to the next <span class="tt">key_item</span>.</dd><dt>2)</dt><dd>Remove any WSP at the beginning and/or end of <span class="tt">parameter</span>.</dd><dt>3)</dt><dd>Let <span class="tt">param_name</span> be the string before the first “=” character in <span class="tt">parameter</span>, case-normalized to lowercase.</dd><dt>4)</dt><dd>If <span class="tt">param_name</span> does not identify a Key parameter processing algorithm that is implemented, fail parameter processing (<a href="#fail-param" title="Failing Parameter Processing">Section&nbsp;2.2.2</a>) and skip to the next <span class="tt">key_item</span>.</dd><dt>5)</dt><dd>Let <span class="tt">param_value</span> be the string after the first “=” character in <span class="tt">parameter</span>.</dd><dt>6)</dt><dd>If the first and last characters of <span class="tt">param_value</span> are both DQUOTE: <dl><dt>1)</dt><dd>Remove the first and last characters of <span class="tt">param_value</span>.</dd><dt>2)</dt><dd>Replace quoted-pairs within <span class="tt">param_value</span> with the octet following the backslash, as per <a href="#RFC7230"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing">[RFC7230]</cite></a>, Section 3.2.6.</dd></dl></dd><dt>7)</dt><dd>If <span class="tt">param_value</span> does not conform to the syntax defined for it by the parameter definition, fail parameter processing (<a href="#fail-param" title="Failing Parameter Processing">Section&nbsp;2.2.2</a>) and skip to the next <span class="tt">key_item</span>.</dd><dt>8)</dt><dd>Run the identified processing algorithm on <span class="tt">field_value</span> with the <span class="tt">param_value</span>, and append the result to <span class="tt">secondary_key</span>. If parameter processing fails (<a href="#fail-param" title="Failing Parameter Processing">Section&nbsp;2.2.2</a>), skip to the next <span class="tt">key_item</span>.</dd><dt>9)</dt><dd>Append a separator character (e.g., NULL) to <span class="tt">secondary_key</span>.</dd></dl></dd></dl></dd><dt>6)</dt><dd>Return <span class="tt">secondary_key</span>.</dd></dl></div><div id="rfc.section.2.2.p.7"><p>Note that this specification does not require that exact algorithm to be implemented. However, implementations’ observable behavior MUST be identical to running it. This includes parameter processing algorithms; implementations MAY use different internal artefacts for secondary cache keys, as long as the results are the same.</p></div><div id="rfc.section.2.2.p.8" class="avoidbreakafter"><p>Likewise, while the secondary cache key associated with both stored and presented requests is required to use the most recently seen Key header field for the resource in question, this can be achieved using a variety of implementation strategies, including (but not limited to):</p></div><div id="rfc.section.2.2.p.9"><ul><li>Generating a new secondary cache key for every stored response associated with the resource upon each request.</li><li>Caching the secondary cache key with the stored request/response pair and re-generating it when the Key header field is observed to change.</li><li>Caching the secondary cache key with the stored response and invalidating the stored response(s) when the Key header field is observed to change.</li></ul></div><section id="value"><h4 id="rfc.section.2.2.1"><a href="#rfc.section.2.2.1">2.2.1.</a>&nbsp;<a href="#value">Creating a Header Field Value</a></h4><div id="rfc.section.2.2.1.p.1" class="avoidbreakafter"><p>Given a header field name <span class="tt">target_field_name</span> and <span class="tt">header_list</span>, a list of (<span class="tt">field_name</span>, <span class="tt">field_value</span>) tuples:</p></div><div id="rfc.section.2.2.1.p.2"><dl><dt>1)</dt><dd>Let <span class="tt">target_field_values</span> be an empty list.</dd><dt>2)</dt><dd>For each (<span class="tt">field_name</span>, <span class="tt">field_value</span>) tuple in <span class="tt">header_list</span>: <dl><dt>1)</dt><dd>If <span class="tt">field_name</span> does not match <span class="tt">target_field_name</span>, skip to the next tuple.</dd><dt>2)</dt><dd>Strip leading and trailing WSP from <span class="tt">field_value</span> and append it to <span class="tt">target_field_values</span>.</dd></dl></dd><dt>3)</dt><dd>If <span class="tt">target_field_values</span> is empty, return an empty string.</dd><dt>4)</dt><dd>Return the concatenation of <span class="tt">target_field_values</span>, separating each with “,” characters.</dd></dl></div></section><section id="fail-param"><h4 id="rfc.section.2.2.2"><a href="#rfc.section.2.2.2">2.2.2.</a>&nbsp;<a href="#fail-param">Failing Parameter Processing</a></h4><div id="rfc.section.2.2.2.p.1"><p>In some cases, a key parameter cannot determine a secondary cache key corresponding to its nominated header field value. When this happens, Key processing needs to fail safely, so that the correct behavior is observed.</p></div><div id="rfc.section.2.2.2.p.2"><p>When this happens, implementations MUST either behave as if the whole Key header field was not present (i.e., abort processing of Key, ignoring it entirely and falling back to Vary), or assure that the nominated header fields being compared match, as per <a href="#RFC7234"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Caching">[RFC7234]</cite></a>, Section 4.1 (i.e., treat the failing portion of the Key header as falling back to Vary, but continuing to process the rest).</p></div></section></section><section id="key-parameters"><h3 id="rfc.section.2.3"><a href="#rfc.section.2.3">2.3.</a>&nbsp;<a href="#key-parameters">Key Parameters</a></h3><div id="rfc.section.2.3.p.1"><p>A Key parameter associates a name with a specific processing algorithm that takes two inputs; a HTTP header value “header_value” (as described in <a href="#value" title="Creating a Header Field Value">Section&nbsp;2.2.1</a>), and “parameter_value”, a string that indicates how the identified header should be processed.</p></div><div id="rfc.section.2.3.p.2" class="avoidbreakafter"><p>The set of key parameters (and their associated processing algorithms) is extensible; see <a href="#iana" title="IANA Considerations">Section&nbsp;3</a>. This document defines the following key parameters:</p></div><section id="div"><h4 id="rfc.section.2.3.1"><a href="#rfc.section.2.3.1">2.3.1.</a>&nbsp;<a href="#div">div</a></h4><div id="rfc.section.2.3.1.p.1"><p>The “div” parameter normalizes positive integer header values into groups by dividing them by a configured value.</p></div><div id="rfc.section.2.3.1.p.2" class="avoidbreakafter"><p>Its value’s syntax is:</p></div><div id="rfc.figure.u.10"><pre class="inline">
div    = 1*DIGIT
</pre></div><div id="rfc.section.2.3.1.p.3" class="avoidbreakafter"><p>To process a set of header fields against a div parameter, follow these steps (or their equivalent):</p></div><div id="rfc.section.2.3.1.p.4"><dl><dt>1)</dt><dd>If <span class="tt">parameter_value</span> is “0”, fail parameter processing (<a href="#fail-param" title="Failing Parameter Processing">Section&nbsp;2.2.2</a>).</dd><dt>2)</dt><dd>If <span class="tt">header_value</span> is the empty string, return “none”.</dd><dt>3)</dt><dd>If <span class="tt">header_value</span> contains a “,”, remove it and all subsequent characters.</dd><dt>4)</dt><dd>Remove all WSP characters from <span class="tt">header_value</span>.</dd><dt>5)</dt><dd>If <span class="tt">header_value</span> does not match the div ABNF rule, fail parameter processing (<a href="#fail-param" title="Failing Parameter Processing">Section&nbsp;2.2.2</a>).</dd><dt>6)</dt><dd>Return the quotient of <span class="tt">header_value</span> / <span class="tt">parameter_value</span> (omitting the modulus).</dd></dl></div><div id="rfc.section.2.3.1.p.5" class="avoidbreakafter"><p>For example, the Key:</p></div><div id="rfc.figure.u.11"><pre class="text">
Key: Bar;div=5
</pre></div><div id="rfc.section.2.3.1.p.6" class="avoidbreakafter"><p>indicates that the “Bar” header’s field value should be partitioned into groups of 5. Thus, the following field values would be considered the same (because, divided by 5, they all result in 0):</p></div><div id="rfc.figure.u.12"><pre class="text">
Bar: 1
Bar: 3 , 42
Bar: 4, 1
</pre></div><div id="rfc.section.2.3.1.p.7"><p>whereas these would be considered to be in a different group (because, divided by 5, they all result in 2);</p></div><div id="rfc.figure.u.13"><pre class="text">
Bar: 12
Bar: 10
Bar: 14, 1
</pre></div></section><section id="partition"><h4 id="rfc.section.2.3.2"><a href="#rfc.section.2.3.2">2.3.2.</a>&nbsp;<a href="#partition">partition</a></h4><div id="rfc.section.2.3.2.p.1"><p>The “partition” parameter normalizes positive numeric header values into pre-defined segments.</p></div><div id="rfc.section.2.3.2.p.2" class="avoidbreakafter"><p>Its value’s syntax is:</p></div><div id="rfc.figure.u.14"><pre class="inline">
partition = [ segment ] *( ":" [ segment ] )
segment   = [ 0*DIGIT "." ] 1*DIGIT
</pre></div><div id="rfc.section.2.3.2.p.3" class="avoidbreakafter"><p>To process a set of header fields against a partition parameter, follow these steps (or their equivalent):</p></div><div id="rfc.section.2.3.2.p.4"><dl><dt>1)</dt><dd>If <span class="tt">header_value</span> is the empty string, return “none”.</dd><dt>2)</dt><dd>If <span class="tt">header_value</span> contains a “,”, remove it and all subsequent characters.</dd><dt>3)</dt><dd>Remove all WSP characters from <span class="tt">header_value</span>.</dd><dt>4)</dt><dd>If <span class="tt">header_value</span> does not match the segment ABNF rule, fail parameter processing (<a href="#fail-param" title="Failing Parameter Processing">Section&nbsp;2.2.2</a>).</dd><dt>5)</dt><dd>Let <span class="tt">segment_id</span> be 0.</dd><dt>6)</dt><dd>Create a list <span class="tt">segment_list</span> by splitting <span class="tt">parameter_value</span> on “:” characters.</dd><dt>7)</dt><dd>For each <span class="tt">segment_value</span> in <span class="tt">segment_list</span>: <dl><dt>1)</dt><dd>If <span class="tt">header_value</span> is less than <span class="tt">segment_value</span> when they are numerically compared, skip to step 7.</dd><dt>2)</dt><dd>Increment <span class="tt">segment_id</span> by 1.</dd></dl></dd><dt>8)</dt><dd>Return <span class="tt">segment_id</span>.</dd></dl></div><div id="rfc.section.2.3.2.p.5" class="avoidbreakafter"><p>For example, the Key:</p></div><div id="rfc.figure.u.15"><pre class="text">
Key: Foo;partition=20:30:40
</pre></div><div id="rfc.section.2.3.2.p.6" class="avoidbreakafter"><p>indicates that the “Foo” header’s field value should be divided into four segments:</p></div><div id="rfc.section.2.3.2.p.7"><ul><li>less than 20</li><li>20 to less than 30</li><li>30 to less than 40</li><li>forty or greater</li></ul></div><div id="rfc.section.2.3.2.p.8" class="avoidbreakafter"><p>Thus, the following headers would all be normalized to the first segment:</p></div><div id="rfc.figure.u.16"><pre class="text">
Foo: 1
Foo: 0
Foo: 4, 54
Foo: 19.9
</pre></div><div id="rfc.section.2.3.2.p.9" class="avoidbreakafter"><p>whereas the following would fall into the second segment:</p></div><div id="rfc.figure.u.17"><pre class="text">
Foo: 20
Foo: 29.999
Foo:  24   , 10
</pre></div></section><section id="match"><h4 id="rfc.section.2.3.3"><a href="#rfc.section.2.3.3">2.3.3.</a>&nbsp;<a href="#match">match</a></h4><div id="rfc.section.2.3.3.p.1"><p>The “match” parameter is used to determine if an exact value occurs in a list of header values. It is case-sensitive.</p></div><div id="rfc.section.2.3.3.p.2" class="avoidbreakafter"><p>Its value’s syntax is:</p></div><div id="rfc.figure.u.18"><pre class="inline">
match  = ( token / quoted-string )
</pre></div><div id="rfc.section.2.3.3.p.3" class="avoidbreakafter"><p>To process a set of header fields against a match parameter, follow these steps (or their equivalent):</p></div><div id="rfc.section.2.3.3.p.4"><dl><dt>1)</dt><dd>If <span class="tt">header_value</span> is the empty string, return “none”.</dd><dt>2)</dt><dd>Create <span class="tt">header_list</span> by splitting <span class="tt">header_value</span> on “,” characters.</dd><dt>3)</dt><dd>For each <span class="tt">header_item</span> in <span class="tt">header_list</span>: <dl><dt>1)</dt><dd>Remove leading and trailing WSP characters in <span class="tt">header_item</span>.</dd><dt>2)</dt><dd>If the value of <span class="tt">header_item</span> is character-for-character identical to <span class="tt">parameter_value</span>, return “1”.</dd></dl></dd><dt>4)</dt><dd>Return “0”.</dd></dl></div><div id="rfc.section.2.3.3.p.5" class="avoidbreakafter"><p>For example, the Key:</p></div><div id="rfc.figure.u.19"><pre class="text">
Key: Baz;match="charlie"
</pre></div><div id="rfc.section.2.3.3.p.6" class="avoidbreakafter"><p>Would return “1” for the following header field values:</p></div><div id="rfc.figure.u.20"><pre class="text">
Baz: charlie
Baz: foo, charlie
Baz: bar, charlie     , abc
</pre></div><div id="rfc.section.2.3.3.p.7" class="avoidbreakafter"><p>and “0” for these:</p></div><div id="rfc.figure.u.21"><pre class="text">
Baz: theodore
Baz: joe, sam
Baz: "charlie"
Baz: Charlie
Baz: cha rlie
Baz: charlie2
</pre></div></section><section id="substr"><h4 id="rfc.section.2.3.4"><a href="#rfc.section.2.3.4">2.3.4.</a>&nbsp;<a href="#substr">substr</a></h4><div id="rfc.section.2.3.4.p.1"><p>The “substr” parameter is used to determine if a value occurs as a substring of an item in a list of header values. It is case-sensitive.</p></div><div id="rfc.section.2.3.4.p.2" class="avoidbreakafter"><p>Its value’s syntax is:</p></div><div id="rfc.figure.u.22"><pre class="inline">
substr  = ( token / quoted-string )
</pre></div><div id="rfc.section.2.3.4.p.3" class="avoidbreakafter"><p>To process a set of header fields against a substr parameter, follow these steps (or their equivalent):</p></div><div id="rfc.section.2.3.4.p.4"><dl><dt>1)</dt><dd>If <span class="tt">header_value</span> is the empty string, return “none”.</dd><dt>2)</dt><dd>Create <span class="tt">header_list</span> by splitting <span class="tt">header_value</span> on “,” characters.</dd><dt>3)</dt><dd>For each <span class="tt">header_item</span> in <span class="tt">header_list</span>: <dl><dt>1)</dt><dd>Remove leading and trailing WSP characters in <span class="tt">header_item</span>.</dd><dt>2)</dt><dd>If the value of <span class="tt">parameter_value</span> is character-for-character present as a substring of <span class="tt">header_value</span>, return “1”.</dd></dl></dd><dt>4)</dt><dd>Return “0”.</dd></dl></div><div id="rfc.section.2.3.4.p.5" class="avoidbreakafter"><p>For example, the Key:</p></div><div id="rfc.figure.u.23"><pre class="text">
Key: Abc;substr=bennet
</pre></div><div id="rfc.section.2.3.4.p.6" class="avoidbreakafter"><p>Would return “1” for the following header field values:</p></div><div id="rfc.figure.u.24"><pre class="text">
Abc: bennet
Abc: foo, bennet
Abc: abennet00
Abc: bar, 99bennet     , abc
Abc: "bennet"
</pre></div><div id="rfc.section.2.3.4.p.7" class="avoidbreakafter"><p>and “0” for these:</p></div><div id="rfc.figure.u.25"><pre class="text">
Abc: theodore
Abc: joe, sam
Abc: Bennet
Abc: Ben net
</pre></div></section><section id="param"><h4 id="rfc.section.2.3.5"><a href="#rfc.section.2.3.5">2.3.5.</a>&nbsp;<a href="#param">param</a></h4><div id="rfc.section.2.3.5.p.1"><p>The “param” parameter considers the request header field as a list of key=value parameters, and uses the nominated key’s value as the secondary cache key.</p></div><div id="rfc.section.2.3.5.p.2" class="avoidbreakafter"><p>Its value’s syntax is:</p></div><div id="rfc.figure.u.26"><pre class="inline">
param  = ( token / quoted-string )
</pre></div><div id="rfc.section.2.3.5.p.3" class="avoidbreakafter"><p>To process a list of header fields against a param parameter, follow these steps (or their equivalent):</p></div><div id="rfc.section.2.3.5.p.4"><dl><dt>1)</dt><dd>Let <span class="tt">header_list</span> be an empty list.</dd><dt>2)</dt><dd>Create <span class="tt">header_list_tmp1</span> by splitting header_value on “,” characters.</dd><dt>3)</dt><dd>For each <span class="tt">header_item_tmp1</span> in <span class="tt">header_list_tmp1</span>: <dl><dt>1)</dt><dd>Create <span class="tt">header_list_tmp2</span> by splitting <span class="tt">header_item_tmp1</span> on “;” characters.</dd><dt>2)</dt><dd>For each <span class="tt">header_item_tmp2</span> in <span class="tt">header_list_tmp2</span>: <dl><dt>1)</dt><dd>Remove leading and trailing WSP from <span class="tt">header_item_tmp2</span>.</dd><dt>2)</dt><dd>Append <span class="tt">header_item_tmp2</span> to header_list.</dd></dl></dd></dl></dd><dt>4)</dt><dd>For each <span class="tt">header_item</span> in <span class="tt">header_list</span>: <dl><dt>1)</dt><dd>If the “=” character does not occur within <span class="tt">header_item</span>, skip to the next <span class="tt">header_item</span>.</dd><dt>2)</dt><dd>Let <span class="tt">item_name</span> be the string occurring before the first “=” character in <span class="tt">header_item</span>.</dd><dt>3)</dt><dd>If <span class="tt">item_name</span> does not case-insensitively match <span class="tt">parameter_value</span>, skip to the next <span class="tt">header_item</span>.</dd><dt>4)</dt><dd>Return the string occurring after the first “=” character in <span class="tt">header_item</span>.</dd></dl></dd><dt>5)</dt><dd>Return the empty string.</dd></dl></div><div id="rfc.section.2.3.5.p.5"><p>Note that steps 2 and 3 accommodate semicolon-separated values, so that it can be used with the Cookie request header field.</p></div><div id="rfc.section.2.3.5.p.6" class="avoidbreakafter"><p>For example, the Key:</p></div><div id="rfc.figure.u.27"><pre class="text">
Key: Def;param=liam
</pre></div><div id="rfc.section.2.3.5.p.7" class="avoidbreakafter"><p>The following headers would return the string (surrounded in single quotes) indicated:</p></div><div id="rfc.figure.u.28"><pre class="text">
Def: liam=123           // '123'
Def: mno=456            // ''
Def:                    // ''
Def: abc=123; liam=890  // '890'
Def: liam="678"         // '"678"'
</pre></div></section></section></section><section id="iana"><h2 id="rfc.section.3"><a href="#rfc.section.3">3.</a>&nbsp;<a href="#iana">IANA Considerations</a></h2><div id="rfc.section.3.p.1"><p>This specification defines the HTTP Key Parameter Registry, maintained at <a href="http://www.iana.org/assignments/http-parameters/http-parameters.xhtml#key">http://www.iana.org/assignments/http-parameters/http-parameters.xhtml#key</a>.</p></div><section id="procedure"><h3 id="rfc.section.3.1"><a href="#rfc.section.3.1">3.1.</a>&nbsp;<a href="#procedure">Procedure</a></h3><div id="rfc.section.3.1.p.1" class="avoidbreakafter"><p>Key Parameter registrations MUST include the following fields:</p></div><div id="rfc.section.3.1.p.2"><ul><li>Parameter Name: [name]</li><li>Reference: [Pointer to specification text]</li></ul></div><div id="rfc.section.3.1.p.3"><p>Values to be added to this namespace require IETF Review (see Section 4.1 of <a href="#RFC5226"><cite title="Guidelines for Writing an IANA Considerations Section in RFCs">[RFC5226]</cite></a>) and MUST conform to the purpose of content coding defined in this section.</p></div></section><section id="registrations"><h3 id="rfc.section.3.2"><a href="#rfc.section.3.2">3.2.</a>&nbsp;<a href="#registrations">Registrations</a></h3><div id="rfc.section.3.2.p.1" class="avoidbreakafter"><p>This specification makes the following entries in the HTTP Key Parameter Registry:</p></div><div id="rfc.table.u.1" class="table table-condensed table-striped"><table class="table table-condensed table-striped full text-center"><thead><tr><th class="left">Parameter Name</th><th class="left">Reference</th></tr></thead><tbody><tr><td class="text-left">div</td><td class="text-left"><a href="#div" title="div">Section&nbsp;2.3.1</a></td></tr><tr><td class="text-left">partition</td><td class="text-left"><a href="#partition" title="partition">Section&nbsp;2.3.2</a></td></tr><tr><td class="text-left">match</td><td class="text-left"><a href="#match" title="match">Section&nbsp;2.3.3</a></td></tr><tr><td class="text-left">substr</td><td class="text-left"><a href="#substr" title="substr">Section&nbsp;2.3.4</a></td></tr><tr><td class="text-left">param</td><td class="text-left"><a href="#param" title="param">Section&nbsp;2.3.5</a></td></tr></tbody></table></div></section></section><section id="security-considerations"><h2 id="rfc.section.4"><a href="#rfc.section.4">4.</a>&nbsp;<a href="#security-considerations">Security Considerations</a></h2><div id="rfc.section.4.p.1"><p>Because Key is an alternative to Vary, it is possible for caches to behave differently based upon whether they implement Key. Likewise, because support for any one Key parameter is not required, it is possible for different implementations of Key to behave differently. In both cases, an attacker might be able to exploit these differences.</p></div><div id="rfc.section.4.p.2"><p>This risk is mitigated by the requirement to fall back to Vary when unsupported parameters are encountered, coupled with the requirement that servers that use Key also include a relevant Vary header.</p></div><div id="rfc.section.4.p.3"><p>An attacker with the ability to inject response headers might be able to perform a cache poisoning attack that tailors a response to a specific user (e.g., by Keying to a Cookie that’s specific to them). While the attack is still possible without Key, the ability to tailor is new.</p></div><div id="rfc.section.4.p.4"><p>When implemented, Key might result in a larger number of stored responses for a given resource in caches; this, in turn, might be used to create an attack upon the cache itself. Good cache replacement algorithms and denial of service monitoring in cache implementations are reasonable mitigations against this risk.</p></div></section><section id="rfc.references"><h2 id="rfc.section.5"><a href="#rfc.section.5">5.</a> References</h2><section id="rfc.references.1"><h3 id="rfc.section.5.1"><a href="#rfc.section.5.1">5.1.</a> Normative References</h3><dl class="dl-horizontal"><dt id="RFC2119">[RFC2119]</dt><dd>Bradner, S., “<a href="https://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>”, BCP&nbsp;14, RFC&nbsp;2119, <a href="http://dx.doi.org/10.17487/RFC2119">DOI&nbsp;10.17487/RFC2119</a>, March&nbsp;1997, &lt;<a href="https://www.rfc-editor.org/info/rfc2119">https://www.rfc-editor.org/info/rfc2119</a>&gt;.</dd><dt id="RFC5234">[RFC5234]</dt><dd>Crocker, D., Ed. and P. Overell, “<a href="https://tools.ietf.org/html/rfc5234">Augmented BNF for Syntax Specifications: ABNF</a>”, STD&nbsp;68, RFC&nbsp;5234, <a href="http://dx.doi.org/10.17487/RFC5234">DOI&nbsp;10.17487/RFC5234</a>, January&nbsp;2008, &lt;<a href="https://www.rfc-editor.org/info/rfc5234">https://www.rfc-editor.org/info/rfc5234</a>&gt;.</dd><dt id="RFC7230">[RFC7230]</dt><dd>Fielding, R., Ed. and J. Reschke, Ed., “<a href="https://tools.ietf.org/html/rfc7230">Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</a>”, RFC&nbsp;7230, <a href="http://dx.doi.org/10.17487/RFC7230">DOI&nbsp;10.17487/RFC7230</a>, June&nbsp;2014, &lt;<a href="https://www.rfc-editor.org/info/rfc7230">https://www.rfc-editor.org/info/rfc7230</a>&gt;.</dd><dt id="RFC7231">[RFC7231]</dt><dd>Fielding, R., Ed. and J. Reschke, Ed., “<a href="https://tools.ietf.org/html/rfc7231">Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content</a>”, RFC&nbsp;7231, <a href="http://dx.doi.org/10.17487/RFC7231">DOI&nbsp;10.17487/RFC7231</a>, June&nbsp;2014, &lt;<a href="https://www.rfc-editor.org/info/rfc7231">https://www.rfc-editor.org/info/rfc7231</a>&gt;.</dd><dt id="RFC7234">[RFC7234]</dt><dd>Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke, Ed., “<a href="https://tools.ietf.org/html/rfc7234">Hypertext Transfer Protocol (HTTP/1.1): Caching</a>”, RFC&nbsp;7234, <a href="http://dx.doi.org/10.17487/RFC7234">DOI&nbsp;10.17487/RFC7234</a>, June&nbsp;2014, &lt;<a href="https://www.rfc-editor.org/info/rfc7234">https://www.rfc-editor.org/info/rfc7234</a>&gt;.</dd></dl></section><section id="rfc.references.2"><h3 id="rfc.section.5.2"><a href="#rfc.section.5.2">5.2.</a> Informative References</h3><dl class="dl-horizontal"><dt id="RFC5226">[RFC5226]</dt><dd>Narten, T. and H. Alvestrand, “<a href="https://tools.ietf.org/html/rfc5226">Guidelines for Writing an IANA Considerations Section in RFCs</a>”, RFC&nbsp;5226, <a href="http://dx.doi.org/10.17487/RFC5226">DOI&nbsp;10.17487/RFC5226</a>, May&nbsp;2008, &lt;<a href="https://www.rfc-editor.org/info/rfc5226">https://www.rfc-editor.org/info/rfc5226</a>&gt;.</dd><dt id="RFC6265">[RFC6265]</dt><dd>Barth, A., “<a href="https://tools.ietf.org/html/rfc6265">HTTP State Management Mechanism</a>”, RFC&nbsp;6265, <a href="http://dx.doi.org/10.17487/RFC6265">DOI&nbsp;10.17487/RFC6265</a>, April&nbsp;2011, &lt;<a href="https://www.rfc-editor.org/info/rfc6265">https://www.rfc-editor.org/info/rfc6265</a>&gt;.</dd></dl></section></section><section id="acknowledgements"><h2 id="rfc.section.A" class="np"><a href="#rfc.section.A">A.</a>&nbsp;<a href="#acknowledgements">Acknowledgements</a></h2><div id="rfc.section.A.p.1"><p>Thanks to Ilya Grigorik, Amos Jeffries and Yoav Weiss for their feedback.</p></div></section><section id="changes"><h2 id="rfc.section.B"><a href="#rfc.section.B">B.</a>&nbsp;<a href="#changes">Changes</a></h2><section id="since-00"><h3 id="rfc.section.B.1"><a href="#rfc.section.B.1">B.1.</a>&nbsp;<a href="#since-00">Since -00</a></h3><div id="rfc.section.B.1.p.1"><ul><li>Issue 108 (field-name cardinality) closed with no action.</li><li>Issue 104 (Support “Or” operator) closed with no action.</li><li>Issue 107 (Whitespace requirement) addressed by allowing whitespace around parameters.</li><li>Issue 106 (Policy for Key parameter registry) closed with no action.</li></ul></div></section><section id="since-01"><h3 id="rfc.section.B.2"><a href="#rfc.section.B.2">B.2.</a>&nbsp;<a href="#since-01">Since -01</a></h3><div id="rfc.section.B.2.p.1"><p>None yet.</p></div></section></section><section id="rfc.authors" class="avoidbreakinside"><h2><a href="#rfc.authors">Authors' Addresses</a></h2><address><b>Roy T. Fielding</b><br>Adobe Systems Incorporated<br>EMail: <a href="mailto:fielding@gbiv.com">fielding@gbiv.com</a><br>URI: <a href="http://roy.gbiv.com/">http://roy.gbiv.com/</a></address><address><b>Mark Nottingham</b><br>EMail: <a href="mailto:mnot@mnot.net">mnot@mnot.net</a><br>URI: <a href="https://www.mnot.net/">https://www.mnot.net/</a></address></section></div></div></div><script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script><script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.2.0/js/bootstrap.min.js"></script></body></html>